Nullable and Default Values
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Nullable Types
~~~~~~~~~~~~~~

Let's take a look at the following example.

.. literalinclude:: /../examples/primitives/cxx/nullables/nullable_utils.hpp
   :language: cpp
   :start-after: [example]
   :end-before: [example]

Iegen uses **nullable_arg** to identify which arguments are nullable. This is a list of argument names.
And for nullable return value uses **nullable_return**, which is a boolean tag.
Let's take a look at the above example. Here we have an overloaded method **max**. The first one has one nullable and one non null argument and it returns nullable value.
And the second one has two nullable arguments and  again returns nullable value.
In the above example you can find also constructor taking nullable argument and getters/setters which are nullable.

.. note::
    For getters/setters make sure that methods marked as **gen_getter** and **gen_setter** both are tagged similarly.
    If the getter is marked with **nullable_return: True** then setter should be marked with **nullable_arg: <arg_name>**.
    In the above example we have `nullable` tagged with gen_getter which returns nullable value
    and `setNullable` tagged with gen_setter having nullable argument.

In this example we use two helper structures `NumberInt` and `NumberDouble`. Note that first one is marked as shared_ref = True,
and the second one as shared_ref = False. Both cases are similar.
Here is the code for them.

.. literalinclude:: /../examples/primitives/cxx/nullables/nullable_utils.hpp
   :language: cpp
   :start-after: [example-helpers]
   :end-before: [example-helpers]

.. note::
    Kotlin and swift have a support for nullable types.
    For python nullable arguments and return values are marked as Optional.
    And as for python everything is nullable iegen does additional checks to not allow passing nullable values where non nulls are expected.

Now let's see some usage examples for generated wrappers.

.. tabs::
    .. tab:: kotlin

        .. literalinclude:: /../examples/primitives/kotlin/src/main/java/com/examples/nullables/main.kt
           :language: kotlin
           :start-after: [nullables-usage]
           :end-before: [nullables-usage]

    .. tab:: python

        As you can see here `ValueError` is thrown when None is passed but expected value is not Optional.
        The same is for return values.

        .. literalinclude:: /../examples/primitives/python/src/examples_lib/nullables/main.py
            :language: py
            :start-after: [nullables-usage]
            :end-before: [nullables-usage]

    .. tab:: swift

        .. literalinclude:: /../examples/primitives/swift/src/nullables/main.swift
            :language: swift
            :start-after: [nullables-usage]
            :end-before: [nullables-usage]

.. collapse:: Generated bindings

    |

    .. tabs::
        .. tab:: kotlin

            .. literalinclude:: /../examples/primitives/kotlin/src/main/java/com/examples/nullables/nullable_utils.kt
                :language: kotlin

        .. tab:: python

            .. literalinclude:: /../examples/primitives/python/src/examples_lib/nullables/nullable_utils_pygen.py
                :language: py

        .. tab:: swift

            .. literalinclude:: /../examples/primitives/swift/src/nullables/NullableUtils.swift
                :language: swift

|

Default Values
~~~~~~~~~~~~~~

Let's take a look at the following example.

.. literalinclude:: /../examples/primitives/cxx/optionals/optionals.hpp
   :language: cpp
   :start-after: [example]
   :end-before: [example]

In this example each method takes a single optional argument and returns it.
Default values are supported in the following cases:
    * For primitive types e.g. int, long, char etc.
    * For char*, std::string.
    * For enums.
    * If the default value is **nullptr** or **NULL**.

These are the cases supported for all languages.

Callable expressions(for example **Task("MyTask")**) are supported only for python. Note that in this case the default value in generated
python api will be **None**. But under the hood the actual default value will be used.

Here's the usage:

.. tabs::
    .. tab:: kotlin

        .. literalinclude:: /../examples/primitives/kotlin/src/main/java/com/examples/optionals/main.kt
           :language: kotlin
           :start-after: [optionals-usage]
           :end-before: [optionals-usage]

    .. tab:: python

        As we can see here we did not pass anything to methods **optional_ref_with_default_complex_value** and
        **optional_by_val_with_default_complex_value** but the default Task("MyTask") is returned.

        .. literalinclude:: /../examples/primitives/python/src/examples_lib/optionals/main.py
            :language: py
            :start-after: [optionals-usage]
            :end-before: [optionals-usage]

.. note::
    If the argument which has a default value is of a custom type(binding is not generated by iegen) and it's built under separate package
    then user should generate __init__.py under root package with an appropriate import statement via iegen API.
    This can be done by adding **gen_package** action and an import statement with **python.code_fragment** variable to source root dir.
    For more details about gen_package please check <appropriate_section_here.>.

.. collapse:: Generated bindings

    |

    .. tabs::
        .. tab:: kotlin

            .. literalinclude:: /../examples/primitives/kotlin/src/main/java/com/examples/optionals/optionals.kt
               :language: kotlin

        .. tab:: python

            Notice that the default value for **optional_by_val_with_default_complex_value** and **optional_ref_with_default_complex_value** is **None**.
            But if user does not specify a value for task argument then the default value from the original code i.e. **Task("MyTask")** will be used.

            .. literalinclude:: /../examples/primitives/python/src/examples_lib/optionals/optionals_pygen.py
                :language: py

|
