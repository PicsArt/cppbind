rules:
  kotlin.type_converters:
    cppbind::example::Size:
      custom:
        pname: Object
        tname: PointFloat
      types:
        kotlin: Point2D.Float
        jni: jfloatArray
        jdk: FloatArray
      converters:
        jni_to_cxx: |
          jfloat *elems = env->GetFloatArrayElements({{name}}, 0);
          jfloat width_{{name}} = elems[0];
          jfloat height_{{name}} = elems[1];
          env->ReleaseFloatArrayElements({{name}}, elems, 0);
          {{target_type_name}} {{target_name}} = {{cxx_unqualified_resolved_type_name}}(width_{{name}}, height_{{name}});
        cxx_to_jni: |
          jfloat width_{{name}} = {{name}}.width;
          jfloat height_{{name}} = {{name}}.height;
          {{target_type_name}} {{target_name}} = env->NewFloatArray(2);
          jfloat carray[] = {width_{{name}}, height_{{name}}};
          env->SetFloatArrayRegion({{target_name}}, 0 , 2, carray);
        kotlin_to_jdk: |
          val width_{{name}} = {{name}}.getX().toFloat()
          val height_{{name}} = {{name}}.getY().toFloat()
          val {{target_name}} = {{target_type_name}}(2)
          {{target_name}}.set(0, width_{{name}})
          {{target_name}}.set(1, height_{{name}})
        jdk_to_kotlin: |
          val width_{{name}} = {{name}}[0]
          val height_{{name}} = {{name}}[1]
          val {{target_name}} = {{target_type_name}}(width_{{name}}, height_{{name}})

  python.type_converters:
    cppbind::example::Size:
      custom:
        pname: SizeF
        tname: SizeF
      types:
        python: SizeF
        pybind: SizeF
      converters:
        pybind_to_cxx:
        cxx_to_pybind:
        python_to_pybind:
        pybind_to_python:


  swift.type_converters:
    cppbind::example::Size:
      custom:
        is_c_pointer_type: False
      types:
        swift: "(Float, Float)"
        c: "CppBindCDataPair"
        sc: "CppBindCDataPair"
      converters:
        c_to_cxx: |
          auto& first_tmp_{{name}} = *reinterpret_cast<float*>({{name}}.first);
          auto& second_tmp_{{name}} = *reinterpret_cast<float*>({{name}}.second);
          {{target_type_name}} {{target_name}} { first_tmp_{{name}}, second_tmp_{{name}} };
        cxx_to_c: |
          auto _first_data_{{target_name}} = new float;
          auto _second_data_{{target_name}} = new float;
          *_first_data_{{target_name}} = {{name}}.width;
          *_second_data_{{target_name}} = {{name}}.height;
          {{target_type_name}} {{target_name}} = { _first_data_{{target_name}}, _second_data_{{target_name}} };
        swift_to_sc: |
          let {{target_name}}First = UnsafeMutablePointer<Float>.allocate(capacity: 1)
          let {{target_name}}Second = UnsafeMutablePointer<Float>.allocate(capacity: 1)
          defer {
            {{target_name}}First.deallocate()
            {{target_name}}Second.deallocate()
          }
          var {{target_name}} = {{target_type_name}}()
          {{target_name}}.first = UnsafeMutableRawPointer({{target_name}}First)
          {{target_name}}.second = UnsafeMutableRawPointer({{target_name}}Second)
          {{target_name}}First[0] = {{name}}.0
          {{target_name}}Second[0] = {{name}}.1
        sc_to_swift: |
          let {{name}}FirstData = UnsafeBufferPointer<Float>(start: {{name}}.first.assumingMemoryBound(to: Float.self), count: 1)
          let {{name}}SecondData = UnsafeBufferPointer<Float>(start: {{name}}.second.assumingMemoryBound(to: Float.self), count: 1)
          defer {
            {{name}}FirstData.deallocate()
            {{name}}SecondData.deallocate()
          }
          let {{target_name}}First = {{name}}FirstData[0]
          let {{target_name}}Second = {{name}}SecondData[0]
          let {{target_name}}: (Float, Float) = ({{target_name}}First, {{target_name}}Second)