rules:
  kotlin.type_converters:
    iegen::example::Size:
      custom:
        pname: Object
      types:
        kotlin: Point2D.Float
        jni: jfloatArray
        jdk: FloatArray
      converters:
        jni_to_cxx: |
          jfloat *elems = env->GetFloatArrayElements({{name}}, 0);
          jfloat width_{{name}} = elems[0];
          jfloat height_{{name}} = elems[1];
          env->ReleaseFloatArrayElements({{name}}, elems, 0);
          {{target_type_name}} {{target_name}} = {{cxx_pointee_unqualified_name}}(width_{{name}}, height_{{name}});
        cxx_to_jni: |
          jfloat width_{{name}} = {{name}}.width;
          jfloat height_{{name}} = {{name}}.height;
          {{target_type_name}} {{target_name}} = env->NewFloatArray(2);
          jfloat carray[] = {width_{{name}}, height_{{name}}};
          env->SetFloatArrayRegion({{target_name}}, 0 , 2, carray);
        kotlin_to_jdk: |
          val width_{{name}} = {{name}}.getX().toFloat()
          val height_{{name}} = {{name}}.getY().toFloat()
          val {{target_name}} = {{target_type_name}}(2)
          {{target_name}}.set(0, width_{{name}})
          {{target_name}}.set(1, height_{{name}})
        jdk_to_kotlin: |
          val width_{{name}} = {{name}}[0]
          val height_{{name}} = {{name}}[1]
          val {{target_name}} = {{target_type_name}}(width_{{name}}, height_{{name}})

  python.type_converters:
    iegen::example::Size:
      custom:
        pname: SizeF
      types:
        python: SizeF
        pybind: SizeF
      converters:
        pybind_to_cxx:
        cxx_to_pybind:
        python_to_pybind:
        pybind_to_python:


  swift.type_converters:
    iegen::example::Size:
      custom:
        is_c_pointer_type: False
      types:
        swift: "(Float, Float)"
        c: "CDataPair"
        sc: "CDataPair"
      converters:
        c_to_cxx: |
          auto first_tmp_{{name}} = *reinterpret_cast<float*>({{name}}.first);
          auto second_tmp_{{name}} = *reinterpret_cast<float*>({{name}}.second);
          {{target_type_name}} {{target_name}} { first_tmp_{{name}}, second_tmp_{{name}} };
        cxx_to_c: |
          auto _first_data_{{target_name}} = new float;
          auto _second_data_{{target_name}} = new float;
          *_first_data_{{target_name}} = {{name}}.width;
          *_second_data_{{target_name}} = {{name}}.height;
          {{target_type_name}} {{target_name}} = { _first_data_{{target_name}}, _second_data_{{target_name}} };
        swift_to_sc: |
          let _first_{{target_name}} = UnsafeMutablePointer<Float>.allocate(capacity: 1)
          let _second_{{target_name}} = UnsafeMutablePointer<Float>.allocate(capacity: 1)
          defer {
            _first_{{target_name}}.deallocate()
            _second_{{target_name}}.deallocate()
          }
          var {{target_name}} = {{target_type_name}}()
          {{target_name}}.first = UnsafeMutableRawPointer(_first_{{target_name}})
          {{target_name}}.second = UnsafeMutableRawPointer(_second_{{target_name}})
          _first_{{target_name}}[0] = {{name}}.0
          _second_{{target_name}}[0] = {{name}}.1
        sc_to_swift: |
          let _tmp_pair_first_{{name}}_data = UnsafeBufferPointer<Float>(start: {{name}}.first.assumingMemoryBound(to: Float.self), count: 1)
          let _tmp_pair_second_{{name}}_data = UnsafeBufferPointer<Float>(start: {{name}}.second.assumingMemoryBound(to: Float.self), count: 1)
          defer {
            _tmp_pair_first_{{name}}_data.deallocate()
            _tmp_pair_second_{{name}}_data.deallocate()
          }
          let first_{{target_name}} = _tmp_pair_first_{{name}}_data[0]
          let second_{{target_name}} = _tmp_pair_second_{{name}}_data[0]
          let {{target_name}}: (Float, Float) = (first_{{target_name}}, second_{{target_name}})