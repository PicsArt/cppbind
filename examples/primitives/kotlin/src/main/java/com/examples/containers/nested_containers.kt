/**
 *   ______ .______   .______   .______    __  .__   __.  _______  
 *  /      ||   _  \  |   _  \  |   _  \  |  | |  \ |  | |       \ 
 * |  ,----'|  |_)  | |  |_)  | |  |_)  | |  | |   \|  | |  .--.  |
 * |  |     |   ___/  |   ___/  |   _  <  |  | |  . `  | |  |  |  |
 * |  `----.|  |      |  |      |  |_)  | |  | |  |\   | |  '--'  |
 *  \______|| _|      | _|      |______/  |__| |__| \__| |_______/ 
 * 
 * This file is generated by cppbind on 08/11/2022-07:03.
 * Please do not change it manually.
 */

package com.examples.containers

import com.examples.cppbind.*
import com.examples.cppbind.exception_helpers.*

open class NestedExamples
internal constructor(obj: CppBindObject) : AutoCloseable {
    companion object {
        init {
            System.loadLibrary("wrapper_jni")
        }
        
        /**
         * comments
         * 
         */
        protected fun constructHelper(): Long {
            val id = jConstructor()
            return id
        }

        @JvmStatic
        private external fun jConstructor(): Long
        /**
         * An internal property to keep an information about the underlying C++ object type.
         * It is intended to be used by the generated code.
         */
        const val cppbindCxxTypeName: String = "cppbind::example::NestedExamples"
    }
    
    protected var cppbindObj = obj
    private var refs: MutableList<Any> = mutableListOf()

    /**
     * An internal method to bind the lifetimes of the current and another object.
     * It is intended to be used by the generated code.
     */
    fun keepCppBindReference(ref: Any) {
        refs.add(ref)
    }
    /**
     * An internal getter to get the id of an object.
     * It is intended to be used by the generated code.
     */
    
    open val cppbindObjId: Long
        get() {
            if (cppbindObj.id == 0L) {
                throw RuntimeException("Object is not allocated")
            }
            return cppbindObj.id
        }

    /**
     * An internal property returning underlying C++ object id.
     * It is intended to be used by the generated code.
     */
    internal val cxxId: Long by lazy {
        jGetcxxid(cppbindObj.id)
    }

    /**
     * An internal property returning underlying C++ type name.
     * It is intended to be used by the generated code.
     */
    internal val cxxTypeName: String by lazy {
        jGettypebyid(cppbindObj.id)
    }
    
    /**
     * comments
     * 
     */
    constructor(): this(CppBindObject(constructHelper(), true)) {
    }
    
    fun setNestedIntVector(v: List<List<Int>>): Unit {
        val kotlintojdkv = ObjectArray(v.size) { Any() }
        var indexV = 0
        for (valueV in v) {
            val kotlintojdkvalueV = IntArray(valueV.size) 
            var indexValuev = 0
            for (valueValuev in valueV) {
                
                kotlintojdkvalueV[indexValuev] = valueValuev
                ++indexValuev
            }
            kotlintojdkv[indexV] = kotlintojdkvalueV
            ++indexV
        }
        val result = jSetnestedintvector(cppbindObjId, kotlintojdkv, v)
        
        return result
    }

    fun getNestedIntVector(): List<List<Int>> {
        val result = jGetnestedintvector(cppbindObjId)
        val jdktokotlinresult: MutableList<List<Int>> = mutableListOf()
        for (valueResult in result) {
            @Suppress("UNCHECKED_CAST") val actualValueresult = valueResult as IntArray
            val jdktokotlinactualValueresult: MutableList<Int> = mutableListOf()
            for (valueActualvalueresult in actualValueresult) {
                
                jdktokotlinactualValueresult.add(valueActualvalueresult)
            }
            jdktokotlinresult.add(jdktokotlinactualValueresult)
        }
        return jdktokotlinresult
    }

    fun setNestedIntMap(m: Map<Int, Map<Int, Int>>): Unit {
        
        val tmpKeyKotlintojdkm = IntArray(m.size) 
        val tmpValKotlintojdkm = ObjectArray(m.size) { Any() }
        val kotlintojdkm = Pair<IntArray, ObjectArray>(tmpKeyKotlintojdkm, tmpValKotlintojdkm)
        var indexM = 0
        for ((keyM, valueM) in m) {
            
            
            val tmpKeyKotlintojdkvaluem = IntArray(valueM.size) 
            val tmpValKotlintojdkvaluem = IntArray(valueM.size) 
            val kotlintojdkvalueM = Pair<IntArray, IntArray>(tmpKeyKotlintojdkvaluem, tmpValKotlintojdkvaluem)
            var indexValuem = 0
            for ((keyValuem, valueValuem) in valueM) {
                
                
                tmpKeyKotlintojdkvaluem[indexValuem] = keyValuem
                tmpValKotlintojdkvaluem[indexValuem] = valueValuem
                ++indexValuem
            }
            tmpKeyKotlintojdkm[indexM] = keyM
            tmpValKotlintojdkm[indexM] = kotlintojdkvalueM
            ++indexM
        }
        val result = jSetnestedintmap(cppbindObjId, kotlintojdkm, m)
        
        return result
    }

    fun getNestedIntMap(): Map<Int, Map<Int, Int>> {
        val result = jGetnestedintmap(cppbindObjId)
        val jdktokotlinresult = HashMap<Int, Map<Int, Int>>()
        for (iResult in 0..result.first.size - 1) {
            val elem1Result = result.first.get(iResult)
            @Suppress("UNCHECKED_CAST") val elem2Result = result.second.get(iResult) as Pair<IntArray, IntArray>
            
            val jdktokotlinelem2Result = HashMap<Int, Int>()
            for (iElem2result in 0..elem2Result.first.size - 1) {
                val elem1Elem2result = elem2Result.first.get(iElem2result)
                val elem2Elem2result = elem2Result.second.get(iElem2result)
                
                
                jdktokotlinelem2Result.put(elem1Elem2result, elem2Elem2result)
            }
            jdktokotlinresult.put(elem1Result, jdktokotlinelem2Result)
        }
        return jdktokotlinresult
    }

    fun mixedExampleWithManyArgs(v1: List<List<Int>>, v2: List<List<Int>>, m1: Map<Int, Map<Int, Int>>, m2: Map<Int, Map<Int, Int>>): Unit {
        val kotlintojdkv1 = ObjectArray(v1.size) { Any() }
        var indexV1 = 0
        for (valueV1 in v1) {
            val kotlintojdkvalueV1 = IntArray(valueV1.size) 
            var indexValuev1 = 0
            for (valueValuev1 in valueV1) {
                
                kotlintojdkvalueV1[indexValuev1] = valueValuev1
                ++indexValuev1
            }
            kotlintojdkv1[indexV1] = kotlintojdkvalueV1
            ++indexV1
        }
        val kotlintojdkv2 = ObjectArray(v2.size) { Any() }
        var indexV2 = 0
        for (valueV2 in v2) {
            val kotlintojdkvalueV2 = IntArray(valueV2.size) 
            var indexValuev2 = 0
            for (valueValuev2 in valueV2) {
                
                kotlintojdkvalueV2[indexValuev2] = valueValuev2
                ++indexValuev2
            }
            kotlintojdkv2[indexV2] = kotlintojdkvalueV2
            ++indexV2
        }
        
        val tmpKeyKotlintojdkm1 = IntArray(m1.size) 
        val tmpValKotlintojdkm1 = ObjectArray(m1.size) { Any() }
        val kotlintojdkm1 = Pair<IntArray, ObjectArray>(tmpKeyKotlintojdkm1, tmpValKotlintojdkm1)
        var indexM1 = 0
        for ((keyM1, valueM1) in m1) {
            
            
            val tmpKeyKotlintojdkvaluem1 = IntArray(valueM1.size) 
            val tmpValKotlintojdkvaluem1 = IntArray(valueM1.size) 
            val kotlintojdkvalueM1 = Pair<IntArray, IntArray>(tmpKeyKotlintojdkvaluem1, tmpValKotlintojdkvaluem1)
            var indexValuem1 = 0
            for ((keyValuem1, valueValuem1) in valueM1) {
                
                
                tmpKeyKotlintojdkvaluem1[indexValuem1] = keyValuem1
                tmpValKotlintojdkvaluem1[indexValuem1] = valueValuem1
                ++indexValuem1
            }
            tmpKeyKotlintojdkm1[indexM1] = keyM1
            tmpValKotlintojdkm1[indexM1] = kotlintojdkvalueM1
            ++indexM1
        }
        
        val tmpKeyKotlintojdkm2 = IntArray(m2.size) 
        val tmpValKotlintojdkm2 = ObjectArray(m2.size) { Any() }
        val kotlintojdkm2 = Pair<IntArray, ObjectArray>(tmpKeyKotlintojdkm2, tmpValKotlintojdkm2)
        var indexM2 = 0
        for ((keyM2, valueM2) in m2) {
            
            
            val tmpKeyKotlintojdkvaluem2 = IntArray(valueM2.size) 
            val tmpValKotlintojdkvaluem2 = IntArray(valueM2.size) 
            val kotlintojdkvalueM2 = Pair<IntArray, IntArray>(tmpKeyKotlintojdkvaluem2, tmpValKotlintojdkvaluem2)
            var indexValuem2 = 0
            for ((keyValuem2, valueValuem2) in valueM2) {
                
                
                tmpKeyKotlintojdkvaluem2[indexValuem2] = keyValuem2
                tmpValKotlintojdkvaluem2[indexValuem2] = valueValuem2
                ++indexValuem2
            }
            tmpKeyKotlintojdkm2[indexM2] = keyM2
            tmpValKotlintojdkm2[indexM2] = kotlintojdkvalueM2
            ++indexM2
        }
        val result = jMixedexamplewithmanyargs(cppbindObjId, kotlintojdkv1, kotlintojdkv2, kotlintojdkm1, kotlintojdkm2, v1, v2, m1, m2)
        
        return result
    }

    fun setVectorOfIntMaps(v: List<Map<Int, Int>>): Unit {
        val kotlintojdkv = ObjectArray(v.size) { Any() }
        var indexV = 0
        for (valueV in v) {
            
            val tmpKeyKotlintojdkvaluev = IntArray(valueV.size) 
            val tmpValKotlintojdkvaluev = IntArray(valueV.size) 
            val kotlintojdkvalueV = Pair<IntArray, IntArray>(tmpKeyKotlintojdkvaluev, tmpValKotlintojdkvaluev)
            var indexValuev = 0
            for ((keyValuev, valueValuev) in valueV) {
                
                
                tmpKeyKotlintojdkvaluev[indexValuev] = keyValuev
                tmpValKotlintojdkvaluev[indexValuev] = valueValuev
                ++indexValuev
            }
            kotlintojdkv[indexV] = kotlintojdkvalueV
            ++indexV
        }
        val result = jSetvectorofintmaps(cppbindObjId, kotlintojdkv, v)
        
        return result
    }

    fun getVectorOfIntMaps(): List<Map<Int, Int>> {
        val result = jGetvectorofintmaps(cppbindObjId)
        val jdktokotlinresult: MutableList<Map<Int, Int>> = mutableListOf()
        for (valueResult in result) {
            @Suppress("UNCHECKED_CAST") val actualValueresult = valueResult as Pair<IntArray, IntArray>
            val jdktokotlinactualValueresult = HashMap<Int, Int>()
            for (iActualvalueresult in 0..actualValueresult.first.size - 1) {
                val elem1Actualvalueresult = actualValueresult.first.get(iActualvalueresult)
                val elem2Actualvalueresult = actualValueresult.second.get(iActualvalueresult)
                
                
                jdktokotlinactualValueresult.put(elem1Actualvalueresult, elem2Actualvalueresult)
            }
            jdktokotlinresult.add(jdktokotlinactualValueresult)
        }
        return jdktokotlinresult
    }

    fun setMapOfIntVectors(m: Map<Int, List<Int>>): Unit {
        
        val tmpKeyKotlintojdkm = IntArray(m.size) 
        val tmpValKotlintojdkm = ObjectArray(m.size) { Any() }
        val kotlintojdkm = Pair<IntArray, ObjectArray>(tmpKeyKotlintojdkm, tmpValKotlintojdkm)
        var indexM = 0
        for ((keyM, valueM) in m) {
            
            val kotlintojdkvalueM = IntArray(valueM.size) 
            var indexValuem = 0
            for (valueValuem in valueM) {
                
                kotlintojdkvalueM[indexValuem] = valueValuem
                ++indexValuem
            }
            tmpKeyKotlintojdkm[indexM] = keyM
            tmpValKotlintojdkm[indexM] = kotlintojdkvalueM
            ++indexM
        }
        val result = jSetmapofintvectors(cppbindObjId, kotlintojdkm, m)
        
        return result
    }

    fun getMapOfIntVectors(): Map<Int, List<Int>> {
        val result = jGetmapofintvectors(cppbindObjId)
        val jdktokotlinresult = HashMap<Int, List<Int>>()
        for (iResult in 0..result.first.size - 1) {
            val elem1Result = result.first.get(iResult)
            @Suppress("UNCHECKED_CAST") val elem2Result = result.second.get(iResult) as IntArray
            
            val jdktokotlinelem2Result: MutableList<Int> = mutableListOf()
            for (valueElem2result in elem2Result) {
                
                jdktokotlinelem2Result.add(valueElem2result)
            }
            jdktokotlinresult.put(elem1Result, jdktokotlinelem2Result)
        }
        return jdktokotlinresult
    }

    fun setComplexStringVector(v: List<List<List<String>>>): Unit {
        val kotlintojdkv = ObjectArray(v.size) { Any() }
        var indexV = 0
        for (valueV in v) {
            val kotlintojdkvalueV = ObjectArray(valueV.size) { Any() }
            var indexValuev = 0
            for (valueValuev in valueV) {
                val kotlintojdkvalueValuev = ObjectArray(valueValuev.size) { Any() }
                var indexValuevaluev = 0
                for (valueValuevaluev in valueValuev) {
                    
                    kotlintojdkvalueValuev[indexValuevaluev] = valueValuevaluev
                    ++indexValuevaluev
                }
                kotlintojdkvalueV[indexValuev] = kotlintojdkvalueValuev
                ++indexValuev
            }
            kotlintojdkv[indexV] = kotlintojdkvalueV
            ++indexV
        }
        val result = jSetcomplexstringvector(cppbindObjId, kotlintojdkv, v)
        
        return result
    }

    fun getComplexStringVector(): List<List<List<String>>> {
        val result = jGetcomplexstringvector(cppbindObjId)
        val jdktokotlinresult: MutableList<List<List<String>>> = mutableListOf()
        for (valueResult in result) {
            @Suppress("UNCHECKED_CAST") val actualValueresult = valueResult as ObjectArray
            val jdktokotlinactualValueresult: MutableList<List<String>> = mutableListOf()
            for (valueActualvalueresult in actualValueresult) {
                @Suppress("UNCHECKED_CAST") val actualValueactualvalueresult = valueActualvalueresult as ObjectArray
                val jdktokotlinactualValueactualvalueresult: MutableList<String> = mutableListOf()
                for (valueActualvalueactualvalueresult in actualValueactualvalueresult) {
                    @Suppress("UNCHECKED_CAST") val actualValueactualvalueactualvalueresult = valueActualvalueactualvalueresult as String
                    
                    jdktokotlinactualValueactualvalueresult.add(actualValueactualvalueactualvalueresult)
                }
                jdktokotlinactualValueresult.add(jdktokotlinactualValueactualvalueresult)
            }
            jdktokotlinresult.add(jdktokotlinactualValueresult)
        }
        return jdktokotlinresult
    }

    fun setComplexStringMap(m: Map<String, Map<String, Map<String, String>>>): Unit {
        
        val tmpKeyKotlintojdkm = ObjectArray(m.size) { Any() }
        val tmpValKotlintojdkm = ObjectArray(m.size) { Any() }
        val kotlintojdkm = Pair<ObjectArray, ObjectArray>(tmpKeyKotlintojdkm, tmpValKotlintojdkm)
        var indexM = 0
        for ((keyM, valueM) in m) {
            
            
            val tmpKeyKotlintojdkvaluem = ObjectArray(valueM.size) { Any() }
            val tmpValKotlintojdkvaluem = ObjectArray(valueM.size) { Any() }
            val kotlintojdkvalueM = Pair<ObjectArray, ObjectArray>(tmpKeyKotlintojdkvaluem, tmpValKotlintojdkvaluem)
            var indexValuem = 0
            for ((keyValuem, valueValuem) in valueM) {
                
                
                val tmpKeyKotlintojdkvaluevaluem = ObjectArray(valueValuem.size) { Any() }
                val tmpValKotlintojdkvaluevaluem = ObjectArray(valueValuem.size) { Any() }
                val kotlintojdkvalueValuem = Pair<ObjectArray, ObjectArray>(tmpKeyKotlintojdkvaluevaluem, tmpValKotlintojdkvaluevaluem)
                var indexValuevaluem = 0
                for ((keyValuevaluem, valueValuevaluem) in valueValuem) {
                    
                    
                    tmpKeyKotlintojdkvaluevaluem[indexValuevaluem] = keyValuevaluem
                    tmpValKotlintojdkvaluevaluem[indexValuevaluem] = valueValuevaluem
                    ++indexValuevaluem
                }
                tmpKeyKotlintojdkvaluem[indexValuem] = keyValuem
                tmpValKotlintojdkvaluem[indexValuem] = kotlintojdkvalueValuem
                ++indexValuem
            }
            tmpKeyKotlintojdkm[indexM] = keyM
            tmpValKotlintojdkm[indexM] = kotlintojdkvalueM
            ++indexM
        }
        val result = jSetcomplexstringmap(cppbindObjId, kotlintojdkm, m)
        
        return result
    }

    fun getComplexStringMap(): Map<String, Map<String, Map<String, String>>> {
        val result = jGetcomplexstringmap(cppbindObjId)
        val jdktokotlinresult = HashMap<String, Map<String, Map<String, String>>>()
        for (iResult in 0..result.first.size - 1) {
            @Suppress("UNCHECKED_CAST") val elem1Result = result.first.get(iResult) as String
            @Suppress("UNCHECKED_CAST") val elem2Result = result.second.get(iResult) as Pair<ObjectArray, ObjectArray>
            
            val jdktokotlinelem2Result = HashMap<String, Map<String, String>>()
            for (iElem2result in 0..elem2Result.first.size - 1) {
                @Suppress("UNCHECKED_CAST") val elem1Elem2result = elem2Result.first.get(iElem2result) as String
                @Suppress("UNCHECKED_CAST") val elem2Elem2result = elem2Result.second.get(iElem2result) as Pair<ObjectArray, ObjectArray>
                
                val jdktokotlinelem2Elem2result = HashMap<String, String>()
                for (iElem2elem2result in 0..elem2Elem2result.first.size - 1) {
                    @Suppress("UNCHECKED_CAST") val elem1Elem2elem2result = elem2Elem2result.first.get(iElem2elem2result) as String
                    @Suppress("UNCHECKED_CAST") val elem2Elem2elem2result = elem2Elem2result.second.get(iElem2elem2result) as String
                    
                    
                    jdktokotlinelem2Elem2result.put(elem1Elem2elem2result, elem2Elem2elem2result)
                }
                jdktokotlinelem2Result.put(elem1Elem2result, jdktokotlinelem2Elem2result)
            }
            jdktokotlinresult.put(elem1Result, jdktokotlinelem2Result)
        }
        return jdktokotlinresult
    }

    /**
     * CppBind generated hashCode method returning the hash of underlying C++ object id.
     */
    override fun hashCode(): Int {
        return cxxId.hashCode()
    }

    /**
     * CppBind generated equals method comparing the underlying C++ object ids.
     */
    override fun equals(other: Any?): Boolean {
        other as NestedExamples
        return cxxId == other.cxxId
    }

    /**
     * CppBind generated toString method returning underlying C++ object type and id.
     */
    override fun toString(): String {
        return "<0x$cxxId: $cxxTypeName>"
    }

    override fun close() {
        if (cppbindObj.owner && cppbindObj.id != 0L) {
            jFinalize(cppbindObj.id)
            cppbindObj.id = 0L
        }
    }

    /**
     * Finalize and deletes the object
     */
    protected fun finalize() {
        close()
    }

    ///// External wrapper functions ////////////
    private external fun jSetnestedintvector(id: Long, v: ObjectArray, vararg extraObjs: Any?): Unit
    private external fun jGetnestedintvector(id: Long): ObjectArray
    private external fun jSetnestedintmap(id: Long, m: Pair<IntArray, ObjectArray>, vararg extraObjs: Any?): Unit
    private external fun jGetnestedintmap(id: Long): Pair<IntArray, ObjectArray>
    private external fun jMixedexamplewithmanyargs(id: Long, v1: ObjectArray, v2: ObjectArray, m1: Pair<IntArray, ObjectArray>, m2: Pair<IntArray, ObjectArray>, vararg extraObjs: Any?): Unit
    private external fun jSetvectorofintmaps(id: Long, v: ObjectArray, vararg extraObjs: Any?): Unit
    private external fun jGetvectorofintmaps(id: Long): ObjectArray
    private external fun jSetmapofintvectors(id: Long, m: Pair<IntArray, ObjectArray>, vararg extraObjs: Any?): Unit
    private external fun jGetmapofintvectors(id: Long): Pair<IntArray, ObjectArray>
    private external fun jSetcomplexstringvector(id: Long, v: ObjectArray, vararg extraObjs: Any?): Unit
    private external fun jGetcomplexstringvector(id: Long): ObjectArray
    private external fun jSetcomplexstringmap(id: Long, m: Pair<ObjectArray, ObjectArray>, vararg extraObjs: Any?): Unit
    private external fun jGetcomplexstringmap(id: Long): Pair<ObjectArray, ObjectArray>
    private external fun jFinalize(id: Long): Unit
    private external fun jGetcxxid(id: Long): Long
}

private external fun jGettypebyid(id: Long): String
