/**
 *   ______ .______   .______   .______    __  .__   __.  _______  
 *  /      ||   _  \  |   _  \  |   _  \  |  | |  \ |  | |       \ 
 * |  ,----'|  |_)  | |  |_)  | |  |_)  | |  | |   \|  | |  .--.  |
 * |  |     |   ___/  |   ___/  |   _  <  |  | |  . `  | |  |  |  |
 * |  `----.|  |      |  |      |  |_)  | |  | |  |\   | |  '--'  |
 *  \______|| _|      | _|      |______/  |__| |__| \__| |_______/ 
 * 
 * This file is generated by cppbind on 07/19/2022-12:20.
 * Please do not change it manually.
 */

import CWrapper
import Foundation

public func add(a: CShort, b: CShort) -> CShort {
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_add(a, b, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  return result
}

public func add(v: Array<CShort>, a: CShort) -> Array<CShort> {
  let _swifttoscvData = UnsafeMutablePointer<CShort>.allocate(capacity: v.count)
  var swifttoscv = CppBindCDataArray()
  swifttoscv.data = UnsafeMutableRawPointer(_swifttoscvData)
  swifttoscv.size = Int64(v.count)
  for i in 0..<v.count {
    let vVal = v[i]
    
    _swifttoscvData[i] = vVal
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_add_1(swifttoscv, a, &cppbindErr)
  
  swifttoscv.data.deallocate()
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  let _resultBuffer = UnsafeBufferPointer<CShort>(
    start: result.data.assumingMemoryBound(to: CShort.self),
    count: Int(result.size))
  var sctoswiftresult: [CShort] = []
  defer {
    _resultBuffer.deallocate()
  }
  for i in 0..<Int(result.size) {
    let resultValue = _resultBuffer[i]
    
    sctoswiftresult.append(resultValue)
  }
  return sctoswiftresult
}

public func add(p1: (CShort, CShort), p2: (CShort, CShort)) -> (CShort, CShort) {
  let _swifttoscp1First = UnsafeMutablePointer<CShort>.allocate(capacity: 1)
  let _swifttoscp1Second = UnsafeMutablePointer<CShort>.allocate(capacity: 1)
  var swifttoscp1 = CppBindCDataPair()
  swifttoscp1.first = UnsafeMutableRawPointer(_swifttoscp1First)
  swifttoscp1.second = UnsafeMutableRawPointer(_swifttoscp1Second)
  let p1First = p1.0
  let p1Second = p1.1


  _swifttoscp1First[0] = p1First
  _swifttoscp1Second[0] = p1Second
  let _swifttoscp2First = UnsafeMutablePointer<CShort>.allocate(capacity: 1)
  let _swifttoscp2Second = UnsafeMutablePointer<CShort>.allocate(capacity: 1)
  var swifttoscp2 = CppBindCDataPair()
  swifttoscp2.first = UnsafeMutableRawPointer(_swifttoscp2First)
  swifttoscp2.second = UnsafeMutableRawPointer(_swifttoscp2Second)
  let p2First = p2.0
  let p2Second = p2.1


  _swifttoscp2First[0] = p2First
  _swifttoscp2Second[0] = p2Second
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_add_2(swifttoscp1, swifttoscp2, &cppbindErr)
  
  swifttoscp1.first.deallocate()
  swifttoscp1.second.deallocate()
  
  swifttoscp2.first.deallocate()
  swifttoscp2.second.deallocate()
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  let _resultFirstData = UnsafeBufferPointer<CShort>(
    start: result.first.assumingMemoryBound(to: CShort.self),
    count: 1)
  let _resultSecondData = UnsafeBufferPointer<CShort>(
    start: result.second.assumingMemoryBound(to: CShort.self),
    count: 1)
  defer {
    _resultFirstData.deallocate()
    _resultSecondData.deallocate()
  }
  let resultFirst = _resultFirstData[0]
  let resultSecond = _resultSecondData[0]


  let sctoswiftresult: (CShort, CShort) = (resultFirst, resultSecond)
  return sctoswiftresult
}
