/**
 *   ______ .______   .______   .______    __  .__   __.  _______  
 *  /      ||   _  \  |   _  \  |   _  \  |  | |  \ |  | |       \ 
 * |  ,----'|  |_)  | |  |_)  | |  |_)  | |  | |   \|  | |  .--.  |
 * |  |     |   ___/  |   ___/  |   _  <  |  | |  . `  | |  |  |  |
 * |  `----.|  |      |  |      |  |_)  | |  | |  |\   | |  '--'  |
 *  \______|| _|      | _|      |______/  |__| |__| \__| |_______/ 
 * 
 * This file is generated by cppbind on 09/09/2022-13:58.
 * Please do not change it manually.
 */

import CWrapper
import Foundation

public func mul(a: Int?, b: Int) -> Int? {
  var swifttosca = CppBindOptionalInt()
  if a != nil {
    let aUnwrapped = a!
    let swifttoscaUnwrapped = CInt(aUnwrapped)
    swifttosca.value = swifttoscaUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  let swifttoscb = CInt(b)
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_mulInt(swifttosca, swifttoscb, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: Int? = nil;
  if (result.has_value) {
    let resultValue = result.value
    let sctoswiftresultValue = Int(resultValue)
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func mul(a: Float?, b: Float) -> Float? {
  var swifttosca = CppBindOptionalFloat()
  if a != nil {
    let aUnwrapped = a!
    
    swifttosca.value = aUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_mulFloat(swifttosca, b, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: Float? = nil;
  if (result.has_value) {
    let resultValue = result.value
    
    sctoswiftresult = Optional(resultValue)
  }
  return sctoswiftresult
}

public func mul(a: Double?, b: Double) -> Double? {
  var swifttosca = CppBindOptionalDouble()
  if a != nil {
    let aUnwrapped = a!
    
    swifttosca.value = aUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_mulDouble(swifttosca, b, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: Double? = nil;
  if (result.has_value) {
    let resultValue = result.value
    
    sctoswiftresult = Optional(resultValue)
  }
  return sctoswiftresult
}

public func mul(a: CShort?, b: CShort) -> CShort? {
  var swifttosca = CppBindOptionalCShort()
  if a != nil {
    let aUnwrapped = a!
    
    swifttosca.value = aUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_mulCShort(swifttosca, b, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: CShort? = nil;
  if (result.has_value) {
    let resultValue = result.value
    
    sctoswiftresult = Optional(resultValue)
  }
  return sctoswiftresult
}

public func mulLong(a: CLong?, b: CLong) -> CLong? {
  var swifttosca = CppBindOptionalCLong()
  if a != nil {
    let aUnwrapped = a!
    
    swifttosca.value = aUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_mulLong(swifttosca, b, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: CLong? = nil;
  if (result.has_value) {
    let resultValue = result.value
    
    sctoswiftresult = Optional(resultValue)
  }
  return sctoswiftresult
}

public func reverseBool(a: Bool?) -> Bool? {
  var swifttosca = CppBindOptionalBool()
  if a != nil {
    let aUnwrapped = a!
    
    swifttosca.value = aUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_reverseBool(swifttosca, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: Bool? = nil;
  if (result.has_value) {
    let resultValue = result.value
    
    sctoswiftresult = Optional(resultValue)
  }
  return sctoswiftresult
}

public func mulUnsignedInt(a: UInt?, b: UInt) -> UInt? {
  var swifttosca = CppBindOptionalUInt()
  if a != nil {
    let aUnwrapped = a!
    let swifttoscaUnwrapped = CUnsignedInt(aUnwrapped)
    swifttosca.value = swifttoscaUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  let swifttoscb = CUnsignedInt(b)
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_mulUnsignedInt(swifttosca, swifttoscb, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: UInt? = nil;
  if (result.has_value) {
    let resultValue = result.value
    let sctoswiftresultValue = UInt(resultValue)
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func mulUnsignedLong(a: CUnsignedLong?, b: CUnsignedLong) -> CUnsignedLong? {
  var swifttosca = CppBindOptionalCUnsignedLong()
  if a != nil {
    let aUnwrapped = a!
    
    swifttosca.value = aUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_mulUnsignedLong(swifttosca, b, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: CUnsignedLong? = nil;
  if (result.has_value) {
    let resultValue = result.value
    
    sctoswiftresult = Optional(resultValue)
  }
  return sctoswiftresult
}

public func mulLongLong(a: CLongLong?, b: CLongLong) -> CLongLong? {
  var swifttosca = CppBindOptionalCLongLong()
  if a != nil {
    let aUnwrapped = a!
    
    swifttosca.value = aUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_mulLongLong(swifttosca, b, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: CLongLong? = nil;
  if (result.has_value) {
    let resultValue = result.value
    
    sctoswiftresult = Optional(resultValue)
  }
  return sctoswiftresult
}

public func mulUnsignedChar(a: CUnsignedChar?, b: CUnsignedChar) -> CUnsignedChar? {
  var swifttosca = CppBindOptionalCUnsignedChar()
  if a != nil {
    let aUnwrapped = a!
    
    swifttosca.value = aUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_mulUnsignedChar(swifttosca, b, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: CUnsignedChar? = nil;
  if (result.has_value) {
    let resultValue = result.value
    
    sctoswiftresult = Optional(resultValue)
  }
  return sctoswiftresult
}

public func charToUpper(a: Character?) -> Character? {
  var swifttosca = CppBindOptionalCharacter()
  if a != nil {
    let aUnwrapped = a!
    let swifttoscaUnwrapped = aUnwrapped.description.utf8CString[0]
    swifttosca.value = swifttoscaUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_charToUpper(swifttosca, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: Character? = nil;
  if (result.has_value) {
    let resultValue = result.value
    let sctoswiftresultValue = Character(UnicodeScalar(Int(resultValue))!)
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func concatString(first: String?, second: String) -> String? {
  var swifttoscfirst = CppBindOptionalString()
  if first != nil {
    let firstUnwrapped = first!
    let swifttoscfirstUnwrapped = strdup(firstUnwrapped)!
    swifttoscfirst.value = swifttoscfirstUnwrapped
    swifttoscfirst.has_value = true
  } else {
    swifttoscfirst.has_value = false
  }
  let swifttoscsecond = strdup(second)!
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_concatString(swifttoscfirst, swifttoscsecond, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: String? = nil;
  if (result.has_value) {
    let resultValue = result.value!
    let sctoswiftresultValue = String(cString: resultValue)
    defer {
      resultValue.deallocate()
    }
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func concat(v: Array<String>?, s: String) -> Array<String>? {
  var swifttoscv = CppBindOptionalArray()
  if v != nil {
    let vUnwrapped = v!
    let _swifttoscvUnwrappedData = UnsafeMutablePointer<UnsafeMutablePointer<CChar>>.allocate(capacity: vUnwrapped.count)
    var swifttoscvUnwrapped = CppBindCDataArray()
    swifttoscvUnwrapped.data = UnsafeMutableRawPointer(_swifttoscvUnwrappedData)
    swifttoscvUnwrapped.size = Int64(vUnwrapped.count)
    for i in 0..<vUnwrapped.count {
      let vUnwrappedVal = vUnwrapped[i]
      let swifttoscvUnwrappedVal = strdup(vUnwrappedVal)!
      _swifttoscvUnwrappedData[i] = swifttoscvUnwrappedVal
    }
    swifttoscv.value = swifttoscvUnwrapped
    swifttoscv.has_value = true
  } else {
    swifttoscv.has_value = false
  }
  let swifttoscs = strdup(s)!
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_concat(swifttoscv, swifttoscs, &cppbindErr)
  
  if (swifttoscv.has_value){

    swifttoscv.value.data.deallocate()
  }
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: Array<String>? = nil;
  if (result.has_value) {
    let resultValue = result.value
    let _resultValueBuffer = UnsafeBufferPointer<UnsafeMutablePointer<CChar>>(
      start: resultValue.data.assumingMemoryBound(to: UnsafeMutablePointer<CChar>.self),
      count: Int(resultValue.size))
    var sctoswiftresultValue: [String] = []
    defer {
      _resultValueBuffer.deallocate()
    }
    for i in 0..<Int(resultValue.size) {
      let resultValueValue = _resultValueBuffer[i]
      let sctoswiftresultValueValue = String(cString: resultValueValue)
      defer {
        resultValueValue.deallocate()
      }
      sctoswiftresultValue.append(sctoswiftresultValueValue)
    }
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func concat2(v: Array<String?>, s: String) -> Array<String?> {
  let _swifttoscvData = UnsafeMutablePointer<CppBindOptionalString>.allocate(capacity: v.count)
  var swifttoscv = CppBindCDataArray()
  swifttoscv.data = UnsafeMutableRawPointer(_swifttoscvData)
  swifttoscv.size = Int64(v.count)
  for i in 0..<v.count {
    let vVal = v[i]
    var swifttoscvVal = CppBindOptionalString()
    if vVal != nil {
      let vValUnwrapped = vVal!
      let swifttoscvValUnwrapped = strdup(vValUnwrapped)!
      swifttoscvVal.value = swifttoscvValUnwrapped
      swifttoscvVal.has_value = true
    } else {
      swifttoscvVal.has_value = false
    }
    _swifttoscvData[i] = swifttoscvVal
  }
  let swifttoscs = strdup(s)!
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_concat2(swifttoscv, swifttoscs, &cppbindErr)
  
  swifttoscv.data.deallocate()
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  let _resultBuffer = UnsafeBufferPointer<CppBindOptionalString>(
    start: result.data.assumingMemoryBound(to: CppBindOptionalString.self),
    count: Int(result.size))
  var sctoswiftresult: [String?] = []
  defer {
    _resultBuffer.deallocate()
  }
  for i in 0..<Int(result.size) {
    let resultValue = _resultBuffer[i]
    var sctoswiftresultValue: String? = nil;
    if (resultValue.has_value) {
      let resultValueValue = resultValue.value!
      let sctoswiftresultValueValue = String(cString: resultValueValue)
      defer {
        resultValueValue.deallocate()
      }
      sctoswiftresultValue = Optional(sctoswiftresultValueValue)
    }
    sctoswiftresult.append(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func sameColor(color: Color?) -> Color? {
  var swifttosccolor = CppBindOptionalInt()
  if color != nil {
    let colorUnwrapped = color!
    let swifttosccolorUnwrapped = colorUnwrapped.rawValue
    swifttosccolor.value = swifttosccolorUnwrapped
    swifttosccolor.has_value = true
  } else {
    swifttosccolor.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_sameColor(swifttosccolor, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: Color? = nil;
  if (result.has_value) {
    let resultValue = result.value
    guard let sctoswiftresultValue = Color(rawValue: resultValue) else {
       ExceptionHandler.handleUncaughtException(
          "Internal error: unresolved reference to non existing field of Color enum.")
    }
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func same_template(a: Int?) -> Int? {
  var swifttosca = CppBindOptionalInt()
  if a != nil {
    let aUnwrapped = a!
    let swifttoscaUnwrapped = CInt(aUnwrapped)
    swifttosca.value = swifttoscaUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_same_templateOptionalInt(swifttosca, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: Int? = nil;
  if (result.has_value) {
    let resultValue = result.value
    let sctoswiftresultValue = Int(resultValue)
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func same_template(a: String?) -> String? {
  var swifttosca = CppBindOptionalString()
  if a != nil {
    let aUnwrapped = a!
    let swifttoscaUnwrapped = strdup(aUnwrapped)!
    swifttosca.value = swifttoscaUnwrapped
    swifttosca.has_value = true
  } else {
    swifttosca.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_same_templateOptionalString(swifttosca, &cppbindErr)
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: String? = nil;
  if (result.has_value) {
    let resultValue = result.value!
    let sctoswiftresultValue = String(cString: resultValue)
    defer {
      resultValue.deallocate()
    }
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func samePair(pair: (Int, Int)?) -> (Int, Int)? {
  var swifttoscpair = CppBindOptionalPair()
  if pair != nil {
    let pairUnwrapped = pair!
    let _swifttoscpairUnwrappedFirst = UnsafeMutablePointer<CInt>.allocate(capacity: 1)
    let _swifttoscpairUnwrappedSecond = UnsafeMutablePointer<CInt>.allocate(capacity: 1)
    var swifttoscpairUnwrapped = CppBindCDataPair()
    swifttoscpairUnwrapped.first = UnsafeMutableRawPointer(_swifttoscpairUnwrappedFirst)
    swifttoscpairUnwrapped.second = UnsafeMutableRawPointer(_swifttoscpairUnwrappedSecond)
    let pairUnwrappedFirst = pairUnwrapped.0
    let pairUnwrappedSecond = pairUnwrapped.1
    let swifttoscpairUnwrappedFirst = CInt(pairUnwrappedFirst)
    let swifttoscpairUnwrappedSecond = CInt(pairUnwrappedSecond)
    _swifttoscpairUnwrappedFirst[0] = swifttoscpairUnwrappedFirst
    _swifttoscpairUnwrappedSecond[0] = swifttoscpairUnwrappedSecond
    swifttoscpair.value = swifttoscpairUnwrapped
    swifttoscpair.has_value = true
  } else {
    swifttoscpair.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_samePair(swifttoscpair, &cppbindErr)
  
  if (swifttoscpair.has_value){

    swifttoscpair.value.first.deallocate()
    swifttoscpair.value.second.deallocate()
  }
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: (Int, Int)? = nil;
  if (result.has_value) {
    let resultValue = result.value
    let _resultValueFirstData = UnsafeBufferPointer<CInt>(
      start: resultValue.first.assumingMemoryBound(to: CInt.self),
      count: 1)
    let _resultValueSecondData = UnsafeBufferPointer<CInt>(
      start: resultValue.second.assumingMemoryBound(to: CInt.self),
      count: 1)
    defer {
      _resultValueFirstData.deallocate()
      _resultValueSecondData.deallocate()
    }
    let resultValueFirst = _resultValueFirstData[0]
    let resultValueSecond = _resultValueSecondData[0]
    let sctoswiftresultValueFirst = Int(resultValueFirst)
    let sctoswiftresultValueSecond = Int(resultValueSecond)
    let sctoswiftresultValue: (Int, Int) = (sctoswiftresultValueFirst, sctoswiftresultValueSecond)
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public func sameMap(map: Dictionary<Int, Int>?) -> Dictionary<Int, Int>? {
  var swifttoscmap = CppBindOptionalMap()
  if map != nil {
    let mapUnwrapped = map!
    let _swifttoscmapUnwrappedKey = UnsafeMutablePointer<CInt>.allocate(
      capacity: mapUnwrapped.count)
    let _swifttoscmapUnwrappedVal = UnsafeMutablePointer<CInt>.allocate(
      capacity: mapUnwrapped.count)
    var swifttoscmapUnwrapped = CppBindCDataMap()
    swifttoscmapUnwrapped.keys = UnsafeMutableRawPointer(_swifttoscmapUnwrappedKey)
    swifttoscmapUnwrapped.values = UnsafeMutableRawPointer(_swifttoscmapUnwrappedVal)
    swifttoscmapUnwrapped.size = Int64(mapUnwrapped.count)
    var mapUnwrappedIdx = 0
    for (mapUnwrappedKey, mapUnwrappedVal) in mapUnwrapped {
      let swifttoscmapUnwrappedKey = CInt(mapUnwrappedKey)
      let swifttoscmapUnwrappedVal = CInt(mapUnwrappedVal)
      _swifttoscmapUnwrappedKey[mapUnwrappedIdx] = swifttoscmapUnwrappedKey
      _swifttoscmapUnwrappedVal[mapUnwrappedIdx] = swifttoscmapUnwrappedVal
      mapUnwrappedIdx += 1
    }
    swifttoscmap.value = swifttoscmapUnwrapped
    swifttoscmap.has_value = true
  } else {
    swifttoscmap.has_value = false
  }
  var cppbindErr = CppBindCObject()
  let result = _func_CppbindExample_sameMap(swifttoscmap, &cppbindErr)
  
  if (swifttoscmap.has_value){

    swifttoscmap.value.keys.deallocate()
    swifttoscmap.value.values.deallocate()
  }
  if cppbindErr.type != nil {
    let errorType = String(cString: cppbindErr.type!)
    switch errorType {
    case ("std::exception"):
      let excObj = StdException(cppbindErr, true)
      ExceptionHandler.handleUncaughtException(excObj.what())
    default:
      cppbindErr.type.deallocate()
      ExceptionHandler.handleUncaughtException("Uncaught Exception")
    }
  }
  var sctoswiftresult: Dictionary<Int, Int>? = nil;
  if (result.has_value) {
    let resultValue = result.value
    let resultValueBufferKey = UnsafeBufferPointer<CInt>(
      start: resultValue.keys.assumingMemoryBound(to: CInt.self),
      count: Int(resultValue.size))
    let resultValueBufferVal = UnsafeBufferPointer<CInt>(
      start: resultValue.values.assumingMemoryBound(to: CInt.self),
      count: Int(resultValue.size))
    var sctoswiftresultValue: [Int:Int] = [:]
    defer {
      resultValueBufferKey.deallocate()
      resultValueBufferVal.deallocate()
    }
    for resultValueIdx in 0..<Int(resultValue.size) {
      let resultValueKey = resultValueBufferKey[resultValueIdx]
      let resultValueVal = resultValueBufferVal[resultValueIdx]
      do {
        let sctoswiftresultValueKey = Int(resultValueKey)
        let sctoswiftresultValueVal = Int(resultValueVal)
        sctoswiftresultValue[sctoswiftresultValueKey] = sctoswiftresultValueVal
      }
    }
    sctoswiftresult = Optional(sctoswiftresultValue)
  }
  return sctoswiftresult
}

public class FrameUsage {

  /// An internal property to keep a reference to the original C++ object.
  /// It is intended to be used by the generated code.
  public let cself: CppBindCObject

  /// An internal property to keep track whether Swift is responsible for deallocating the underlying C++ object or not.
  /// It is intended to be used by the generated code.
  public let owner: Bool
  private var refs: [Any]

  /// internal main initializer
  internal required init(_ _cself: CppBindCObject, _ _owner: Bool = false) {
    self.cself = _cself
    self.owner = _owner
    self.refs = []
  }

  deinit {
    release_CppbindExample_FrameUsage(cself, owner)
  }

  /// An internal method to bind the lifetimes of the current and another object.
  /// It is intended to be used by the generated code.
  public func keepCppBindReference(_ object: Any) {
    self.refs.append(object)
  }

  public convenience init() {
    var cppbindErr = CppBindCObject()
    self.init(create_CppbindExample_FrameUsage(&cppbindErr), true)
    if cppbindErr.type != nil {
      let errorType = String(cString: cppbindErr.type!)
      switch errorType {
      case ("std::exception"):
        let excObj = StdException(cppbindErr, true)
        ExceptionHandler.handleUncaughtException(excObj.what())
      default:
        cppbindErr.type.deallocate()
        ExceptionHandler.handleUncaughtException("Uncaught Exception")
      }
    }
  }

  public func sameFrame(frame: Frame?) -> Frame? {

    var swifttoscframe = CppBindOptionalObject()
    if frame != nil {
      let frameUnwrapped = frame!
      let swifttoscframeUnwrapped = frameUnwrapped.cself
      swifttoscframe.value = swifttoscframeUnwrapped
      swifttoscframe.has_value = true
    } else {
      swifttoscframe.has_value = false
    }
    var cppbindErr = CppBindCObject()
    let result = _func_CppbindExample_FrameUsage_sameFrame(cself, swifttoscframe, &cppbindErr)
    if (frame != nil) {
      self.keepCppBindReference(frame!)
    }
    if cppbindErr.type != nil {
      let errorType = String(cString: cppbindErr.type!)
      switch errorType {
      case ("std::exception"):
        let excObj = StdException(cppbindErr, true)
        ExceptionHandler.handleUncaughtException(excObj.what())
      default:
        cppbindErr.type.deallocate()
        ExceptionHandler.handleUncaughtException("Uncaught Exception")
      }
    }
    var sctoswiftresult: Frame? = nil;
    if (result.has_value) {
      let resultValue = result.value
      var sctoswiftresultValue: Frame
      sctoswiftresultValue = Frame(resultValue, true)
      sctoswiftresult = Optional(sctoswiftresultValue)
    }
    return sctoswiftresult
  }

  public func getFrame() -> Frame? {

    var cppbindErr = CppBindCObject()
    let result = _func_CppbindExample_FrameUsage_getFrame(cself, &cppbindErr)
    if cppbindErr.type != nil {
      let errorType = String(cString: cppbindErr.type!)
      switch errorType {
      case ("std::exception"):
        let excObj = StdException(cppbindErr, true)
        ExceptionHandler.handleUncaughtException(excObj.what())
      default:
        cppbindErr.type.deallocate()
        ExceptionHandler.handleUncaughtException("Uncaught Exception")
      }
    }
    var sctoswiftresult: Frame? = nil;
    if (result.has_value) {
      let resultValue = result.value
      var sctoswiftresultValue: Frame
      sctoswiftresultValue = Frame(resultValue, true)
      sctoswiftresult = Optional(sctoswiftresultValue)
    }
    if (sctoswiftresult != nil) {
      sctoswiftresult!.keepCppBindReference(self)
    }
    return sctoswiftresult
  }

  /// An internal property to keep an information about the underlying C++ object type.
  /// It is intended to be used by the generated code.
  class var cppbindCxxTypeName : String { return "cppbind::example::FrameUsage" }
}
