/**
 * ,--.,------. ,----.   ,------.,--.  ,--. 
 * |  ||  .---''  .-.|   |  .---'|  ,'.|  | 
 * |  ||  `--, |  | .---.|  `--, |  |' '  | 
 * |  ||  `---.'  '--'  ||  `---.|  | `   | 
 * `--'`------' `------' `------'`--'  `--' 
 * 
 * This file is generated by iegen on 09/08/2021-06:29.
 * Please do not change it manually.
 */

#include <string.h>
#include <memory>
#include "swift/wrappers/containers/c_nested_containers.h"
#include "cxx/containers/nested_containers.hpp"

using namespace iegen::example;

void release_NestedExamples(void* _Nonnull cself) {
    delete dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
}

void* _Nonnull create_NestedExamples(){
    auto this_object = new iegen::example::NestedExamples();
    return static_cast<iegen::example::NestedExamples*>(this_object);
}

void _func_NestedExamples_setNestedIntVector(void* _Nonnull cself, CDataArray v, ErrorObj* _Nonnull err){
    std::vector<std::vector<int> > c_to_cxx_v;

    auto data_v = reinterpret_cast<CDataArray*>(v.data);

    for (size_t _i_v = 0; _i_v < v.size; ++_i_v) {
        auto& value_v = data_v[_i_v];
        std::vector<int> c_to_cxx_value_v;

        auto data_value_v = reinterpret_cast<int*>(value_v.data);

        for (size_t _i_value_v = 0; _i_value_v < value_v.size; ++_i_value_v) {
            auto& value_value_v = data_value_v[_i_value_v];
            
            c_to_cxx_value_v.emplace_back(value_value_v);
        }
        c_to_cxx_v.emplace_back(c_to_cxx_value_v);
    }
  
    auto c_to_cxx_cself = dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
    try {
        c_to_cxx_cself->setNestedIntVector(c_to_cxx_v);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataArray _func_NestedExamples_getNestedIntVector(void* _Nonnull cself, ErrorObj* _Nonnull err){
    auto c_to_cxx_cself = dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
    try {
      const auto& result = c_to_cxx_cself->getNestedIntVector();
      auto _data_cxx_to_c_result = new CDataArray [result.size()];
    CDataArray cxx_to_c_result = { _data_cxx_to_c_result, (long long)result.size() };
    for (int _i_result = 0; _i_result < result.size(); ++_i_result) {
      auto& value_result = result[_i_result];
      auto _data_cxx_to_c_value_result = new int [value_result.size()];
        CDataArray cxx_to_c_value_result = { _data_cxx_to_c_value_result, (long long)value_result.size() };
        for (int _i_value_result = 0; _i_value_result < value_result.size(); ++_i_value_result) {
          auto& value_value_result = value_result[_i_value_result];
          
          _data_cxx_to_c_value_result[_i_value_result] = value_value_result;
        }
      _data_cxx_to_c_result[_i_result] = cxx_to_c_value_result;
    }
      return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataArray result;
    return result;
}

void _func_NestedExamples_setNestedIntMap(void* _Nonnull cself, CDataMap m, ErrorObj* _Nonnull err){
    std::map<int, std::map<int, int> > c_to_cxx_m;

    for (size_t _i_m = 0; _i_m < m.size; ++_i_m) {
        auto ktmp_m = reinterpret_cast<int*>(m.keys)[_i_m];
        auto vtmp_m = reinterpret_cast<CDataMap*>(m.values)[_i_m];
        
        std::map<int, int> c_to_cxx_vtmp_m;

        for (size_t _i_vtmp_m = 0; _i_vtmp_m < vtmp_m.size; ++_i_vtmp_m) {
            auto ktmp_vtmp_m = reinterpret_cast<int*>(vtmp_m.keys)[_i_vtmp_m];
            auto vtmp_vtmp_m = reinterpret_cast<int*>(vtmp_m.values)[_i_vtmp_m];
            
            
            c_to_cxx_vtmp_m.insert({ ktmp_vtmp_m, vtmp_vtmp_m });
        }
        c_to_cxx_m.insert({ ktmp_m, c_to_cxx_vtmp_m });
    }
  
    auto c_to_cxx_cself = dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
    try {
        c_to_cxx_cself->setNestedIntMap(c_to_cxx_m);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataMap _func_NestedExamples_getNestedIntMap(void* _Nonnull cself, ErrorObj* _Nonnull err){
    auto c_to_cxx_cself = dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
    try {
      const auto& result = c_to_cxx_cself->getNestedIntMap();
      auto _k_data_cxx_to_c_result = new int [result.size()];
    auto _v_data_cxx_to_c_result = new CDataMap [result.size()];
    CDataMap cxx_to_c_result = { _k_data_cxx_to_c_result, _v_data_cxx_to_c_result, (long long)result.size() };
    size_t _i_result = 0;
    for (auto& value_result : result) {
        const auto& key_result = value_result.first;
        const auto& val_result = value_result.second;
        {
          
          auto _k_data_cxx_to_c_val_result = new int [val_result.size()];
        auto _v_data_cxx_to_c_val_result = new int [val_result.size()];
        CDataMap cxx_to_c_val_result = { _k_data_cxx_to_c_val_result, _v_data_cxx_to_c_val_result, (long long)val_result.size() };
        size_t _i_val_result = 0;
        for (auto& value_val_result : val_result) {
            const auto& key_val_result = value_val_result.first;
            const auto& val_val_result = value_val_result.second;
            {
              
              
              _k_data_cxx_to_c_val_result[_i_val_result] = key_val_result;
              _v_data_cxx_to_c_val_result[_i_val_result] = val_val_result;
              _i_val_result += 1;
            }
        }
          _k_data_cxx_to_c_result[_i_result] = key_result;
          _v_data_cxx_to_c_result[_i_result] = cxx_to_c_val_result;
          _i_result += 1;
        }
    }
      return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataMap result;
    return result;
}

void _func_NestedExamples_mixedExampleWithManyArgs(void* _Nonnull cself, CDataArray v1, CDataArray v2, CDataMap m1, CDataMap m2, ErrorObj* _Nonnull err){
    std::vector<std::vector<int> > c_to_cxx_v1;

    auto data_v1 = reinterpret_cast<CDataArray*>(v1.data);

    for (size_t _i_v1 = 0; _i_v1 < v1.size; ++_i_v1) {
        auto& value_v1 = data_v1[_i_v1];
        std::vector<int> c_to_cxx_value_v1;

        auto data_value_v1 = reinterpret_cast<int*>(value_v1.data);

        for (size_t _i_value_v1 = 0; _i_value_v1 < value_v1.size; ++_i_value_v1) {
            auto& value_value_v1 = data_value_v1[_i_value_v1];
            
            c_to_cxx_value_v1.emplace_back(value_value_v1);
        }
        c_to_cxx_v1.emplace_back(c_to_cxx_value_v1);
    }
  
    std::vector<std::vector<int> > c_to_cxx_v2;

    auto data_v2 = reinterpret_cast<CDataArray*>(v2.data);

    for (size_t _i_v2 = 0; _i_v2 < v2.size; ++_i_v2) {
        auto& value_v2 = data_v2[_i_v2];
        std::vector<int> c_to_cxx_value_v2;

        auto data_value_v2 = reinterpret_cast<int*>(value_v2.data);

        for (size_t _i_value_v2 = 0; _i_value_v2 < value_v2.size; ++_i_value_v2) {
            auto& value_value_v2 = data_value_v2[_i_value_v2];
            
            c_to_cxx_value_v2.emplace_back(value_value_v2);
        }
        c_to_cxx_v2.emplace_back(c_to_cxx_value_v2);
    }
  
    std::map<int, std::map<int, int> > c_to_cxx_m1;

    for (size_t _i_m1 = 0; _i_m1 < m1.size; ++_i_m1) {
        auto ktmp_m1 = reinterpret_cast<int*>(m1.keys)[_i_m1];
        auto vtmp_m1 = reinterpret_cast<CDataMap*>(m1.values)[_i_m1];
        
        std::map<int, int> c_to_cxx_vtmp_m1;

        for (size_t _i_vtmp_m1 = 0; _i_vtmp_m1 < vtmp_m1.size; ++_i_vtmp_m1) {
            auto ktmp_vtmp_m1 = reinterpret_cast<int*>(vtmp_m1.keys)[_i_vtmp_m1];
            auto vtmp_vtmp_m1 = reinterpret_cast<int*>(vtmp_m1.values)[_i_vtmp_m1];
            
            
            c_to_cxx_vtmp_m1.insert({ ktmp_vtmp_m1, vtmp_vtmp_m1 });
        }
        c_to_cxx_m1.insert({ ktmp_m1, c_to_cxx_vtmp_m1 });
    }
  
    std::map<int, std::map<int, int> > c_to_cxx_m2;

    for (size_t _i_m2 = 0; _i_m2 < m2.size; ++_i_m2) {
        auto ktmp_m2 = reinterpret_cast<int*>(m2.keys)[_i_m2];
        auto vtmp_m2 = reinterpret_cast<CDataMap*>(m2.values)[_i_m2];
        
        std::map<int, int> c_to_cxx_vtmp_m2;

        for (size_t _i_vtmp_m2 = 0; _i_vtmp_m2 < vtmp_m2.size; ++_i_vtmp_m2) {
            auto ktmp_vtmp_m2 = reinterpret_cast<int*>(vtmp_m2.keys)[_i_vtmp_m2];
            auto vtmp_vtmp_m2 = reinterpret_cast<int*>(vtmp_m2.values)[_i_vtmp_m2];
            
            
            c_to_cxx_vtmp_m2.insert({ ktmp_vtmp_m2, vtmp_vtmp_m2 });
        }
        c_to_cxx_m2.insert({ ktmp_m2, c_to_cxx_vtmp_m2 });
    }
  
    auto c_to_cxx_cself = dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
    try {
        c_to_cxx_cself->mixedExampleWithManyArgs(c_to_cxx_v1, c_to_cxx_v2, c_to_cxx_m1, c_to_cxx_m2);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

void _func_NestedExamples_setVectorOfIntMaps(void* _Nonnull cself, CDataArray v, ErrorObj* _Nonnull err){
    std::vector<std::map<int, int> > c_to_cxx_v;

    auto data_v = reinterpret_cast<CDataMap*>(v.data);

    for (size_t _i_v = 0; _i_v < v.size; ++_i_v) {
        auto& value_v = data_v[_i_v];
        std::map<int, int> c_to_cxx_value_v;

        for (size_t _i_value_v = 0; _i_value_v < value_v.size; ++_i_value_v) {
            auto ktmp_value_v = reinterpret_cast<int*>(value_v.keys)[_i_value_v];
            auto vtmp_value_v = reinterpret_cast<int*>(value_v.values)[_i_value_v];
            
            
            c_to_cxx_value_v.insert({ ktmp_value_v, vtmp_value_v });
        }
        c_to_cxx_v.emplace_back(c_to_cxx_value_v);
    }
  
    auto c_to_cxx_cself = dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
    try {
        c_to_cxx_cself->setVectorOfIntMaps(c_to_cxx_v);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataArray _func_NestedExamples_getVectorOfIntMaps(void* _Nonnull cself, ErrorObj* _Nonnull err){
    auto c_to_cxx_cself = dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
    try {
      const auto& result = c_to_cxx_cself->getVectorOfIntMaps();
      auto _data_cxx_to_c_result = new CDataMap [result.size()];
    CDataArray cxx_to_c_result = { _data_cxx_to_c_result, (long long)result.size() };
    for (int _i_result = 0; _i_result < result.size(); ++_i_result) {
      auto& value_result = result[_i_result];
      auto _k_data_cxx_to_c_value_result = new int [value_result.size()];
        auto _v_data_cxx_to_c_value_result = new int [value_result.size()];
        CDataMap cxx_to_c_value_result = { _k_data_cxx_to_c_value_result, _v_data_cxx_to_c_value_result, (long long)value_result.size() };
        size_t _i_value_result = 0;
        for (auto& value_value_result : value_result) {
            const auto& key_value_result = value_value_result.first;
            const auto& val_value_result = value_value_result.second;
            {
              
              
              _k_data_cxx_to_c_value_result[_i_value_result] = key_value_result;
              _v_data_cxx_to_c_value_result[_i_value_result] = val_value_result;
              _i_value_result += 1;
            }
        }
      _data_cxx_to_c_result[_i_result] = cxx_to_c_value_result;
    }
      return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataArray result;
    return result;
}

void _func_NestedExamples_setMapOfIntVectors(void* _Nonnull cself, CDataMap m, ErrorObj* _Nonnull err){
    std::map<int, std::vector<int> > c_to_cxx_m;

    for (size_t _i_m = 0; _i_m < m.size; ++_i_m) {
        auto ktmp_m = reinterpret_cast<int*>(m.keys)[_i_m];
        auto vtmp_m = reinterpret_cast<CDataArray*>(m.values)[_i_m];
        
        std::vector<int> c_to_cxx_vtmp_m;

        auto data_vtmp_m = reinterpret_cast<int*>(vtmp_m.data);

        for (size_t _i_vtmp_m = 0; _i_vtmp_m < vtmp_m.size; ++_i_vtmp_m) {
            auto& value_vtmp_m = data_vtmp_m[_i_vtmp_m];
            
            c_to_cxx_vtmp_m.emplace_back(value_vtmp_m);
        }
        c_to_cxx_m.insert({ ktmp_m, c_to_cxx_vtmp_m });
    }
  
    auto c_to_cxx_cself = dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
    try {
        c_to_cxx_cself->setMapOfIntVectors(c_to_cxx_m);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataMap _func_NestedExamples_getMapOfIntVectors(void* _Nonnull cself, ErrorObj* _Nonnull err){
    auto c_to_cxx_cself = dynamic_cast<iegen::example::NestedExamples*>(static_cast<iegen::example::NestedExamples*>(cself));
    try {
      const auto& result = c_to_cxx_cself->getMapOfIntVectors();
      auto _k_data_cxx_to_c_result = new int [result.size()];
    auto _v_data_cxx_to_c_result = new CDataArray [result.size()];
    CDataMap cxx_to_c_result = { _k_data_cxx_to_c_result, _v_data_cxx_to_c_result, (long long)result.size() };
    size_t _i_result = 0;
    for (auto& value_result : result) {
        const auto& key_result = value_result.first;
        const auto& val_result = value_result.second;
        {
          
          auto _data_cxx_to_c_val_result = new int [val_result.size()];
        CDataArray cxx_to_c_val_result = { _data_cxx_to_c_val_result, (long long)val_result.size() };
        for (int _i_val_result = 0; _i_val_result < val_result.size(); ++_i_val_result) {
          auto& value_val_result = val_result[_i_val_result];
          
          _data_cxx_to_c_val_result[_i_val_result] = value_val_result;
        }
          _k_data_cxx_to_c_result[_i_result] = key_result;
          _v_data_cxx_to_c_result[_i_result] = cxx_to_c_val_result;
          _i_result += 1;
        }
    }
      return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataMap result;
    return result;
}