/**
 * ,--.,------. ,----.   ,------.,--.  ,--. 
 * |  ||  .---''  .-.|   |  .---'|  ,'.|  | 
 * |  ||  `--, |  | .---.|  `--, |  |' '  | 
 * |  ||  `---.'  '--'  ||  `---.|  | `   | 
 * `--'`------' `------' `------'`--'  `--' 
 * 
 * This file is generated by iegen on 12/07/2021-08:30.
 * Please do not change it manually.
 */

#include <string.h>
#include <cxxabi.h>
#include <memory>
#include "swift/wrappers/containers/c_nested_containers.h"
#include "cxx/containers/nested_containers.hpp"

using namespace iegen::example;

void release_NestedExamples(CObject cself) {
    delete static_cast<iegen::example::NestedExamples*>(cself.ptr);
}

CObject create_NestedExamples(ErrorObj* _Nonnull err){
    try {
        auto this_object = new iegen::example::NestedExamples();
        return {strdup("iegen::example::NestedExamples"), this_object};
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CObject result{};
    return result;
}

void _func_NestedExamples_setNestedIntVector(CObject cself, CDataArray v, ErrorObj* _Nonnull err){
    std::vector<std::vector<int>> c_to_cxx_v;

    auto data_v = reinterpret_cast<CDataArray*>(v.data);

    for (size_t _i_v = 0; _i_v < v.size; ++_i_v) {
        auto& value_v = data_v[_i_v];
        std::vector<int> c_to_cxx_value_v;

        auto data_value_v = reinterpret_cast<int*>(value_v.data);

        for (size_t _i_value_v = 0; _i_value_v < value_v.size; ++_i_value_v) {
            auto& value_value_v = data_value_v[_i_value_v];
            
            c_to_cxx_value_v.emplace_back(value_value_v);
        }
        c_to_cxx_v.emplace_back(c_to_cxx_value_v);
    }
  
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        c_to_cxx_cself->setNestedIntVector(c_to_cxx_v);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataArray _func_NestedExamples_getNestedIntVector(CObject cself, ErrorObj* _Nonnull err){
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        const auto& result = c_to_cxx_cself->getNestedIntVector();
        auto _data_cxx_to_c_result = new CDataArray [result.size()];
        CDataArray cxx_to_c_result = { _data_cxx_to_c_result, (long long)result.size() };
        for (int _i_result = 0; _i_result < result.size(); ++_i_result) {
            auto& value_result = result[_i_result];
            auto _data_cxx_to_c_value_result = new int [value_result.size()];
            CDataArray cxx_to_c_value_result = { _data_cxx_to_c_value_result, (long long)value_result.size() };
            for (int _i_value_result = 0; _i_value_result < value_result.size(); ++_i_value_result) {
                auto& value_value_result = value_result[_i_value_result];
                
                _data_cxx_to_c_value_result[_i_value_result] = value_value_result;
            }
            _data_cxx_to_c_result[_i_result] = cxx_to_c_value_result;
        }
        return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataArray result{};
    return result;
}

void _func_NestedExamples_setNestedIntMap(CObject cself, CDataMap m, ErrorObj* _Nonnull err){
    std::map<int, std::map<int, int>> c_to_cxx_m;

    for (size_t _i_m = 0; _i_m < m.size; ++_i_m) {
        auto ktmp_m = reinterpret_cast<int*>(m.keys)[_i_m];
        auto vtmp_m = reinterpret_cast<CDataMap*>(m.values)[_i_m];
        
        std::map<int, int> c_to_cxx_vtmp_m;

        for (size_t _i_vtmp_m = 0; _i_vtmp_m < vtmp_m.size; ++_i_vtmp_m) {
            auto ktmp_vtmp_m = reinterpret_cast<int*>(vtmp_m.keys)[_i_vtmp_m];
            auto vtmp_vtmp_m = reinterpret_cast<int*>(vtmp_m.values)[_i_vtmp_m];
            
            
            c_to_cxx_vtmp_m.insert({ ktmp_vtmp_m, vtmp_vtmp_m });
        }
        c_to_cxx_m.insert({ ktmp_m, c_to_cxx_vtmp_m });
    }
  
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        c_to_cxx_cself->setNestedIntMap(c_to_cxx_m);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataMap _func_NestedExamples_getNestedIntMap(CObject cself, ErrorObj* _Nonnull err){
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        const auto& result = c_to_cxx_cself->getNestedIntMap();
        auto _k_data_cxx_to_c_result = new int [result.size()];
        auto _v_data_cxx_to_c_result = new CDataMap [result.size()];
        CDataMap cxx_to_c_result = { _k_data_cxx_to_c_result, _v_data_cxx_to_c_result, (long long)result.size() };
        size_t _i_result = 0;
        for (auto& value_result : result) {
            const auto& key_result = value_result.first;
            const auto& val_result = value_result.second;
            {
                
                auto _k_data_cxx_to_c_val_result = new int [val_result.size()];
                auto _v_data_cxx_to_c_val_result = new int [val_result.size()];
                CDataMap cxx_to_c_val_result = { _k_data_cxx_to_c_val_result, _v_data_cxx_to_c_val_result, (long long)val_result.size() };
                size_t _i_val_result = 0;
                for (auto& value_val_result : val_result) {
                    const auto& key_val_result = value_val_result.first;
                    const auto& val_val_result = value_val_result.second;
                    {
                        
                        
                        _k_data_cxx_to_c_val_result[_i_val_result] = key_val_result;
                        _v_data_cxx_to_c_val_result[_i_val_result] = val_val_result;
                        _i_val_result += 1;
                    }
                }
                _k_data_cxx_to_c_result[_i_result] = key_result;
                _v_data_cxx_to_c_result[_i_result] = cxx_to_c_val_result;
                _i_result += 1;
            }
        }
        return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataMap result{};
    return result;
}

void _func_NestedExamples_mixedExampleWithManyArgs(CObject cself, CDataArray v1, CDataArray v2, CDataMap m1, CDataMap m2, ErrorObj* _Nonnull err){
    std::vector<std::vector<int>> c_to_cxx_v1;

    auto data_v1 = reinterpret_cast<CDataArray*>(v1.data);

    for (size_t _i_v1 = 0; _i_v1 < v1.size; ++_i_v1) {
        auto& value_v1 = data_v1[_i_v1];
        std::vector<int> c_to_cxx_value_v1;

        auto data_value_v1 = reinterpret_cast<int*>(value_v1.data);

        for (size_t _i_value_v1 = 0; _i_value_v1 < value_v1.size; ++_i_value_v1) {
            auto& value_value_v1 = data_value_v1[_i_value_v1];
            
            c_to_cxx_value_v1.emplace_back(value_value_v1);
        }
        c_to_cxx_v1.emplace_back(c_to_cxx_value_v1);
    }
  
    std::vector<std::vector<int>> c_to_cxx_v2;

    auto data_v2 = reinterpret_cast<CDataArray*>(v2.data);

    for (size_t _i_v2 = 0; _i_v2 < v2.size; ++_i_v2) {
        auto& value_v2 = data_v2[_i_v2];
        std::vector<int> c_to_cxx_value_v2;

        auto data_value_v2 = reinterpret_cast<int*>(value_v2.data);

        for (size_t _i_value_v2 = 0; _i_value_v2 < value_v2.size; ++_i_value_v2) {
            auto& value_value_v2 = data_value_v2[_i_value_v2];
            
            c_to_cxx_value_v2.emplace_back(value_value_v2);
        }
        c_to_cxx_v2.emplace_back(c_to_cxx_value_v2);
    }
  
    std::map<int, std::map<int, int>> c_to_cxx_m1;

    for (size_t _i_m1 = 0; _i_m1 < m1.size; ++_i_m1) {
        auto ktmp_m1 = reinterpret_cast<int*>(m1.keys)[_i_m1];
        auto vtmp_m1 = reinterpret_cast<CDataMap*>(m1.values)[_i_m1];
        
        std::map<int, int> c_to_cxx_vtmp_m1;

        for (size_t _i_vtmp_m1 = 0; _i_vtmp_m1 < vtmp_m1.size; ++_i_vtmp_m1) {
            auto ktmp_vtmp_m1 = reinterpret_cast<int*>(vtmp_m1.keys)[_i_vtmp_m1];
            auto vtmp_vtmp_m1 = reinterpret_cast<int*>(vtmp_m1.values)[_i_vtmp_m1];
            
            
            c_to_cxx_vtmp_m1.insert({ ktmp_vtmp_m1, vtmp_vtmp_m1 });
        }
        c_to_cxx_m1.insert({ ktmp_m1, c_to_cxx_vtmp_m1 });
    }
  
    std::map<int, std::map<int, int>> c_to_cxx_m2;

    for (size_t _i_m2 = 0; _i_m2 < m2.size; ++_i_m2) {
        auto ktmp_m2 = reinterpret_cast<int*>(m2.keys)[_i_m2];
        auto vtmp_m2 = reinterpret_cast<CDataMap*>(m2.values)[_i_m2];
        
        std::map<int, int> c_to_cxx_vtmp_m2;

        for (size_t _i_vtmp_m2 = 0; _i_vtmp_m2 < vtmp_m2.size; ++_i_vtmp_m2) {
            auto ktmp_vtmp_m2 = reinterpret_cast<int*>(vtmp_m2.keys)[_i_vtmp_m2];
            auto vtmp_vtmp_m2 = reinterpret_cast<int*>(vtmp_m2.values)[_i_vtmp_m2];
            
            
            c_to_cxx_vtmp_m2.insert({ ktmp_vtmp_m2, vtmp_vtmp_m2 });
        }
        c_to_cxx_m2.insert({ ktmp_m2, c_to_cxx_vtmp_m2 });
    }
  
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        c_to_cxx_cself->mixedExampleWithManyArgs(c_to_cxx_v1, c_to_cxx_v2, c_to_cxx_m1, c_to_cxx_m2);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

void _func_NestedExamples_setVectorOfIntMaps(CObject cself, CDataArray v, ErrorObj* _Nonnull err){
    std::vector<std::map<int, int>> c_to_cxx_v;

    auto data_v = reinterpret_cast<CDataMap*>(v.data);

    for (size_t _i_v = 0; _i_v < v.size; ++_i_v) {
        auto& value_v = data_v[_i_v];
        std::map<int, int> c_to_cxx_value_v;

        for (size_t _i_value_v = 0; _i_value_v < value_v.size; ++_i_value_v) {
            auto ktmp_value_v = reinterpret_cast<int*>(value_v.keys)[_i_value_v];
            auto vtmp_value_v = reinterpret_cast<int*>(value_v.values)[_i_value_v];
            
            
            c_to_cxx_value_v.insert({ ktmp_value_v, vtmp_value_v });
        }
        c_to_cxx_v.emplace_back(c_to_cxx_value_v);
    }
  
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        c_to_cxx_cself->setVectorOfIntMaps(c_to_cxx_v);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataArray _func_NestedExamples_getVectorOfIntMaps(CObject cself, ErrorObj* _Nonnull err){
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        const auto& result = c_to_cxx_cself->getVectorOfIntMaps();
        auto _data_cxx_to_c_result = new CDataMap [result.size()];
        CDataArray cxx_to_c_result = { _data_cxx_to_c_result, (long long)result.size() };
        for (int _i_result = 0; _i_result < result.size(); ++_i_result) {
            auto& value_result = result[_i_result];
            auto _k_data_cxx_to_c_value_result = new int [value_result.size()];
            auto _v_data_cxx_to_c_value_result = new int [value_result.size()];
            CDataMap cxx_to_c_value_result = { _k_data_cxx_to_c_value_result, _v_data_cxx_to_c_value_result, (long long)value_result.size() };
            size_t _i_value_result = 0;
            for (auto& value_value_result : value_result) {
                const auto& key_value_result = value_value_result.first;
                const auto& val_value_result = value_value_result.second;
                {
                    
                    
                    _k_data_cxx_to_c_value_result[_i_value_result] = key_value_result;
                    _v_data_cxx_to_c_value_result[_i_value_result] = val_value_result;
                    _i_value_result += 1;
                }
            }
            _data_cxx_to_c_result[_i_result] = cxx_to_c_value_result;
        }
        return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataArray result{};
    return result;
}

void _func_NestedExamples_setMapOfIntVectors(CObject cself, CDataMap m, ErrorObj* _Nonnull err){
    std::map<int, std::vector<int>> c_to_cxx_m;

    for (size_t _i_m = 0; _i_m < m.size; ++_i_m) {
        auto ktmp_m = reinterpret_cast<int*>(m.keys)[_i_m];
        auto vtmp_m = reinterpret_cast<CDataArray*>(m.values)[_i_m];
        
        std::vector<int> c_to_cxx_vtmp_m;

        auto data_vtmp_m = reinterpret_cast<int*>(vtmp_m.data);

        for (size_t _i_vtmp_m = 0; _i_vtmp_m < vtmp_m.size; ++_i_vtmp_m) {
            auto& value_vtmp_m = data_vtmp_m[_i_vtmp_m];
            
            c_to_cxx_vtmp_m.emplace_back(value_vtmp_m);
        }
        c_to_cxx_m.insert({ ktmp_m, c_to_cxx_vtmp_m });
    }
  
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        c_to_cxx_cself->setMapOfIntVectors(c_to_cxx_m);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataMap _func_NestedExamples_getMapOfIntVectors(CObject cself, ErrorObj* _Nonnull err){
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        const auto& result = c_to_cxx_cself->getMapOfIntVectors();
        auto _k_data_cxx_to_c_result = new int [result.size()];
        auto _v_data_cxx_to_c_result = new CDataArray [result.size()];
        CDataMap cxx_to_c_result = { _k_data_cxx_to_c_result, _v_data_cxx_to_c_result, (long long)result.size() };
        size_t _i_result = 0;
        for (auto& value_result : result) {
            const auto& key_result = value_result.first;
            const auto& val_result = value_result.second;
            {
                
                auto _data_cxx_to_c_val_result = new int [val_result.size()];
                CDataArray cxx_to_c_val_result = { _data_cxx_to_c_val_result, (long long)val_result.size() };
                for (int _i_val_result = 0; _i_val_result < val_result.size(); ++_i_val_result) {
                    auto& value_val_result = val_result[_i_val_result];
                    
                    _data_cxx_to_c_val_result[_i_val_result] = value_val_result;
                }
                _k_data_cxx_to_c_result[_i_result] = key_result;
                _v_data_cxx_to_c_result[_i_result] = cxx_to_c_val_result;
                _i_result += 1;
            }
        }
        return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataMap result{};
    return result;
}

void _func_NestedExamples_setComplexStringVector(CObject cself, CDataArray v, ErrorObj* _Nonnull err){
    std::vector<std::vector<std::vector<std::string>>> c_to_cxx_v;

    auto data_v = reinterpret_cast<CDataArray*>(v.data);

    for (size_t _i_v = 0; _i_v < v.size; ++_i_v) {
        auto& value_v = data_v[_i_v];
        std::vector<std::vector<std::string>> c_to_cxx_value_v;

        auto data_value_v = reinterpret_cast<CDataArray*>(value_v.data);

        for (size_t _i_value_v = 0; _i_value_v < value_v.size; ++_i_value_v) {
            auto& value_value_v = data_value_v[_i_value_v];
            std::vector<std::string> c_to_cxx_value_value_v;

            auto data_value_value_v = reinterpret_cast<char**>(value_value_v.data);

            for (size_t _i_value_value_v = 0; _i_value_value_v < value_value_v.size; ++_i_value_value_v) {
                auto& value_value_value_v = data_value_value_v[_i_value_value_v];
                auto c_to_cxx_value_value_value_v = std::string(value_value_value_v);
                free(value_value_value_v);
                c_to_cxx_value_value_v.emplace_back(c_to_cxx_value_value_value_v);
            }
            c_to_cxx_value_v.emplace_back(c_to_cxx_value_value_v);
        }
        c_to_cxx_v.emplace_back(c_to_cxx_value_v);
    }
  
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        c_to_cxx_cself->setComplexStringVector(c_to_cxx_v);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataArray _func_NestedExamples_getComplexStringVector(CObject cself, ErrorObj* _Nonnull err){
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        const auto& result = c_to_cxx_cself->getComplexStringVector();
        auto _data_cxx_to_c_result = new CDataArray [result.size()];
        CDataArray cxx_to_c_result = { _data_cxx_to_c_result, (long long)result.size() };
        for (int _i_result = 0; _i_result < result.size(); ++_i_result) {
            auto& value_result = result[_i_result];
            auto _data_cxx_to_c_value_result = new CDataArray [value_result.size()];
            CDataArray cxx_to_c_value_result = { _data_cxx_to_c_value_result, (long long)value_result.size() };
            for (int _i_value_result = 0; _i_value_result < value_result.size(); ++_i_value_result) {
                auto& value_value_result = value_result[_i_value_result];
                auto _data_cxx_to_c_value_value_result = new char* [value_value_result.size()];
                CDataArray cxx_to_c_value_value_result = { _data_cxx_to_c_value_value_result, (long long)value_value_result.size() };
                for (int _i_value_value_result = 0; _i_value_value_result < value_value_result.size(); ++_i_value_value_result) {
                    auto& value_value_value_result = value_value_result[_i_value_value_result];
                    auto cxx_to_c_value_value_value_result = strdup(value_value_value_result.data());
                    _data_cxx_to_c_value_value_result[_i_value_value_result] = cxx_to_c_value_value_value_result;
                }
                _data_cxx_to_c_value_result[_i_value_result] = cxx_to_c_value_value_result;
            }
            _data_cxx_to_c_result[_i_result] = cxx_to_c_value_result;
        }
        return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataArray result{};
    return result;
}

void _func_NestedExamples_setComplexStringMap(CObject cself, CDataMap m, ErrorObj* _Nonnull err){
    std::map<std::string, std::map<std::string, std::map<std::string, std::string>>> c_to_cxx_m;

    for (size_t _i_m = 0; _i_m < m.size; ++_i_m) {
        auto ktmp_m = reinterpret_cast<char**>(m.keys)[_i_m];
        auto vtmp_m = reinterpret_cast<CDataMap*>(m.values)[_i_m];
        auto c_to_cxx_ktmp_m = std::string(ktmp_m);
        free(ktmp_m);
        std::map<std::string, std::map<std::string, std::string>> c_to_cxx_vtmp_m;

        for (size_t _i_vtmp_m = 0; _i_vtmp_m < vtmp_m.size; ++_i_vtmp_m) {
            auto ktmp_vtmp_m = reinterpret_cast<char**>(vtmp_m.keys)[_i_vtmp_m];
            auto vtmp_vtmp_m = reinterpret_cast<CDataMap*>(vtmp_m.values)[_i_vtmp_m];
            auto c_to_cxx_ktmp_vtmp_m = std::string(ktmp_vtmp_m);
            free(ktmp_vtmp_m);
            std::map<std::string, std::string> c_to_cxx_vtmp_vtmp_m;

            for (size_t _i_vtmp_vtmp_m = 0; _i_vtmp_vtmp_m < vtmp_vtmp_m.size; ++_i_vtmp_vtmp_m) {
                auto ktmp_vtmp_vtmp_m = reinterpret_cast<char**>(vtmp_vtmp_m.keys)[_i_vtmp_vtmp_m];
                auto vtmp_vtmp_vtmp_m = reinterpret_cast<char**>(vtmp_vtmp_m.values)[_i_vtmp_vtmp_m];
                auto c_to_cxx_ktmp_vtmp_vtmp_m = std::string(ktmp_vtmp_vtmp_m);
                free(ktmp_vtmp_vtmp_m);
                auto c_to_cxx_vtmp_vtmp_vtmp_m = std::string(vtmp_vtmp_vtmp_m);
                free(vtmp_vtmp_vtmp_m);
                c_to_cxx_vtmp_vtmp_m.insert({ c_to_cxx_ktmp_vtmp_vtmp_m, c_to_cxx_vtmp_vtmp_vtmp_m });
            }
            c_to_cxx_vtmp_m.insert({ c_to_cxx_ktmp_vtmp_m, c_to_cxx_vtmp_vtmp_m });
        }
        c_to_cxx_m.insert({ c_to_cxx_ktmp_m, c_to_cxx_vtmp_m });
    }
  
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        c_to_cxx_cself->setComplexStringMap(c_to_cxx_m);
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
}

CDataMap _func_NestedExamples_getComplexStringMap(CObject cself, ErrorObj* _Nonnull err){
    
    auto c_to_cxx_cself = static_cast<iegen::example::NestedExamples*>(cself.ptr);
    try {
        const auto& result = c_to_cxx_cself->getComplexStringMap();
        auto _k_data_cxx_to_c_result = new char* [result.size()];
        auto _v_data_cxx_to_c_result = new CDataMap [result.size()];
        CDataMap cxx_to_c_result = { _k_data_cxx_to_c_result, _v_data_cxx_to_c_result, (long long)result.size() };
        size_t _i_result = 0;
        for (auto& value_result : result) {
            const auto& key_result = value_result.first;
            const auto& val_result = value_result.second;
            {
                auto cxx_to_c_key_result = strdup(key_result.data());
                auto _k_data_cxx_to_c_val_result = new char* [val_result.size()];
                auto _v_data_cxx_to_c_val_result = new CDataMap [val_result.size()];
                CDataMap cxx_to_c_val_result = { _k_data_cxx_to_c_val_result, _v_data_cxx_to_c_val_result, (long long)val_result.size() };
                size_t _i_val_result = 0;
                for (auto& value_val_result : val_result) {
                    const auto& key_val_result = value_val_result.first;
                    const auto& val_val_result = value_val_result.second;
                    {
                        auto cxx_to_c_key_val_result = strdup(key_val_result.data());
                        auto _k_data_cxx_to_c_val_val_result = new char* [val_val_result.size()];
                        auto _v_data_cxx_to_c_val_val_result = new char* [val_val_result.size()];
                        CDataMap cxx_to_c_val_val_result = { _k_data_cxx_to_c_val_val_result, _v_data_cxx_to_c_val_val_result, (long long)val_val_result.size() };
                        size_t _i_val_val_result = 0;
                        for (auto& value_val_val_result : val_val_result) {
                            const auto& key_val_val_result = value_val_val_result.first;
                            const auto& val_val_val_result = value_val_val_result.second;
                            {
                                auto cxx_to_c_key_val_val_result = strdup(key_val_val_result.data());
                                auto cxx_to_c_val_val_val_result = strdup(val_val_val_result.data());
                                _k_data_cxx_to_c_val_val_result[_i_val_val_result] = cxx_to_c_key_val_val_result;
                                _v_data_cxx_to_c_val_val_result[_i_val_val_result] = cxx_to_c_val_val_val_result;
                                _i_val_val_result += 1;
                            }
                        }
                        _k_data_cxx_to_c_val_result[_i_val_result] = cxx_to_c_key_val_result;
                        _v_data_cxx_to_c_val_result[_i_val_result] = cxx_to_c_val_val_result;
                        _i_val_result += 1;
                    }
                }
                _k_data_cxx_to_c_result[_i_result] = cxx_to_c_key_result;
                _v_data_cxx_to_c_result[_i_result] = cxx_to_c_val_result;
                _i_result += 1;
            }
        }
        return cxx_to_c_result;
    }
    catch (const std::exception& e) {
        err->err_type = 1;
        err->err_ptr = new std::exception(e);
    }
    catch (...) {
        err->err_type = -1;
    }
    CDataMap result{};
    return result;
}