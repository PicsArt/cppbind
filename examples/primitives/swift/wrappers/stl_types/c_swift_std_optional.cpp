/**
 *   ______ .______   .______   .______    __  .__   __.  _______  
 *  /      ||   _  \  |   _  \  |   _  \  |  | |  \ |  | |       \ 
 * |  ,----'|  |_)  | |  |_)  | |  |_)  | |  | |   \|  | |  .--.  |
 * |  |     |   ___/  |   ___/  |   _  <  |  | |  . `  | |  |  |  |
 * |  `----.|  |      |  |      |  |_)  | |  | |  |\   | |  '--'  |
 *  \______|| _|      | _|      |______/  |__| |__| \__| |_______/ 
 * 
 * This file is generated by cppbind on 09/09/2022-13:51.
 * Please do not change it manually.
 */

#include <iostream>
#include <stdlib.h>
#include <string.h>
#include <cxxabi.h>
#include <memory>
#include <type_traits>
#include "swift/wrappers/stl_types/c_swift_std_optional.h"
#include "cxx/stl_types/std_optional.hpp"
#include "cxx/enums/color.hpp"
#include "cxx/enums/frame.hpp"

extern const char* CPPBIND_STD_STDEXCEPTION;
extern const char* CPPBIND_CPPBIND_EXAMPLE_FRAME;

const char* CPPBIND_CPPBIND_EXAMPLE_FRAMEUSAGE = "cppbind::example::FrameUsage";

using namespace cppbind::example;

CppBindOptionalInt _func_CppbindExample_mulInt(CppBindOptionalInt a, int b, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<int> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<int>(a_val);
    }
    
    try {
        const auto& result = cppbind::example::mul<int>(ctocxxa, b);
        CppBindOptionalInt cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalInt result {};
    return result;
}

CppBindOptionalFloat _func_CppbindExample_mulFloat(CppBindOptionalFloat a, float b, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<float> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<float>(a_val);
    }
    
    try {
        const auto& result = cppbind::example::mul<float>(ctocxxa, b);
        CppBindOptionalFloat cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalFloat result {};
    return result;
}

CppBindOptionalDouble _func_CppbindExample_mulDouble(CppBindOptionalDouble a, double b, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<double> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<double>(a_val);
    }
    
    try {
        const auto& result = cppbind::example::mul<double>(ctocxxa, b);
        CppBindOptionalDouble cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalDouble result {};
    return result;
}

CppBindOptionalCShort _func_CppbindExample_mulCShort(CppBindOptionalCShort a, short b, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<short> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<short>(a_val);
    }
    
    try {
        const auto& result = cppbind::example::mul<short>(ctocxxa, b);
        CppBindOptionalCShort cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalCShort result {};
    return result;
}

CppBindOptionalCLong _func_CppbindExample_mulLong(CppBindOptionalCLong a, long b, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<long> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<long>(a_val);
    }
    
    try {
        const auto& result = cppbind::example::mulLong(ctocxxa, b);
        CppBindOptionalCLong cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalCLong result {};
    return result;
}

CppBindOptionalBool _func_CppbindExample_reverseBool(CppBindOptionalBool a, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<bool> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<bool>(a_val);
    }
    try {
        const auto& result = cppbind::example::reverseBool(ctocxxa);
        CppBindOptionalBool cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalBool result {};
    return result;
}

CppBindOptionalUInt _func_CppbindExample_mulUnsignedInt(CppBindOptionalUInt a, unsigned int b, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<unsigned int> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<unsigned int>(a_val);
    }
    
    try {
        const auto& result = cppbind::example::mulUnsignedInt(ctocxxa, b);
        CppBindOptionalUInt cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalUInt result {};
    return result;
}

CppBindOptionalCUnsignedLong _func_CppbindExample_mulUnsignedLong(CppBindOptionalCUnsignedLong a, unsigned long b, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<unsigned long> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<unsigned long>(a_val);
    }
    
    try {
        const auto& result = cppbind::example::mulUnsignedLong(ctocxxa, b);
        CppBindOptionalCUnsignedLong cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalCUnsignedLong result {};
    return result;
}

CppBindOptionalCLongLong _func_CppbindExample_mulLongLong(CppBindOptionalCLongLong a, long long b, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<long long> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<long long>(a_val);
    }
    
    try {
        const auto& result = cppbind::example::mulLongLong(ctocxxa, b);
        CppBindOptionalCLongLong cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalCLongLong result {};
    return result;
}

CppBindOptionalCUnsignedChar _func_CppbindExample_mulUnsignedChar(CppBindOptionalCUnsignedChar a, unsigned char b, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<unsigned char> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<unsigned char>(a_val);
    }
    
    try {
        const auto& result = cppbind::example::mulUnsignedChar(ctocxxa, b);
        CppBindOptionalCUnsignedChar cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalCUnsignedChar result {};
    return result;
}

CppBindOptionalCharacter _func_CppbindExample_charToUpper(CppBindOptionalCharacter a, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<char> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<char>(a_val);
    }
    try {
        const auto& result = cppbind::example::charToUpper(ctocxxa);
        CppBindOptionalCharacter cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalCharacter result {};
    return result;
}

CppBindOptionalString _func_CppbindExample_concatString(CppBindOptionalString first, char* _Nonnull second, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<std::string> ctocxxfirst {std::nullopt};
    if (first.has_value) {
        auto& first_val = first.value;
        first.has_value = true;
        auto ctocxxfirst_val = std::string(first_val);
        free(first_val);
        ctocxxfirst = std::optional<std::string>(ctocxxfirst_val);
    }
    auto ctocxxsecond = std::string(second);
    free(second);
    try {
        const auto& result = cppbind::example::concatString(ctocxxfirst, ctocxxsecond);
        CppBindOptionalString cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            auto cxxtocresult_val = strdup(result_val.data());
            cxxtocresult.value = cxxtocresult_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalString result {};
    return result;
}

CppBindOptionalArray _func_CppbindExample_concat(CppBindOptionalArray v, char* _Nonnull s, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<std::vector<std::string>> ctocxxv {std::nullopt};
    if (v.has_value) {
        auto& v_val = v.value;
        v.has_value = true;
        std::vector<std::string> ctocxxv_val;

        auto data_v_val = reinterpret_cast<char**>(v_val.data);

        for (size_t _i_v_val = 0; _i_v_val < v_val.size; ++_i_v_val) {
            auto& value_v_val = data_v_val[_i_v_val];
            auto ctocxxvalue_v_val = std::string(value_v_val);
            free(value_v_val);
            ctocxxv_val.emplace_back(ctocxxvalue_v_val);
        }
        ctocxxv = std::optional<std::vector<std::string>>(ctocxxv_val);
    }
    auto ctocxxs = std::string(s);
    free(s);
    try {
        const auto& result = cppbind::example::concat(ctocxxv, ctocxxs);
        CppBindOptionalArray cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            auto _data_cxxtocresult_val = new char* [result_val.size()];
            CppBindCDataArray cxxtocresult_val = { _data_cxxtocresult_val, static_cast<long long>(result_val.size()) };
            for (int _i_result_val = 0; _i_result_val < result_val.size(); ++_i_result_val) {
                auto& value_result_val = result_val[_i_result_val];
                auto cxxtocvalue_result_val = strdup(value_result_val.data());
                _data_cxxtocresult_val[_i_result_val] = cxxtocvalue_result_val;
            }
            cxxtocresult.value = cxxtocresult_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalArray result {};
    return result;
}

CppBindCDataArray _func_CppbindExample_concat2(CppBindCDataArray v, char* _Nonnull s, CppBindCObject* _Nonnull cppbind_err) {
    std::vector<std::optional<std::string>> ctocxxv;

    auto data_v = reinterpret_cast<CppBindOptionalString*>(v.data);

    for (size_t _i_v = 0; _i_v < v.size; ++_i_v) {
        auto& value_v = data_v[_i_v];
        std::optional<std::string> ctocxxvalue_v {std::nullopt};
        if (value_v.has_value) {
            auto& value_v_val = value_v.value;
            value_v.has_value = true;
            auto ctocxxvalue_v_val = std::string(value_v_val);
            free(value_v_val);
            ctocxxvalue_v = std::optional<std::string>(ctocxxvalue_v_val);
        }
        ctocxxv.emplace_back(ctocxxvalue_v);
    }
    auto ctocxxs = std::string(s);
    free(s);
    try {
        const auto& result = cppbind::example::concat2(ctocxxv, ctocxxs);
        auto _data_cxxtocresult = new CppBindOptionalString [result.size()];
        CppBindCDataArray cxxtocresult = { _data_cxxtocresult, static_cast<long long>(result.size()) };
        for (int _i_result = 0; _i_result < result.size(); ++_i_result) {
            auto& value_result = result[_i_result];
            CppBindOptionalString cxxtocvalue_result {};
            if (value_result) {
                auto value_result_val = value_result.value();
                auto cxxtocvalue_result_val = strdup(value_result_val.data());
                cxxtocvalue_result.value = cxxtocvalue_result_val;
                cxxtocvalue_result.has_value = true;
            } else {
                cxxtocvalue_result.has_value = false;
            }
            _data_cxxtocresult[_i_result] = cxxtocvalue_result;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindCDataArray result {};
    return result;
}

CppBindOptionalInt _func_CppbindExample_sameColor(CppBindOptionalInt color, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<cppbind::example::Color> ctocxxcolor {std::nullopt};
    if (color.has_value) {
        auto& color_val = color.value;
        color.has_value = true;
        auto ctocxxcolor_val = static_cast<cppbind::example::Color>(color_val);
        ctocxxcolor = std::optional<cppbind::example::Color>(ctocxxcolor_val);
    }
    try {
        const auto& result = cppbind::example::sameColor(ctocxxcolor);
        CppBindOptionalInt cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            int cxxtocresult_val = static_cast<int>(result_val);
            cxxtocresult.value = cxxtocresult_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalInt result {};
    return result;
}

CppBindOptionalInt _func_CppbindExample_same_templateOptionalInt(CppBindOptionalInt a, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<int> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        
        ctocxxa = std::optional<int>(a_val);
    }
    try {
        const auto& result = cppbind::example::same_template<std::optional<int>>(ctocxxa);
        CppBindOptionalInt cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            cxxtocresult.value = result_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalInt result {};
    return result;
}

CppBindOptionalString _func_CppbindExample_same_templateOptionalString(CppBindOptionalString a, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<std::string> ctocxxa {std::nullopt};
    if (a.has_value) {
        auto& a_val = a.value;
        a.has_value = true;
        auto ctocxxa_val = std::string(a_val);
        free(a_val);
        ctocxxa = std::optional<std::string>(ctocxxa_val);
    }
    try {
        const auto& result = cppbind::example::same_template<std::optional<std::string>>(ctocxxa);
        CppBindOptionalString cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            auto cxxtocresult_val = strdup(result_val.data());
            cxxtocresult.value = cxxtocresult_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalString result {};
    return result;
}

CppBindOptionalPair _func_CppbindExample_samePair(CppBindOptionalPair pair, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<std::pair<int, int>> ctocxxpair {std::nullopt};
    if (pair.has_value) {
        auto& pair_val = pair.value;
        pair.has_value = true;
        auto& first_tmp_pair_val = *reinterpret_cast<int*>(pair_val.first);
        auto& second_tmp_pair_val = *reinterpret_cast<int*>(pair_val.second);


        std::pair<int, int> ctocxxpair_val { first_tmp_pair_val, second_tmp_pair_val };
        ctocxxpair = std::optional<std::pair<int, int>>(ctocxxpair_val);
    }
    try {
        const auto& result = cppbind::example::samePair(ctocxxpair);
        CppBindOptionalPair cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            auto _first_data_cxxtocresult_val = new int;
            auto _second_data_cxxtocresult_val = new int;
            const auto& first_result_val = result_val.first;
            const auto& second_result_val = result_val.second;


            *_first_data_cxxtocresult_val = first_result_val;
            *_second_data_cxxtocresult_val = second_result_val;
            CppBindCDataPair cxxtocresult_val = { _first_data_cxxtocresult_val, _second_data_cxxtocresult_val };
            cxxtocresult.value = cxxtocresult_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalPair result {};
    return result;
}

CppBindOptionalMap _func_CppbindExample_sameMap(CppBindOptionalMap map, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<std::map<int, int>> ctocxxmap {std::nullopt};
    if (map.has_value) {
        auto& map_val = map.value;
        map.has_value = true;
        std::map<int, int> ctocxxmap_val;

        for (size_t _i_map_val = 0; _i_map_val < map_val.size; ++_i_map_val) {
            auto ktmp_map_val = reinterpret_cast<int*>(map_val.keys)[_i_map_val];
            auto vtmp_map_val = reinterpret_cast<int*>(map_val.values)[_i_map_val];
            
            
            ctocxxmap_val.insert({ ktmp_map_val, vtmp_map_val });
        }
        ctocxxmap = std::optional<std::map<int, int>>(ctocxxmap_val);
    }
    try {
        const auto& result = cppbind::example::sameMap(ctocxxmap);
        CppBindOptionalMap cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            auto _k_data_cxxtocresult_val = new int [result_val.size()];
            auto _v_data_cxxtocresult_val = new int [result_val.size()];
            CppBindCDataMap cxxtocresult_val = { _k_data_cxxtocresult_val, _v_data_cxxtocresult_val, static_cast<long long>(result_val.size()) };
            size_t _i_result_val = 0;
            for (auto& value_result_val : result_val) {
                const auto& key_result_val = value_result_val.first;
                const auto& val_result_val = value_result_val.second;
                {
                    
                    
                    _k_data_cxxtocresult_val[_i_result_val] = key_result_val;
                    _v_data_cxxtocresult_val[_i_result_val] = val_result_val;
                    _i_result_val += 1;
                }
            }
            cxxtocresult.value = cxxtocresult_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalMap result {};
    return result;
}

void release_CppbindExample_FrameUsage(CppBindCObject cself, bool owner) {
    if (owner) {
        delete static_cast<cppbind::example::FrameUsage*>(cself.ptr);
    }
    free(cself.type);
}

CppBindCObject create_CppbindExample_FrameUsage(CppBindCObject* _Nonnull cppbind_err) {
    try {
        auto this_object = new cppbind::example::FrameUsage();
        return {strdup(CPPBIND_CPPBIND_EXAMPLE_FRAMEUSAGE), this_object};
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindCObject result {};
    return result;
}

CppBindOptionalObject _func_CppbindExample_FrameUsage_sameFrame(CppBindCObject cself, CppBindOptionalObject frame, CppBindCObject* _Nonnull cppbind_err) {
    std::optional<cppbind::example::Frame> ctocxxframe {std::nullopt};
    if (frame.has_value) {
        auto& frame_val = frame.value;
        frame.has_value = true;
        
        auto& ctocxxframe_val = *static_cast<cppbind::example::Frame*>(frame_val.ptr);
        ctocxxframe = std::optional<cppbind::example::Frame>(ctocxxframe_val);
    }

    auto ctocxxcself = static_cast<cppbind::example::FrameUsage*>(cself.ptr);
    try {
        const auto& result = ctocxxcself->sameFrame(ctocxxframe);
        CppBindOptionalObject cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            char* type_result_val = strdup(CPPBIND_CPPBIND_EXAMPLE_FRAME);
            auto value_ptr_result_val = const_cast<cppbind::example::Frame*>(new cppbind::example::Frame(result_val));
            CppBindCObject cxxtocresult_val = {type_result_val, value_ptr_result_val};
            cxxtocresult.value = cxxtocresult_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalObject result {};
    return result;
}

CppBindOptionalObject _func_CppbindExample_FrameUsage_getFrame(CppBindCObject cself, CppBindCObject* _Nonnull cppbind_err) {
    auto ctocxxcself = static_cast<cppbind::example::FrameUsage*>(cself.ptr);
    try {
        const auto& result = ctocxxcself->getFrame();
        CppBindOptionalObject cxxtocresult {};
        if (result) {
            auto result_val = result.value();
            
            char* type_result_val = strdup(CPPBIND_CPPBIND_EXAMPLE_FRAME);
            auto value_ptr_result_val = const_cast<cppbind::example::Frame*>(new cppbind::example::Frame(result_val));
            CppBindCObject cxxtocresult_val = {type_result_val, value_ptr_result_val};
            cxxtocresult.value = cxxtocresult_val;
            cxxtocresult.has_value = true;
        } else {
            cxxtocresult.has_value = false;
        }
        return cxxtocresult;
    } catch (const std::exception& e) {
        cppbind_err->type = strdup(CPPBIND_STD_STDEXCEPTION);
        cppbind_err->ptr = new std::exception(e);
    } catch (...) {
        cppbind_err->type = strdup("Uncaught Exception");
    }
    CppBindOptionalObject result {};
    return result;
}

