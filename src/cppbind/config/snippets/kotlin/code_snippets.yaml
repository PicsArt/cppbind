# Copyright (c) 2022 PicsArt, Inc.
# All rights reserved. Use of this source code is governed by a
# MIT-style license that can be found in the LICENSE file.

file:
  kotlin:
    file_path: |
      {{vars.file_fullname}}
    scopes:
      - body
      - include
      - glob_init
      - glob_external
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      package {{vars.full_package}}
      {% set helpers = helper_includes|format_list('import {}.*')|join_unique %}
      {%- set exc_vars = get_type_info("std::exception").vars %}
      {%- set exc_include = 'import ' + exc_vars.full_package + '.*' %}
      {{[helpers, exc_include, include]|sort_snippets|join(new_line)}}
      {%- if glob_init %}
      {{glob_init}}
      {%- endif %}
      {%- if body %}
      {{body}}
      {%- endif %}
      {%- if glob_external %}

      {{glob_external}}
      {%- endif %}

      private external fun jGettypebyid(id: Long): String{{new_line}}
  cxx:
    file_path: |
      {{vars.c_file_fullname}}
    scopes:
      - namespace
      - body
      - include
      - glob_decl
      - glob_def
      - forward_decl
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include "jni.h"
      #include <iostream>
      #include <cxxabi.h>
      #include <string.h>
      #include <type_traits>
      {{cxx_helper_includes|format_list('#include "{}"')|join(new_line)}}
      {{include}}
      {%- if glob_decl %}

      {{glob_decl}}
      {%- endif %}
      {%- if glob_def %}

      {{glob_def}}
      {%- endif %}
      {%- if forward_decl %}

      {{forward_decl}}
      {%- endif %}
      {{namespace}}

      {{body}}
      {% set file = path.splitext(path.basename(vars.file_fullname))[0] %}
      extern "C" JNIEXPORT jstring {{helper.get_jni_func_name(vars.full_package, file[0]|upper + file[1:] + 'Kt', 'jGettypebyid')}}(JNIEnv* env, jclass, jobjectid id) {
          validateID(id);
          return env->NewStringUTF(reinterpret_cast<CppBindCObject*>(id)->type);
      }{{new_line}}

package:

enum:
  kotlin:
    body: |
      {%- if vars.header_code_fragment %}
      {{new_line}}{{vars.header_code_fragment}}
      {%- endif %}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      enum class {{vars.name}}(val value: Int){{': ' if vars.bases_list}}{{vars.bases_list|join(', ')}} {
          {%- set comma = joiner(",") -%}
          {%- for case in enum_cases -%}
          {%- if case.name not in vars.enum_excluded_cases -%}
          {{comma()}}
          {%- if case.comment %}
          {{case.comment|make_doxygen_comment|indent(4)}}
          {%- endif %}
          {{vars.enum_case_names.get(case.name, vars.enum_case_name_prefix + case.name)}}({{case.value}})
          {%- endif %}
          {%- endfor %};

          companion object {
              private val values = values()
              fun getByValue(value: Int) = values.firstOrNull { it.value == value }
          }
          {%- if vars.code_fragment %}

          {{vars.code_fragment|indent(4)}}
          {%- endif %}
      }
      {%- if vars.footer_code_fragment %}
      {{new_line}}{{vars.footer_code_fragment}}
      {%- endif %}

var_class_cxx_glob_decl: &var_class_cxx_glob_decl
    unique_content: |
      {#- this should go to shared macro -#}
      {%- macro collect_include_type_infos(type_info, include_type_infos) -%}
      {%- if type_info.vars -%}
      {%- do include_type_infos.append(type_info) -%}
      {%- endif -%}
      {%- for arg_type_info in type_info.arg_types_infos -%}
          {%- do collect_include_type_infos(arg_type_info, include_type_infos) -%}
      {%- endfor -%}
      {%- endmacro -%}
      {%- macro collect_desc_include_type_infos(type_info, desc_include_type_infos) -%}
      {%- if type_info.vars and type_info.vars.descendants is defined -%}
      {%- for descendant in (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) -%}
          {%- do collect_include_type_infos(get_type_info(descendant), desc_include_type_infos) -%}
      {%- endfor -%}
      {%- endif -%}
      {%- for arg_type_info in type_info.arg_types_infos -%}
          {%- do collect_desc_include_type_infos(arg_type_info, desc_include_type_infos) -%}
      {%- endfor -%}
      {%- endmacro -%}
      {%- set desc_include_type_infos = [] -%}
      {%- do collect_desc_include_type_infos(type_info, desc_include_type_infos) -%}
      {%- for desc_type_info in desc_include_type_infos -%}
      {%- if desc_type_info.vars.c_file_fullname != vars.c_file_fullname -%}
      {{marker}}{{'extern const char* ' + make_type_converter(desc_type_info.cxx.type_name).cxx_type_name_global.snippet() + ';'}}
      {%- endif -%}
      {%- endfor -%}

var_class_cxx: &var_class_cxx
  include:
    unique_content:
      !concat
      - !include cxx_macros.yaml&cxx_include
      - |
        {%- macro collect_includes(converter, includes) -%}
        {%- if converter.cxx_include -%}
        {%- do includes.append(converter.cxx_include.snippet()) -%}
        {%- endif -%}
        {%- for arg_converter in converter.kotlin.args_converters -%}
        {%- do collect_includes(arg_converter, includes) -%}
        {%- endfor -%}
        {%- endmacro -%}
        {%- macro collect_desc_includes(converter, desc_includes) -%}
        {%- if converter.kotlin.vars and converter.kotlin.vars.descendants is defined -%}
        {%- for descendant in (converter.kotlin.vars.descendants if converter.kotlin.vars.descendants is not none else converter.kotlin.descendants) -%}
        {%- do collect_includes(make_type_converter(descendant), desc_includes) -%}
        {%- endfor -%}
        {%- endif -%}
        {%- for arg_converter in converter.kotlin.args_converters -%}
        {%- do collect_desc_includes(arg_converter, desc_includes) -%}
        {%- endfor -%}
        {%- endmacro -%}
        {%- set includes = [] -%}
        {%- do collect_includes(converter, includes) -%}
        {%- for base in base_types_converters -%}
        {%- do collect_includes(base, includes) -%}
        {%- endfor -%}
        {%- do collect_desc_includes(converter, includes) -%}
        {%- if includes -%}
        {{includes|join(marker)}}
        {%- endif -%}
        {%- set includes = gen_cxx_include(vars) -%}
        {%- if includes -%}{{includes}}{%- endif -%}
  namespace:
    unique_content: |
      {%- if cxx.namespace %}
      using namespace {{cxx.namespace}};
      {%- endif %}
  glob_decl: *var_class_cxx_glob_decl
  glob_def:
    unique_content: |
      const char* {{converter.cxx_type_name_global.snippet()}} = "{{cxx.unqualified_canonical_type_name}}";
  body:
    scopes:
      - body
    content:
      !concat
      - !include kotlin_macros.yaml&jni_functions
      - |
        {%- set descendants = vars.descendants if vars.descendants is not none else descendants %}
        {%- set is_root_class = base_types_converters|map(attribute='kotlin')|rejectattr('vars.action', 'equalto', 'gen_interface')|list|length == 0 %}
        {%- set parent_type_name = converter.kotlin.get_target_type_name(interface_class=vars.action == 'gen_interface') %}
        {%- if is_root_class %}
        {%- set finalize_name = helper.get_jni_func_name(vars.full_package, parent_type_name, 'jFinalize') %}
        extern "C" JNIEXPORT void {{finalize_name}}(JNIEnv*, jobject, jobjectid id){
            {%- if not vars.shared_ref and cxx.is_polymorphic and (vars.descendants if vars.descendants is not none else descendants) %}
            static_assert(std::has_virtual_destructor<{{cxx.unqualified_resolved_type_name}}>::value, {{'"{} type must have virtual destructor"'.format(cxx.unqualified_resolved_type_name)}});
            {%- endif %}
            auto cppbind_obj_id = reinterpret_cast<CppBindCObject*>(id);
            auto cppbind_obj_id_ptr = cppbind_obj_id ? cppbind_obj_id->ptr : nullptr;
            {#- here is used almost the same logic as for jni_to_cxx section of Object/std::shared_ptr type converter (instead of constructing target value we delete it here) -#}
            {%- if descendants %}
            if (strcmp(cppbind_obj_id->type, {{converter.cxx_type_name_global.snippet()}}) == 0)
            {%- if vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(cppbind_obj_id_ptr);
            {%- else %}
                delete static_cast<{{cxx.unqualified_resolved_type_name}}*>(cppbind_obj_id_ptr);
            {%- endif %}
            {%- for descendant in descendants %}
            else if (strcmp(cppbind_obj_id->type, {{make_type_converter(descendant).cxx_type_name_global.snippet()}}) == 0)
            {%- if vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{descendant}}>*>(cppbind_obj_id_ptr);
            {%- else %}
                delete static_cast<{{descendant}}*>(cppbind_obj_id_ptr);
            {%- endif %}
            {%- endfor %}
            else {
                std::cerr << "Unexpected object type: " << cppbind_obj_id->type << std::endl;
                exit(1);
            }
            {%- else %}
            {%- if vars.shared_ref %}
            delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(cppbind_obj_id_ptr);
            {%- else %}
            delete static_cast<{{cxx.unqualified_resolved_type_name}}*>(cppbind_obj_id_ptr);
            {%- endif %}
            {%- endif %}
            free(cppbind_obj_id->type);
            delete cppbind_obj_id;
        }
        {%- endif %}
        {#- object recover function is generated for all classes (not only for bases with reusing them for derived types) since the performance would be lowered in case of superbases with deep hierarchy -#}
        {%- if descendants %}
        {%- set this_converter = make_type_converter('std::shared_ptr<' + cxx.type_name + '>') if vars.shared_ref else converter %}

        {{this_converter.cxx_obj_recover_func_decl.snippet(name="id")}} {
            {{this_converter.cxx_obj_recover.snippet(name="id")|indent(4)}}
        }
        {%- endif -%}
        {%- if is_root_class %}

        {{gen_jni_cxxid_function()}}
        {%- endif %}
        {{body}}

var_class_kotlin_include: &var_class_kotlin_include
  unique_content: |
    {{marker if vars.include}}{{vars.include|format_list("import {}")|join_unique}}
    {%- macro collect_import_converters(converter, import_converters, gen_for_impl=false) -%}
    {%- if converter.kotlin.parent_type_info -%}
    {#- in case of nested cases we don't need `gen_for_impl` anymore, so we don't pass it deeper -#}
    {%- do collect_import_converters(make_type_converter(converter.kotlin.parent_type_info.cxx.type_name), import_converters) -%}
    {%- else %}
    {%- do import_converters.append((converter, gen_for_impl)) -%}
    {%- endif -%}
    {%- for arg_converter in converter.kotlin.args_converters -%}
    {%- do collect_import_converters(arg_converter, import_converters, gen_for_impl) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- macro collect_desc_import_converters(converter, desc_import_converters) -%}
    {%- if converter.kotlin.vars and converter.kotlin.vars.descendants is defined -%}
    {%- for descendant in (converter.kotlin.vars.descendants if converter.kotlin.vars.descendants is not none else converter.kotlin.descendants) -%}
    {%- do collect_import_converters(make_type_converter(descendant), desc_import_converters, gen_for_impl=true) -%}
    {%- endfor -%}
    {%- endif -%}
    {%- for arg_converter in converter.kotlin.args_converters -%}
    {%- do collect_desc_import_converters(arg_converter, desc_import_converters) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- set import_converters = [] -%}
    {%- for base in base_types_converters -%}
    {%- do collect_import_converters(base, import_converters) -%}
    {%- endfor -%}
    {%- set desc_import_converters = [] -%}
    {%- do collect_desc_import_converters(converter, desc_import_converters) -%}
    {%- for import_converter, _ in import_converters -%}
    {%- if import_converter.kotlin_include -%}
    {{marker}}{{import_converter.kotlin_include.snippet(full_package=vars.full_package)}}
    {%- endif -%}
    {%- endfor -%}
    {%- for desc_import_converter, gen_for_impl in desc_import_converters -%}
    {#- we need to import implementation classes for object construction (`gen_for_impl` is for tracking nested types) -#}
    {%- if desc_import_converter.kotlin_include -%}
    {{marker}}{{desc_import_converter.kotlin_include.snippet(interface_class=(gen_for_impl and desc_import_converter.kotlin.vars.action=='gen_interface'), full_package=vars.full_package)}}
    {%- endif -%}
    {%- endfor -%}

class:
  kotlin:
    include: *var_class_kotlin_include
    body:
      scopes:
        - head
        - properties
        - body
        - companion
        - private_external
      content:
        !concat
        - !include kotlin_macros.yaml&special_functions.class
        - |
          {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
          {%- do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
          {%- endif -%}
          {%- if vars.header_code_fragment -%}
          {{new_line}}{{vars.header_code_fragment}}
          {% endif -%}
          {%- set base_interfaces = base_types_converters|map(attribute='kotlin')|selectattr('vars.action', 'eq', 'gen_interface')|map(attribute='target_type_name')|list -%}
          {%- set is_root_class = not base_types_infos|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}
          {%- set bases_specifiers = base_interfaces + base_types_converters|map(attribute='kotlin.target_type_name')|reject('in', base_interfaces)|format_list('{}(obj)') + vars.bases_list + (['AutoCloseable'] if not base_types_converters or is_root_class else []) + (['Exception()'] if vars.is_exception and not ancestors|selectattr('vars.is_exception', 'equalto', True)|list else []) -%}
          {%- if base_types_converters|map(attribute='kotlin')|rejectattr('vars.action', 'equalto', 'gen_interface')|list|length > 1 %}
          {%- do Error.critical(cxx.type_name + ' has more than 1 non abstract base type.') %}
          {%- endif %}
          {%- if ancestors|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
          {%- do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
          {%- endif %}
          {%- if vars.comment %}
          {{vars.comment|make_doxygen_comment}}
          {%- endif %}
          {{'open ' if cxx.is_open}}class {{converter.kotlin.get_target_type_name(definition=True)}}
          internal constructor(obj: CppBindObject){{' : ' + bases_specifiers|join(', ') if bases_specifiers}} {
              companion object {
                  {%- if vars.c_wrapper_lib_name and is_root_class %}
                  init {
                      System.loadLibrary("{{vars.c_wrapper_lib_name}}")
                  }
                  {%- endif %}
                  {{companion|string|indent(8)}}
                  /**
                   * An internal property to keep an information about the underlying C++ object type.
                   * It is intended to be used by the generated code.
                   */
                  const val cppbindCxxTypeName: String = "{{cxx.unqualified_canonical_type_name}}"
                  {%- if (vars.descendants if vars.descendants is not none else descendants) and cxx.is_polymorphic %}

                  /**
                   * An internal method to create a Kotlin object from a C++ object.
                   * It is intended to be used by the generated code.
                   */
                  public fun cppbindConstructObject(id: Long, owner: Boolean = false): {{converter.kotlin.target_type_name}} {
                      {{converter.kotlin_obj_construction.snippet(name="id")|indent(12)}}
                  }
                  {%- endif %}
              }
              {% if is_root_class %}
              protected var cppbindObj = obj
              private var refs: MutableList<Any> = mutableListOf()

              /**
               * An internal method to bind the lifetimes of the current and another object.
               * It is intended to be used by the generated code.
               */
              {{'override ' if base_types_converters}}fun keepCppBindReference(ref: Any) {
                  refs.add(ref)
              }
              {%- endif %}
              {%- if base_types_converters|map(attribute='kotlin')|selectattr('vars.action', 'equalto', 'gen_interface')|list or not base_types_converters %}
              /**
               * An internal getter to get the id of an object.
               * It is intended to be used by the generated code.
               */
              {% if base_types_converters -%}
              {{'override '}}
              {%- else %}
              {{'open '}}
              {%- endif -%}
              val cppbindObjId: Long
                  get() {
                      if (cppbindObj.id == 0L) {
                          throw RuntimeException("Object is not allocated")
                      }
                      return cppbindObj.id
                  }
              {%- endif -%}
              {%- if is_root_class %}

              /**
               * An internal property returning underlying C++ object id.
               * It is intended to be used by the generated code.
               */
              internal val cxxId: Long by lazy {
                  jGetcxxid(cppbindObj.id)
              }

              /**
               * An internal property returning underlying C++ type name.
               * It is intended to be used by the generated code.
               */
              internal val cxxTypeName: String by lazy {
                  jGettypebyid(cppbindObj.id)
              }
              {%- endif %}
              {%- if head %}
              {{head|string|indent}}
              {%- endif %}
              {%- if properties %}
              {{properties|string|indent}}
              {%- endif %}
              {%- if body %}
              {{body|string|indent}}
              {%- endif %}
              {%- if is_root_class %}
              {%- if hash_decl not in body|string %}

              {{gen_default_hash_function()|indent(4)}}
              {%- endif %}
              {%- if equals_decl not in body|string %}

              {{gen_default_equals_function()|indent(4)}}
              {%- endif %}
              {%- if tostring_decl not in body|string %}

              {{gen_default_tostring_function()|indent(4)}}
              {%- endif %}

              override fun close() {
                  if (cppbindObj.owner && cppbindObj.id != 0L) {
                      jFinalize(cppbindObj.id)
                      cppbindObj.id = 0L
                  }
              }

              /**
               * Finalize and deletes the object
               */
              protected fun finalize() {
                  close()
              }
              {%- endif %}
              {%- if private_external or is_root_class %}

              ///// External wrapper functions ////////////
              {%- endif %}
              {%- if private_external %}
              {{private_external|string|indent}}
              {%- endif %}
              {%- if is_root_class %}
              private external fun jFinalize(id: Long): Unit
              private external fun jGetcxxid(id: Long): Long
              {%- endif %}
          }
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {% endif -%}
  cxx: *var_class_cxx

interface:
  kotlin:
    include: *var_class_kotlin_include
    body:
      scopes:
        - head
        - properties
        - body
        - companion
        - interface_external
      content:
        !concat
        - !include kotlin_macros.yaml&special_functions.class
        - |
          {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
          {%- do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
          {%- endif -%}
          {%- if vars.header_code_fragment -%}
          {{new_line}}{{vars.header_code_fragment}}
          {% endif -%}
          {%- set bases_specifiers = base_types_converters|map(attribute='kotlin.target_type_name')|list + vars.bases_list %}
          {%- if base_types_converters|map(attribute='kotlin')|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}
          {%- do Error.critical(cxx.type_name + ' interface cannot inherit from a class.') %}
          {%- endif %}
          {%- if ancestors|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
          {%- do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
          {%- endif %}
          {% if vars.comment %}
          {{vars.comment|make_doxygen_comment}}
          {%- endif %}
          interface {{converter.kotlin.get_target_type_name(definition=True)}}{{' : ' + bases_specifiers|join(', ') if bases_specifiers else ' : AutoCloseable'}} {
              {%- if not base_types_converters %}
              /**
               * An internal getter to get the id of an object.
               * It is intended to be used by the generated code.
               */
              val cppbindObjId: Long
              /**
               * An internal method to bind the lifetimes of the current and another object.
               * It is intended to be used by the generated code.
               */
              fun keepCppBindReference(ref: Any)
              {%- endif %}
              {{properties|string|indent}}
              {{body|string|indent}}
              {%- if (vars.descendants if vars.descendants is not none else descendants) and cxx.is_polymorphic %}

              companion object {
                  /**
                   * An internal method to create a Kotlin object from a C++ object.
                   * It is intended to be used by the generated code.
                   */
                  public fun cppbindConstructObject(id: Long, owner: Boolean = false): {{converter.kotlin.target_type_name}} {
                      {{converter.kotlin_obj_construction.snippet(name="id")|indent(12)}}
                  }
              }
              {%- endif %}
          }

          {% if interface_external %}
          class {{converter.kotlin.get_target_type_name(definition=True)}}Helper {
              companion object {
                  {{interface_external|string|indent(8)}}
              }
          }
          {% endif %}

          {{'open ' if cxx.is_open}}class {{converter.kotlin.get_target_type_name(interface_class=True, definition=True)}}
          internal constructor(obj : CppBindObject) : {{converter.kotlin.target_type_name}} {
              companion object {
                  {%- if vars.c_wrapper_lib_name %}
                  init {
                      System.loadLibrary("{{vars.c_wrapper_lib_name}}")
                  }
                  {%- endif %}
                  {{companion|string|indent(8)}}
                  /**
                   * An internal property to keep an information about the underlying C++ object type.
                   * It is intended to be used by the generated code.
                   */
                  const val cppbindCxxTypeName: String = "{{cxx.unqualified_canonical_type_name}}"
              }

              protected var cppbindObj = obj
              private var refs: MutableList<Any> = mutableListOf()

              override fun keepCppBindReference(ref: Any) {
                  refs.add(ref)
              }

              override val cppbindObjId: Long
                  get() {
                      if (cppbindObj.id == 0L) {
                          throw RuntimeException("Object is not allocated")
                      }
                      return cppbindObj.id
                  }

              /**
               * An internal property returning underlying C++ object id.
               * It is intended to be used by the generated code.
               */
              internal val cxxId: Long by lazy {
                  jGetcxxid(cppbindObj.id)
              }

              /**
               * An internal property returning underlying C++ type name.
               * It is intended to be used by the generated code.
               */
              internal val cxxTypeName: String by lazy {
                  jGettypebyid(cppbindObj.id)
              }
              {%- if head %}
              {{head|string|indent}}
              {%- endif %}
              {%- if not base_types_converters|map(attribute='kotlin')|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}

              override fun close() {
                  if (cppbindObj.owner && cppbindObj.id != 0L) {
                      jFinalize(cppbindObj.id)
                      cppbindObj.id = 0L
                  }
              }

              /**
              * Finalize and deletes the object
              */
              protected fun finalize() {
                  close()
              }
              {% endif %}
              {{gen_default_hash_function()|indent(4)}}

              {{gen_default_equals_function(True)|indent(4)}}

              {{gen_default_tostring_function()|indent(4)}}

              ///// External wrapper functions ////////////
              private external fun jFinalize(id: Long): Unit
              private external fun jGetcxxid(id: Long): Long
          }
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {% endif -%}
  cxx: *var_class_cxx


var_method_kotlin_include: &var_method_kotlin_include
  unique_content: |
    {%- macro gen_import(converter) -%}
    {%- if converter.kotlin.parent_type_info -%}
    {{gen_import(make_type_converter(converter.kotlin.parent_type_info.cxx.type_name))}}
    {%- elif converter.kotlin_include -%}
    {{marker}}{{converter.kotlin_include.snippet(full_package=vars.full_package)}}
    {%- endif -%}
    {%- for arg_converter in converter.kotlin.args_converters -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- endmacro -%}
    {%- for arg_converter in args|map(attribute='converter') -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_import(rconverter)}}
    {%- endif -%}

var_method_cxx_include: &var_method_cxx_include
  unique_content:
    !concat
    - !include cxx_macros.yaml&cxx_include
    - |
      {%- if vars.is_proj_type -%}
      {{marker}}#include "{{vars.prj_rel_file_name}}"
      {%- endif -%}
      {#- this should go to shared macro cxx_include -#}
      {%- macro gen_include(converter) -%}
      {%- if converter.cxx_include -%}
      {{marker}}{{converter.cxx_include.snippet()}}
      {%- endif -%}
      {%- if converter.kotlin -%}
      {%- for arg_converter in converter.kotlin.args_converters -%}
      {{gen_include(arg_converter)}}
      {%- endfor -%}
      {%- endif -%}
      {%- endmacro -%}
      {%- for arg in args -%}
      {{gen_include(arg.converter)}}
      {%- endfor -%}
      {%- if rconverter is defined -%}
      {{gen_include(rconverter)}}
      {%- endif -%}
      {%- set includes = gen_cxx_include(vars) -%}
      {%- if includes -%}{{includes}}{%- endif -%}

var_method_cxx_forward_decl: &var_method_cxx_forward_decl
  unique_content: |
    {%- macro collect_fwd_decl_type_infos(type_info, fwd_decl_type_infos) -%}
    {#- Type comparison is done when the type has descendants. Forward decl is not needed when the object recover function is generated in the same file as current function/method. -#}
    {%- if type_info.vars and type_info.vars.descendants is defined and (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) and vars.c_file_fullname != type_info.vars.c_file_fullname -%}
    {%- do fwd_decl_type_infos.append(type_info) -%}
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
        {%- do collect_fwd_decl_type_infos(arg_type_info, fwd_decl_type_infos) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- set fwd_decl_type_infos = [] -%}
    {%- for arg in args -%}
        {%- do collect_fwd_decl_type_infos(arg.type_info, fwd_decl_type_infos) -%}
    {%- endfor -%}
    {%- for fwd_decl_type_info in fwd_decl_type_infos -%}
    {%- set fwd_decl_type_converter = make_type_converter('std::shared_ptr<' + fwd_decl_type_info.cxx.type_name + '>' if fwd_decl_type_info.vars.shared_ref else fwd_decl_type_info.cxx.type_name) -%}
    {{marker}}{{fwd_decl_type_converter.cxx_obj_recover_func_decl.snippet(is_fwd_decl=True)}};
    {%- endfor -%}

var_method_cxx_glob_decl: &var_method_cxx_glob_decl
  unique_content: |
    {#- this should go to shared macro -#}
    {%- macro collect_type_info_names(type_info, result_type_info_names) -%}
    {%- if type_info.vars -%}
    {%- do result_type_info_names.append(type_info.cxx.unqualified_canonical_type_name) -%}
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
        {%- do collect_type_info_names(arg_type_info, result_type_info_names) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- macro gen_glob_decl(type_names) -%}
    {%- for type_name in type_names -%}
        {%- set type_conv = make_type_converter(type_name) -%}
        {%- set type_info = get_type_info(type_name) -%}
        {#- `cxx_type_name_global` is none for enum types -#}
        {%- if type_conv.cxx_type_name_global is not none and type_info.vars.c_file_fullname != vars.c_file_fullname -%}
        {{marker}}{{'extern const char* ' + type_conv.cxx_type_name_global.snippet() + ';'}}
        {%- endif -%}
    {%- endfor -%}
    {%- endmacro -%}
    {#- `return_type_info` is not defined for constructors -#}
    {%- if return_type_info is defined -%}
    {%- set result_type_info_names = [] -%}
    {%- do collect_type_info_names(return_type_info, result_type_info_names) -%}
    {{gen_glob_decl(result_type_info_names)}}
    {%- endif -%}
    {#- `vars.throws` is not defiend for property getters/setters -#}
    {%- if vars.throws is defined and not 'no_throw' in vars.throws -%}
    {{gen_glob_decl(vars.throws)}}
    {%- endif -%}
    {%- if setter is defined and not 'no_throw' in setter.vars.throws -%}
    {{gen_glob_decl(setter.vars.throws)}}
    {%- endif -%}
    {{gen_glob_decl(['std::exception'])}}

constructor:
  kotlin:
    include: *var_method_kotlin_include
    head: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {%- set comma = joiner(', ') %}
      constructor({%- for arg in args -%}
      {{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
      {%- if arg.default -%}
      {%- if arg.is_enum %}
      {%- set enum_case_name = arg.default.split('::')|last %}
      {%- if enum_case_name in arg.type_info.vars.enum_excluded_cases -%}
      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} constructor argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- else %} = {{arg.converter.kotlin.target_type_name}}.{{arg.type_info.vars.enum_case_names.get(enum_case_name, arg.type_info.vars.enum_case_name_prefix + enum_case_name)}}
      {%- endif -%}
      {%- else -%}
      {%- if arg.default_is_literal %} = {{arg.default}}{{'F' if arg.is_float}}{{'L' if arg.is_long}}{{'u' if arg.is_uchar}}
      {%- elif arg.default_is_nullptr %} = null
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor -%}): this(CppBindObject(construct_helper({{args|join(', ', attribute='name')}}), true)) {
          {#- This should go to shared macro -#}
          {%- if vars.keep_alive %}
          {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
          {%- if invalid_args  %}
          {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
          {%- endif %}
          {%- for arg_idx in vars.keep_alive %}
          {%- set converter = args[arg_idx - 1].converter %}
          {%- if converter.kotlin_keep_alive %}
          {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
          {%- endif %}
          {%- endfor %}
          {%- endif %}
      }
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}
    companion: |
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- set comma = joiner(', ') %}
      protected fun construct_helper({%- for arg in args -%}
      {{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{%- endfor-%}): Long {
          {%- set call_args = [] %}
          {%- for arg in args %}
          {%- set converter = arg.converter.kotlin_to_jdk %}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
          {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg_name)) %}
          {%- endfor %}
          {#- extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
          {%- for arg in args %}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name) %}
          {%- do call_args.append(arg_name) if not arg_name in call_args %}
          {%- endfor %}
          val id = jConstructor{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({{call_args|join(', ')}})
          return id
      }
      {% set comma = joiner(', ') %}
      @JvmStatic
      private external fun jConstructor{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): Long
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}
  cxx:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- set parent_type_name = owner_class.converter.kotlin.get_target_type_name(interface_class=owner_class.vars.action == 'gen_interface') %}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- set index = '_' + index|string if index else '' %}
      {%- set jni_name = helper.get_jni_func_name(vars.full_package, parent_type_name, 'jConstructor' + (vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix) + template_postfix + index) %}
      extern "C" JNIEXPORT jobjectid {{jni_name}}([[maybe_unused]] JNIEnv* env, jobject{{', ' if args}}
      {%- set comma = joiner(', ') -%}
      {% for arg in args -%}
      {{comma()}}{{arg.converter.jni.target_type_name}} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
      {%- endfor %}{{', ...' if args}}){
          {%- set call_args = [] -%}
          {%- for arg in args -%}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
          {% set converter = arg.converter.jni_to_cxx %}
          {{converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr)|indent(4)}}
          {%- do call_args.append(converter.converted_name(arg_name)) -%}
          {%- endfor %}
          {%- if 'no_throw' not in vars.throws %}
          void* err_ptr = nullptr;
          {%- endif %}
          try {
              {%- if not owner_class.root.vars.shared_ref %}
              {{owner_class.cxx.unqualified_resolved_type_name}}* ptr = new {{owner_class.cxx.type_name}}({{call_args|join(', ')}});
              return reinterpret_cast<jlong>(new CppBindCObject {strdup({{owner_class.converter.cxx_type_name_global.snippet()}}), ptr});
              {%- else %}
              {{owner_class.cxx.type_name}}* obj_ptr = new {{owner_class.cxx.type_name}}({{call_args|join(', ')}});
              auto this_object = std::shared_ptr<{{owner_class.cxx.type_name}}>(obj_ptr);
              return reinterpret_cast<jlong>(new CppBindCObject {strdup({{owner_class.converter.cxx_type_name_global.snippet()}}), new std::shared_ptr<{{owner_class.cxx.type_name}}>(this_object)});
              {%- endif %}
          }
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws -%}
          catch (const {{exc_type}}& e) {
              err_ptr = new {{exc_type}}(e);
              {%- set exc_info = get_type_info(exc_type) %}
              {%- set exc_conv = make_type_converter(exc_type) %}
              jclass excCls = env->FindClass("{{[exc_info.vars.full_package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
              jclass cppbindObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'alias.CppBindObject']|map('replace', '.', pat_sep)|path_join}}");
              jmethodID cppbindConstructor = env->GetMethodID(cppbindObjClass, "<init>", "(JZ)V");
              jobject cppbindObj = env->NewObject(cppbindObjClass, cppbindConstructor, reinterpret_cast<jobjectid>(new CppBindCObject {strdup({{exc_conv.cxx_type_name_global.snippet()}}), err_ptr}), true);
              jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'alias.CppBindObject']|map('replace', '.', pat_sep)|path_join}};)V");
              jobject excObj = env->NewObject(excCls, excConstructor, cppbindObj);
              env->Throw(jthrowable(excObj));
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          catch (const std::exception& e) {
              jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
          }
          {%- endif %}
          catch (...) {
              jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
          }
          jobjectid result {};
          return result;
      }
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}

method:
  kotlin:
    include: *var_method_kotlin_include
    body:
      !concat
      - !include kotlin_macros.yaml&validations
      - !include kotlin_macros.yaml&special_functions.method
      - |
        {%- do run_method_validations() -%}
        {%- if cxx.name == vars.hash_method -%}
        {{gen_hash_function()}}
        {%- elif cxx.name == vars.equals_method or (vars.name == "equals" and vars.is_operator) -%}
        {{gen_equals_function()}}
        {%- elif cxx.name == vars.tostring_method -%}
        {{gen_tostring_function()}}
        {%- else -%}
        {%- if not cxx.is_static %}
        {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
        {#- this should go to shared macro #}
        {%- macro gen_func(args, index=none) -%}
        {%- set comma = joiner(', ') -%}
        {%- if vars.comment %}
        {{vars.comment|make_doxygen_comment}}
        {%- endif %}
        {{'open ' if cxx.is_open}}{{'operator ' if vars.is_operator}}{{'override ' if cxx.is_override}}fun {{vars.name}}(
        {%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
        {%- if arg.default -%}
        {%- if arg.is_enum %}
        {%- set enum_case_name = arg.default.split('::')|last %}
        {%- if enum_case_name in arg.type_info.vars.enum_excluded_cases -%}
        {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
        {%- else %} = {{arg.converter.kotlin.target_type_name}}.{{arg.type_info.vars.enum_case_names.get(enum_case_name, arg.type_info.vars.enum_case_name_prefix + enum_case_name)}}
        {%- endif -%}
        {%- else -%}
        {%- if arg.default_is_literal %} = {{arg.default}}{{'F' if arg.is_float}}{{'L' if arg.is_long}}{{'u' if arg.is_uchar}}
        {%- elif arg.default_is_nullptr %} = null
        {%- endif %}
        {%- endif %}
        {%- endif -%}
        {%- endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if vars.nullable_return}} {
            {%- set call_args = ['cppbindObjId'] -%}
            {%- set result_converter = rconverter.jdk_to_kotlin -%}
            {%- for arg in args %}
            {%- set converter = arg.converter.kotlin_to_jdk -%}
            {%- set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
            {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) -%}
            {%- if conversion %}
            {{conversion|indent}}
            {%- endif %}
            {%- do call_args.append(converter.converted_name(arg_name)) %}
            {%- endfor %}
            {#- extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
            {%- for arg in args %}
            {%- set arg_name = vars.argument_name.get(arg.name, arg.name) %}
            {%- do call_args.append(arg_name) if not arg_name in call_args %}
            {%- endfor %}
            {%- if owner_class.vars.action == 'gen_interface' %}
            val result = {{owner_class.converter.kotlin.target_type_name}}Helper.j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({{call_args|join(', ')}})
            {%- else %}
            val result = j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({{call_args|join(', ')}})
            {%- endif %}
            {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
            {%- if vars.keep_alive and not (vars.is_operator and vars.name == 'get') %}
            {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
            {%- if invalid_args  %}
            {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
            {%- endif %}
            {%- for arg_idx in vars.keep_alive %}
            {%- set converter = args[arg_idx - 1].converter %}
            {%- if converter.kotlin_keep_alive %}
            {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
            {%- endif %}
            {%- endfor %}
            {%- endif %}
            {%- if vars.return_value_policy == 'reference_internal' and rconverter.kotlin_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
            {%- set conversion = rconverter.kotlin_ref_internal.snippet(result_converter.converted_name('result'), reference='this', nullable=vars.nullable_return) -%}
            {%- if conversion %}
            {{conversion|indent(4)}}{% endif %}
            {%- endif %}
            return {{result_converter.converted_name('result')}}
        }
        {%- endmacro -%}
        {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(args)}}


        {%- if vars.is_operator and vars.name == 'get' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
        {% set setter_var_name = 'value' %}

        {{'open ' if cxx.is_open}}{{'operator ' if vars.is_operator}}{{'override ' if cxx.is_override}}fun set(
        {%- for arg in args -%}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.kotlin.target_type_name}}, {{setter_var_name}}: {{rconverter.kotlin.target_type_name}}
        {%- endfor-%}){
            {%- set call_args = ['cppbindObjId'] -%}
            {%- for arg in args %}
            {%- set converter = arg.converter.kotlin_to_jdk -%}
            {%- set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
            {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) -%}
            {%- if conversion %}
            {{conversion|indent}}
            {%- endif %}
            {%- do call_args.append(converter.converted_name(arg_name)) %}
            {%- endfor %}
            {#- extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
            {%- set extra_call_args = [] -%}
            {%- for arg in args %}
            {%- set arg_name = vars.argument_name.get(arg.name, arg.name) %}
            {%- do extra_call_args.append(arg_name) if not arg_name in call_args %}
            {%- endfor %}
            {%- if owner_class.vars.action == 'gen_interface' %}
            {{owner_class.converter.kotlin.target_type_name}}Helper.jSet{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{call_args|join(', ')}}, {{setter_var_name}})
            {%- else %}
            jSet{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{call_args|join(', ')}}, {{setter_var_name}})
            {#- This should go to shared macro -#}
            {%- if vars.keep_alive %}
            {%- set args = args + [namespace(name='value', converter=rconverter)] -%}
            {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
            {%- if invalid_args  %}
            {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
            {%- endif %}
            {%- for arg_idx in vars.keep_alive %}
            {%- set converter = args[arg_idx - 1].converter %}
            {%- if converter.kotlin_keep_alive %}
            {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
            {%- endif %}
            {%- endfor %}
            {%- endif %}
            {%- endif %}
        }

        {%- endif %}

        {%- endif %}
        {%- endif %}
    companion: |
      {%- if cxx.is_static %}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- if vars.return_value_policy == 'reference_internal' -%}
      {% do Error.critical("Cannot apply reference internal policy on a static method's return value: {}::{}".format(owner_class.cxx.type_name, cxx.name)) -%}
      {%- endif -%}
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive %}
      {%- do Error.critical('Cannot apply keep alive policy for a static member function: {}.{}'.format(cxx.name, owner_class.cxx.type_name)) -%}
      {%- endif %}
      {%- set comma = joiner(', ') -%}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      fun {{vars.name}}({%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{%- endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if vars.nullable_return}} {
          {%- set call_args = [] %}
          {%- set result_converter = rconverter.jdk_to_kotlin -%}
          {%- for arg in args -%}
          {%- set converter = arg.converter.kotlin_to_jdk -%}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
          {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) -%}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg_name)) %}
          {%- endfor %}
          {#- extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
          {%- for arg in args %}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name) %}
          {%- do call_args.append(arg_name) if not arg_name in call_args %}
          {%- endfor %}
          {%- if owner_class.vars.action == 'gen_interface' %}
          val result = {{owner_class.converter.kotlin.target_type_name}}Helper.j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({{call_args|join(', ')}})
          {%- else %}
          val result = j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({{call_args|join(', ')}})
          {%- endif %}
          {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent}}
          return {{result_converter.converted_name('result')}}
      }
      {%- set comma = joiner(', ') %}
      @JvmStatic
      private external fun j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): {{rconverter.jdk.target_type_name}}
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}
      {%- endif %}
    private_external: |
      {%- if owner_class.vars.action == 'gen_class' -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- if not cxx.is_static %}
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- set comma = joiner(', ') -%}
      private external fun j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): {{rconverter.jdk.target_type_name}}
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}
      {%- if vars.is_operator and vars.name == 'get' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
      {%- set comma = joiner(', ') -%}
      {%- set setter_var_name = 'value' %}
      private external fun jSet{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}, {{setter_var_name}}: {{rconverter.kotlin.target_type_name}}{{', vararg extraObjs: Any?' if args}})
      {%- endif %}
      {%- endif %}
      {%- endif -%}
    interface_external: |
      {%- if owner_class.vars.action == 'gen_interface' -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- if not cxx.is_static %}
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- set comma = joiner(', ') -%}
      @JvmStatic
      external fun j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): {{rconverter.jdk.target_type_name}}
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}
      {%- if vars.is_operator and vars.name == 'get' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
      {%- set comma = joiner(', ') %}
      {%- set setter_var_name = 'value' %}
      @JvmStatic
      external fun jSet{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}, {{setter_var_name}}: {{rconverter.kotlin.target_type_name}}{{', vararg extraObjs: Any?' if args}})
      {%- endif %}
      {%- endif %}
      {%- endif %}
  cxx:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- set parent_type_name = owner_class.converter.kotlin.target_type_name + 'Helper' if owner_class.vars.action == 'gen_interface' else owner_class.converter.kotlin.target_type_name %}
      {%- set setter_var_name = 'value' -%}
      {%- macro args_snippet(args, call_args) -%}
      {%- for arg in args -%}
      {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
      {%- set converter = arg.converter.jni_to_cxx %}
      {{converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr)}}
      {%- do call_args.append(converter.converted_name(arg_name))%}
      {% endfor %}
      {%- endmacro -%}
      {%- macro call_code(prefix, call_args, is_set_op=false) -%}
      {%- if 'no_throw' not in vars.throws %}
      void* err_ptr = nullptr;
      {%- endif -%}
      {% if rconverter.jni.target_type_name != 'void' and not is_set_op %}
      try {
          const auto& result = {{prefix}}{{cxx.name}}{%- if cxx.is_template -%}
                                              <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                              {%- endif -%}({{call_args|join(', ')}});
          {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
          return {{rconverter.cxx_to_jni.converted_name('result')}};
      }
      {%- else %}
      try {
          {{prefix}}{{cxx.name}}({{call_args|join(', ')}}){{' = ' + setter_var_name if is_set_op}};
          return;
      }
      {%- endif %}
      {%- if 'no_throw' not in vars.throws %}
      {%- for exc_type in vars.throws -%}
      catch (const {{exc_type}}& e) {
          err_ptr = new {{exc_type}}(e);
          {%- set exc_info = get_type_info(exc_type) %}
          {%- set exc_conv = make_type_converter(exc_type) %}
          jclass excCls = env->FindClass("{{[exc_info.vars.full_package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
          jclass cppbindObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'alias.CppBindObject']|map('replace', '.', pat_sep)|path_join}}");
          jmethodID cppbindConstructor = env->GetMethodID(cppbindObjClass, "<init>", "(JZ)V");
          jobject cppbindObj = env->NewObject(cppbindObjClass, cppbindConstructor, reinterpret_cast<jobjectid>(new CppBindCObject {strdup({{exc_conv.cxx_type_name_global.snippet()}}), err_ptr}), true);
          jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'alias.CppBindObject']|map('replace', '.', pat_sep)|path_join}};)V");
          jobject excObj = env->NewObject(excCls, excConstructor, cppbindObj);
          env->Throw(jthrowable(excObj));
      }
      {%- endfor %}
      {%- endif %}
      {%- if not 'std::exception' in vars.throws %}
      catch (const std::exception& e) {
          jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
          jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
          env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
      }
      {%- endif %}
      catch (...) {
          jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
          jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
          env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
      }

      {% if rconverter.jni.target_type_name != 'void' and not is_set_op -%}
      {{rconverter.jni.target_type_name}} result {};
      return result;
      {%- endif %}
      {%- endmacro -%}
      {%- macro gen_method(is_set_op=false) -%}
      {%- set index = '_' + index|string if index else '' %}
      {%- set func_name="j%s%s%s%s"|format('Set' if is_set_op else vars.name|capitalize, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix, template_postfix, index) %}
      {%- set jni_name = helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}

      extern "C" JNIEXPORT {{ 'void' if is_set_op else rconverter.jni.target_type_name }} {{jni_name}}([[maybe_unused]] JNIEnv* env, jobject{{", jobjectid id" if not cxx.is_static}}{{', ' if args}}
      {%- set comma = joiner(', ') -%}
      {%- for arg in args -%}
      {{comma()}}{{arg.converter.jni.target_type_name}} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
      {%- endfor %}{{', ' + rconverter.jni.target_type_name + ' ' + setter_var_name if is_set_op}}{{', ...' if args}}){
          {%- set call_args = [] %}
          {{args_snippet(args, call_args)|indent(4)}}
          {%- if not cxx.is_static %}
          validateID(id);
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').jni_to_cxx if owner_class.vars.shared_ref else owner_class.converter.jni_to_cxx -%}
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          {{call_code(this_converter.converted_name('id') + "->", call_args, is_set_op)|indent(4)}}
          {%- else %}
          {{call_code(owner_class.cxx.type_name + "::", call_args, is_set_op)|indent(4)}}
          {%- endif %}
      }
      {%- endmacro -%}
      {{gen_method()}}
      {%- if vars.is_operator and vars.name == 'get' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
      {{gen_method(is_set_op=true)}}
      {%- endif %}
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}

function:
  kotlin:
    include: *var_method_kotlin_include
    body: |
      {%- if vars.return_value_policy == 'reference_internal' -%}
      {% do Error.critical("Cannot apply reference internal policy on a non member function's return value: {} in {}".format(cxx.name, cxx.source_file_name)) -%}
      {%- endif -%}
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname) -%}
      {%- endif -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- set comma = joiner(', ') -%}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      fun {{vars.name}}({%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
      {%- if arg.default -%}
      {%- if arg.is_enum %}
      {%- set enum_case_name = arg.default.split('::')|last %}
      {%- if enum_case_name in arg.type_info.vars.enum_excluded_cases -%}
      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- else %} = {{arg.converter.kotlin.target_type_name}}.{{arg.type_info.vars.enum_case_names.get(enum_case_name, arg.type_info.vars.enum_case_name_prefix + enum_case_name)}}
      {%- endif -%}
      {%- else -%}
      {%- if arg.default_is_literal %} = {{arg.default}}{{'F' if arg.is_float}}{{'L' if arg.is_long}}{{'u' if arg.is_uchar}}
      {%- elif arg.default_is_nullptr %} = null
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if vars.nullable_return}} {
          {%- set call_args = [] -%}
          {%- set result_converter = rconverter.jdk_to_kotlin -%}
          {%- for arg in args %}
          {%- set converter = arg.converter.kotlin_to_jdk -%}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
          {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) -%}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg_name)) %}
          {%- endfor %}
          {#- extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
          {%- for arg in args %}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name) %}
          {%- do call_args.append(arg_name) if not arg_name in call_args %}
          {%- endfor %}
          val result = j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({{call_args|join(', ')}})
          {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent}}
          return {{result_converter.converted_name('result')}}
      }
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}
    glob_external: |
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- set comma = joiner(', ') -%}
      private external fun j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): {{rconverter.jdk.target_type_name}}
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}
    glob_init:
      unique_content: |
        {%- if vars.c_wrapper_lib_name %}
        private val INIT = run {
            System.loadLibrary("{{vars.c_wrapper_lib_name}}");
        }
        {%- endif %}
  cxx:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {#- this should go to shared macro #}
      {%- macro gen_func(args, index=none) -%}
      {%- set index = '_' + index|string if index else '' %}
      {%- set func_name="j%s%s%s%s"|format(vars.name|capitalize, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none and cxx.is_overloaded else overloading_postfix, template_postfix, index) %}
      {%- macro args_snippet(args, call_args) %}
      {%- for arg in args -%}
      {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
      {%- set converter = arg.converter.jni_to_cxx %}
      {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
      {%- if conversion %}
      {{conversion}}
      {%- endif %}
      {%- do call_args.append(converter.converted_name(arg_name))%}
      {%- endfor %}
      {%- endmacro %}
      {%- macro call_code(call_args) %}
      {%- if 'no_throw' not in vars.throws %}
      void* err_ptr = nullptr;
      {%- endif -%}
      {%- if rconverter.jni.target_type_name != 'void' %}
      try {
          const auto& result = {{cxx.namespace}}::{{cxx.name}}{%- if cxx.is_template -%}
                                              <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                              {%- endif -%}({{call_args|join(', ')}});
          {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
          return {{rconverter.cxx_to_jni.converted_name('result')}};
      }
      {%- else %}
      try {
          {{cxx.namespace}}::{{cxx.name}}({{call_args|join(', ')}});
          return;
      }
      {%- endif %}
      {%- if 'no_throw' not in vars.throws %}
      {%- for exc_type in vars.throws -%}
      catch (const {{exc_type}}& e) {
          err_ptr = new {{exc_type}}(e);
          {%- set exc_info = get_type_info(exc_type) %}
          {%- set exc_conv = make_type_converter(exc_type) %}
          jclass excCls = env->FindClass("{{[exc_info.vars.full_package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
          jclass cppbindObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'alias.CppBindObject']|map('replace', '.', pat_sep)|path_join}}");
          jmethodID cppbindConstructor = env->GetMethodID(cppbindObjClass, "<init>", "(JZ)V");
          jobject cppbindObj = env->NewObject(cppbindObjClass, cppbindConstructor, reinterpret_cast<jobjectid>(new CppBindCObject {strdup({{exc_conv.cxx_type_name_global.snippet()}}), err_ptr}), true);
          jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'alias.CppBindObject']|map('replace', '.', pat_sep)|path_join}};)V");
          jobject excObj = env->NewObject(excCls, excConstructor, cppbindObj);
          env->Throw(jthrowable(excObj));
      }
      {%- endfor %}
      {%- endif %}
      {%- if not 'std::exception' in vars.throws %}
      catch (const std::exception& e) {
          jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
          jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
          env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
      }
      {%- endif %}
      catch (...) {
          jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
          jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
          env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
      }

      {% if rconverter.jni.target_type_name != 'void' -%}
      {{rconverter.jni.target_type_name}} result {};
      return result;
      {%- endif %}
      {%- endmacro %}
      {%- set file = path.splitext(path.basename(vars.file_fullname))[0] %}
      {%- set jni_name = helper.get_jni_func_name(vars.full_package, file[0]|upper + file[1:] + 'Kt', func_name) %}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}(JNIEnv* env, jclass{{', ' if args}}
      {%- set comma = joiner(', ') -%}
      {%- for arg in args -%}
      {{comma()}}{{arg.converter.jni.target_type_name}} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
      {%- endfor %}{{', ...' if args}}){
          {%- set call_args = [] %}
          {{args_snippet(args, call_args)|indent(4)}}
          {{call_code(call_args)|indent(4)}}
      }
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}


var_getter_kotlin_include: &var_getter_kotlin_include
  unique_content: |
    {%- macro gen_import(converter) -%}
    {%- if converter.kotlin.parent_type_info -%}
    {{gen_import(make_type_converter(converter.kotlin.parent_type_info.cxx.type_name))}}
    {%- elif converter.kotlin_include -%}
    {{marker}}{{converter.kotlin_include.snippet(full_package=vars.full_package)}}
    {%- endif -%}
    {%- for arg_converter in converter.kotlin.args_converters -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- endmacro -%}
    {{gen_import(rconverter)}}

var_getter_cxx_include: &var_getter_cxx_include
  unique_content: |
    {#- this should go to shared macro cxx_include -#}
    {%- macro gen_include(converter) -%}
    {%- if converter.cxx_include -%}
    {{marker}}{{converter.cxx_include.snippet()}}
    {%- endif -%}
    {%- if converter.kotlin -%}
    {%- for arg_converter in converter.kotlin.args_converters -%}
    {{gen_include(arg_converter)}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {{gen_include(rconverter)}}

var_getter_cxx_forward_decl: &var_getter_cxx_forward_decl
  unique_content: |
    {%- macro collect_fwd_decl_type_infos(type_info, fwd_decl_type_infos) -%}
    {#- Type comparison is done when the type has descendants. Forward decl is not needed when the object recover function is generated in the same file as current getter/setter. -#}
    {%- if type_info.vars and type_info.vars.descendants is defined and (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) and vars.c_file_fullname != type_info.vars.c_file_fullname -%}
    {%- do fwd_decl_type_infos.append(type_info) -%}
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
        {%- do collect_fwd_decl_type_infos(arg_type_info, fwd_decl_type_infos) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- set fwd_decl_type_infos = [] -%}
    {%- if setter is defined -%}
        {%- do collect_fwd_decl_type_infos(return_type_info, fwd_decl_type_infos) -%}
    {%- endif -%}
    {%- for fwd_decl_type_info in fwd_decl_type_infos -%}
    {%- set fwd_decl_type_converter = make_type_converter('std::shared_ptr<' + fwd_decl_type_info.cxx.type_name + '>' if fwd_decl_type_info.vars.shared_ref else fwd_decl_type_info.cxx.type_name) -%}
    {{marker}}{{fwd_decl_type_converter.cxx_obj_recover_func_decl.snippet(is_fwd_decl=True)}};
    {%- endfor -%}

property_getter:
  kotlin:
    include: *var_getter_kotlin_include
    properties: |
      {%- if not cxx.is_public -%}
        {%- do Error.critical("{}.{} is not a public field. Make it public or remove cppbind API.".format(owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- set owner_name = owner_class.converter.kotlin.target_type_name -%}
      {% set result_converter = rconverter.jdk_to_kotlin %}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {{'var' if vars.action == 'gen_property_setter' else 'val'}} {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}}
          get() {
              {%- if owner_class.vars.action == 'gen_interface' %}
              val result = {{owner_name}}Helper.j{{vars.name|capitalize}}(cppbindObjId)
              {%- else %}
              val result = j{{vars.name|capitalize}}(cppbindObjId)
              {%- endif %}
              {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(8)}}
              {%- if vars.return_value_policy == 'reference_internal' and rconverter.kotlin_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
              {%- set conversion = rconverter.kotlin_ref_internal.snippet(result_converter.converted_name('result'), reference='this', nullable=vars.nullable_return) -%}
              {%- if conversion %}
              {{conversion|indent(8)}}{% endif %}
              {%- endif %}
              return {{result_converter.converted_name('result')}}
          }
          {%- if vars.action == 'gen_property_setter' %}
          {%- set converter = rconverter.kotlin_to_jdk %}
          set(value) {
              {{converter.snippet('value', nullable=vars.nullable_return)|indent(8)}}
              {%- if owner_class.vars.action == 'gen_interface' %}
              {{owner_name}}Helper.jSet{{vars.name|lower}}(cppbindObjId, {{converter.converted_name('value')}}, value)
              {%- else %}
              jSet{{vars.name|lower}}(cppbindObjId, {{converter.converted_name('value')}}, value)
              {%- endif %}
              {#- This should go to shared macro -#}
              {%- if vars.keep_alive %}
              {%- set args = [namespace(name='value', converter=rconverter)] %}
              {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
              {%- if invalid_args  %}
              {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
              {%- endif %}
              {%- for arg_idx in vars.keep_alive %}
              {%- set converter = args[arg_idx - 1].converter %}
              {%- if converter.kotlin_keep_alive %}
              {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(8)}}
              {%- endif %}
              {%- endfor %}
              {%- endif %}
          }
          {% endif %}
    private_external: |
      {%- if owner_class.vars.action == 'gen_class' -%}
      private external fun j{{vars.name|capitalize}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if vars.action == 'gen_property_setter' %}
      private external fun jSet{{vars.name|lower}}(id: Long, value: {{rconverter.jdk.target_type_name}}, valueObj: Any?): Unit
      {%- endif %}
      {%- endif %}
    interface_external: |
      {%- if owner_class.vars.action == 'gen_interface' %}

      @JvmStatic
      external fun j{{vars.name|capitalize}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if vars.action == 'gen_property_setter' %}

      @JvmStatic
      external fun jSet{{vars.name|lower}}(id: Long, value: {{rconverter.jdk.target_type_name}}, valueObj: Any?): Unit
      {%- endif %}
      {%- endif %}
  cxx:
    include: *var_getter_cxx_include
    forward_decl: *var_getter_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {%- set parent_type_name = owner_class.converter.kotlin.target_type_name + 'Helper' if owner_class.vars.action == 'gen_interface' else owner_class.converter.kotlin.target_type_name %}
      {%- set func_name="j%s"|format(vars.name|capitalize) %}
      {%- set jni_name = helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}
      {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').jni_to_cxx if owner_class.vars.shared_ref else owner_class.converter.jni_to_cxx -%}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}([[maybe_unused]] JNIEnv* env, jobject, jobjectid id){
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          const auto& result = {{this_converter.converted_name('id')}}->{{cxx.name}};
          {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
          return {{rconverter.cxx_to_jni.converted_name('result')}};
      }
      {%- if vars.action == 'gen_property_setter' %}
      {% set func_name="jSet%s"|format(vars.name|lower) %}
      {%- set jni_name = helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}
      extern "C" JNIEXPORT void {{jni_name}}([[maybe_unused]] JNIEnv* env, jobject, jobjectid id, {{rconverter.jni.target_type_name}} value, ...){
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          {% set converter = rconverter.jni_to_cxx %}
          {{converter.snippet('value', nullable=vars.nullable_return)|indent(4)}}
          {{this_converter.converted_name('id')}}->{{cxx.name}} = {{converter.converted_name('value')}};
      }
      {% endif %}

getter:
  kotlin:
    include: *var_getter_kotlin_include
    properties: |
      {%- do helper.validate_getter(cxx, vars, args, owner_class, setter|default(none)) -%}
      {%- do helper.validate_template_getter_setter(cxx, vars, owner_class, setter|default(none)) -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set owner_name = owner_class.converter.kotlin.target_type_name -%}
      {% set result_converter = rconverter.jdk_to_kotlin %}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {{'open ' if cxx.is_open}}{{'override ' if cxx.is_override}}{{'var ' if setter is defined else 'val '}}
                                             {%- if cxx.is_template -%}
                                             {%- for name in template_args_postfixes or [] %}
                                             {%- if name != None %}{{name}}{% else %}{{template_type_converters[loop.index - 1].custom.tname}}{% endif %}
                                             {%- endfor %}
                                             {%- else %}{{vars.name}}
                                             {%- endif -%}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}}
          get() {
              {%- if owner_class.vars.action == 'gen_interface' %}
              val result = {{owner_name}}Helper.j{{vars.name|capitalize}}{{template_postfix}}(cppbindObjId)
              {%- else %}
              val result = j{{vars.name|capitalize}}{{template_postfix}}(cppbindObjId)
              {%- endif %}
              {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(8)}}
              {%- if vars.return_value_policy == 'reference_internal' and rconverter.kotlin_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
              {%- set conversion = rconverter.kotlin_ref_internal.snippet(result_converter.converted_name('result'), reference='this', nullable=vars.nullable_return) -%}
              {%- if conversion %}
              {{conversion|indent(8)}}{%- endif %}
              {%- endif %}
              return {{result_converter.converted_name('result')}}
          }
          {%- if setter is defined %}
          {%- set incorrect_nullable_args = setter.vars.nullable_arg|reject('in', setter.args|map(attribute='name'))|list -%}
          {%- if incorrect_nullable_args -%}
            {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), setter.owner_class.cxx.displayname, setter.cxx.displayname)) -%}
          {%- endif -%}
          {%- set converter = setter.args[0].converter.kotlin_to_jdk %}
          {%- if cxx.is_override %}
          set(value) {
              super.{{vars.name}} = value
          }
          {%- else %}
          set(value) {
              {{converter.snippet('value', nullable=vars.nullable_return)|indent(8)}}
              {%- if owner_class.vars.action == 'gen_interface' %}
              {{owner_name}}Helper.j{{setter.vars.name|capitalize}}{{template_postfix}}(cppbindObjId, {{converter.converted_name('value')}}, value)
              {%- else %}
              j{{setter.vars.name|capitalize}}{{template_postfix}}(cppbindObjId, {{converter.converted_name('value')}}, value)
              {%- endif %}
              {%- if setter.vars.keep_alive %}
              {%- set args = [namespace(name='value', converter=rconverter)] %}
              {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
              {%- if invalid_args  %}
              {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
              {%- endif %}
              {%- for arg_idx in vars.keep_alive %}
              {%- set converter = args[arg_idx - 1].converter %}
              {%- if converter.kotlin_keep_alive %}
              {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(8)}}
              {%- endif %}
              {%- endfor %}
              {%- endif %}
          }
          {%- endif %}
          {%- endif %}
    private_external: |
      {%- if owner_class.vars.action == 'gen_class' -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      private external fun j{{vars.name|capitalize}}{{template_postfix}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if setter is defined %}
      private external fun j{{setter.vars.name|capitalize}}{{template_postfix}}(id: Long, value: {{setter.args[0].converter.jdk.target_type_name}}, valueObj: Any?): Unit
      {%- endif %}
      {%- endif %}
    interface_external: |
      {%- if owner_class.vars.action == 'gen_interface' -%}
      {% set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      @JvmStatic
      external fun j{{vars.name|capitalize}}{{template_postfix}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if setter is defined %}

      @JvmStatic
      external fun j{{setter.vars.name|capitalize}}{{template_postfix}}(id: Long, value: {{setter.args[0].converter.jdk.target_type_name}}, valueObj: Any?): Unit
      {%- endif %}
      {%- endif %}
  cxx:
    include: *var_getter_cxx_include
    forward_decl: *var_getter_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {%- macro gen_exc_try_block(vars) -%}
      {%- if 'no_throw' not in vars.throws %}
      {%- for exc_type in vars.throws -%}
          catch (const {{exc_type}}& e) {
              err_ptr = new {{exc_type}}(e);
              {%- set exc_info = get_type_info(exc_type) %}
              {%- set exc_conv = make_type_converter(exc_type) %}
              jclass excCls = env->FindClass("{{[exc_info.vars.full_package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
              jclass cppbindObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'alias.CppBindObject']|map('replace', '.', pat_sep)|path_join}}");
              jmethodID cppbindConstructor = env->GetMethodID(cppbindObjClass, "<init>", "(JZ)V");
              jobject cppbindObj = env->NewObject(cppbindObjClass, cppbindConstructor, reinterpret_cast<jobjectid>(new CppBindCObject {strdup({{exc_conv.cxx_type_name_global.snippet()}}), err_ptr}), true);
              jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'alias.CppBindObject']|map('replace', '.', pat_sep)|path_join}};)V");
              jobject excObj = env->NewObject(excCls, excConstructor, cppbindObj);
              env->Throw(jthrowable(excObj));
          }
      {%- endfor %}
      {%- endif %}
      {%- if not 'std::exception' in vars.throws %}
          catch (const std::exception& e) {
              jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
          }
      {%- endif %}
          catch (...) {
              jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
          }
      {%- endmacro -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set func_name="j%s%s"|format(vars.name|capitalize, template_postfix) %}
      {%- if cxx.is_template -%}
      {%- set template_args = '<' + template_choice.values()|format_list("{type}", 'type')|join(', ') + '>' %}
      {%- else %}
      {%- set template_args = '' %}
      {%- endif %}
      {%- set parent_type_name = owner_class.converter.kotlin.target_type_name + 'Helper' if owner_class.vars.action == 'gen_interface' else owner_class.converter.kotlin.target_type_name %}
      {%- set jni_name = helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}
      {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').jni_to_cxx if owner_class.vars.shared_ref else owner_class.converter.jni_to_cxx %}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}([[maybe_unused]] JNIEnv* env, jobject, jobjectid id){
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          {%- if 'no_throw' not in vars.throws %}
          void* err_ptr = nullptr;
          {%- endif %}
          try {
              const auto& result = {{this_converter.converted_name('id')}}->{{cxx.name}}{{template_args}}();
              {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(8)}}
              return {{rconverter.cxx_to_jni.converted_name('result')}};
          }
          {{gen_exc_try_block(vars)}}

          {{rconverter.jni.target_type_name}} result {};
          return result;
      }
      {%- if setter is defined %}
      {% set func_name="j%s%s"|format(setter.vars.name|capitalize, template_postfix) %}
      {%- set jni_setter_name = helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}
      extern "C" JNIEXPORT void {{jni_setter_name}}([[maybe_unused]] JNIEnv* env, jobject, jobjectid id, {{setter.args[0].converter.jni.target_type_name}} {{setter.args[0].name}}, ...){
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          {%- set converter = setter.args[0].converter.jni_to_cxx %}
          {{converter.snippet(setter.args[0].name, nullable=vars.nullable_return)|indent(4)}}
          {%- if 'no_throw' not in setter.vars.throws %}
          void* err_ptr = nullptr;
          {%- endif %}
          try {
             {{this_converter.converted_name('id')}}->{{setter.cxx.name}}{{template_args}}({{converter.converted_name(setter.args[0].name)}});
          }
          {{gen_exc_try_block(setter.vars)}}
      }
      {% endif %}
