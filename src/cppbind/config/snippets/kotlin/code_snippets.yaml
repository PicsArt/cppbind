# Copyright (c) 2022 PicsArt, Inc.
# All rights reserved. Use of this source code is governed by a
# MIT-style license that can be found in the LICENSE file.

file:
  kotlin:
    file_path: |
      {{vars.file_fullname}}
    scopes:
      - body
      - include
      - glob_init
      - glob_external
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      package {{vars.full_package}}
      {% set helpers = helper_includes|unique_snippets|format_list('import {}.*') %}
      {%- set exc_vars = get_type_info("std::exception").vars %}
      {%- set exc_include = 'import ' + exc_vars.full_package + '.*' %}
      {{(helpers + [exc_include, include])|sort_snippets|join(new_line)}}
      {%- if glob_init %}
      {{glob_init}}
      {%- endif %}
      {%- if body %}
      {{body}}
      {%- endif %}
      {%- if glob_external %}

      {{glob_external}}
      {%- endif %}

      private external fun jGettypebyid(id: Long): String{{new_line}}
  cxx:
    file_path: |
      {{vars.c_file_fullname}}
    scopes:
      - body
      - include
      - glob_decl
      - glob_def
      - forward_decl
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include "jni.h"
      #include <iostream>
      #include <cxxabi.h>
      #include <string.h>
      #include <type_traits>
      {{cxx_helper_includes|format_list('#include "{}"')|join(new_line)}}
      {{include}}
      {%- if glob_decl %}

      {{glob_decl}}
      {%- endif %}
      {%- if glob_def %}

      {{glob_def}}
      {%- endif %}
      {%- if forward_decl %}

      {{forward_decl}}
      {%- endif %}

      {{body}}
      {% set file = path.splitext(path.basename(vars.file_fullname))[0] %}
      extern "C" JNIEXPORT jstring {{cppbind_helper.get_jni_func_name(vars.full_package, file[0]|upper + file[1:] + 'Kt', 'jGettypebyid')}}(JNIEnv* env, jclass, jobjectid id) {
          validateID(id);
          return env->NewStringUTF(reinterpret_cast<CppBindCObject*>(id)->type);
      }{{new_line}}

package:

enum:
  kotlin:
    body: |
      {%- if vars.header_code_fragment %}
      {{new_line}}{{vars.header_code_fragment}}
      {%- endif %}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      enum class {{vars.name}}(val value: Int){{': ' if vars.bases_list}}{{vars.bases_list|join(', ')}} {
      {%- set comma = joiner(",") -%}
      {%- for case in cxx.enum_cases -%}
      {%-   if case.name not in vars.enum_excluded_cases -%}
          {{comma()}}
      {%-     if case.comment %}
          {{case.comment|make_doxygen_comment|indent(4)}}
      {%-     endif %}
          {{vars.enum_case_names.get(case.name, vars.enum_case_name_prefix + case.name)}}({{case.value}})
      {%-   endif %}
      {%- endfor %};

          companion object {
              private val values = values()
              fun getByValue(value: Int) = values.firstOrNull { it.value == value }
          }
      {%- if vars.code_fragment %}

          {{vars.code_fragment|indent(4)}}
      {%- endif %}
      }
      {%- if vars.footer_code_fragment %}
      {{new_line}}{{vars.footer_code_fragment}}
      {%- endif %}

var_class_cxx_glob_decl: &var_class_cxx_glob_decl
    unique_content:
      !concat
      - !include common_macros.yaml&global_declarations.class
      - |
        {{gen_glob_decl()}}

var_class_cxx: &var_class_cxx
  include:
    unique_content:
      !concat
      - !include cxx_macros.yaml&includes
      - !include common_macros.yaml&includes.cxx
      - |
        {%- set includes = [] -%}
        {%- set converter = get_type_converter(cxx.type) -%}
        {%- do collect_includes(converter, includes) -%}
        {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
        {%- for base in base_types_converters -%}
        {%-   do collect_includes(base, includes) -%}
        {%- endfor -%}
        {%- do collect_desc_includes(converter, includes) -%}
        {%- if includes -%}
        {{includes|join(marker)}}
        {%- endif -%}
        {%- set includes = gen_user_defined_cxx_includes(vars) -%}
        {%- if includes -%}{{includes}}{%- endif -%}
  glob_decl: *var_class_cxx_glob_decl
  glob_def:
    unique_content: |
      {%- set converter = get_type_converter(cxx.type) -%}
      const char* {{converter.cxx_type_name_global.snippet()}} = "{{cxx.type_name}}";
  body:
    scopes:
      - body
    content:
      !concat
      - !include kotlin_macros.yaml&jni_functions
      - |
        {%- set converter = get_type_converter(cxx.type) %}
        {%- set descendants = vars.descendants if vars.descendants is not none else descendants %}
        {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
        {%- set is_root_class = base_types_converters|rejectattr('type_info.vars.action', 'equalto', 'gen_interface')|list|length == 0 %}
        {%- set parent_type_name = converter.kotlin.get_target_type_name(interface_class=vars.action == 'gen_interface') %}
        {%- if is_root_class %}
        {%-   set finalize_name = cppbind_helper.get_jni_func_name(vars.full_package, parent_type_name, 'jFinalize') %}
        extern "C" JNIEXPORT void {{finalize_name}}(JNIEnv*, jobject, jobjectid id){
        {%- if cxx.namespace %}
            using namespace {{cxx.namespace}};
        {%- endif %}
        {%-   if not vars.shared_ref and cxx.is_polymorphic and (vars.descendants if vars.descendants is not none else descendants) %}
            static_assert(std::has_virtual_destructor<{{cxx.type_name}}>::value, {{'"{} type must have virtual destructor"'.format(cxx.type_name)}});
        {%-   endif %}
            auto cppbind_obj_id = reinterpret_cast<CppBindCObject*>(id);
            auto cppbind_obj_id_ptr = cppbind_obj_id ? cppbind_obj_id->ptr : nullptr;
        {#- here is used almost the same logic as for jni_to_cxx section of Object/std::shared_ptr type converter (instead of constructing target value we delete it here) -#}
        {%-   if descendants %}
            if (strcmp(cppbind_obj_id->type, {{converter.cxx_type_name_global.snippet()}}) == 0)
        {%-     if vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{cxx.type_name}}>*>(cppbind_obj_id_ptr);
        {%-     else %}
                delete static_cast<{{cxx.type_name}}*>(cppbind_obj_id_ptr);
        {%-     endif %}
        {%-     for descendant in descendants %}
            else if (strcmp(cppbind_obj_id->type, {{get_type_converter(descendant).cxx_type_name_global.snippet()}}) == 0)
        {%-       if vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{descendant}}>*>(cppbind_obj_id_ptr);
        {%-       else %}
                delete static_cast<{{descendant}}*>(cppbind_obj_id_ptr);
        {%-       endif %}
        {%-     endfor %}
            else {
                std::cerr << "Unexpected object type: " << cppbind_obj_id->type << std::endl;
                exit(1);
            }
        {%-   else %}
        {%-     if vars.shared_ref %}
            delete static_cast<std::shared_ptr<{{cxx.type_name}}>*>(cppbind_obj_id_ptr);
        {%-     else %}
            delete static_cast<{{cxx.type_name}}*>(cppbind_obj_id_ptr);
        {%-     endif %}
        {%-   endif %}
            free(cppbind_obj_id->type);
            delete cppbind_obj_id;
        }
        {%- endif %}
        {#- object recover function is generated for all classes (not only for bases with reusing them for derived types) since the performance would be lowered in case of superbases with deep hierarchy -#}
        {%- if descendants %}
        {%-   set this_converter = get_type_converter('std::shared_ptr<' + cxx.type_name + '>') if vars.shared_ref else converter %}

        {{this_converter.cxx_obj_recover_func_decl.snippet(name="id")}} {
            {{this_converter.cxx_obj_recover.snippet(name="id")|indent(4)}}
        }
        {%- endif -%}
        {%- if is_root_class %}

        {{gen_jni_cxxid_function()}}
        {%- endif %}
        {{body}}

var_class_kotlin_include: &var_class_kotlin_include
  unique_content:
    !concat
    - !include common_macros.yaml&includes.target_language
    - |
      {{marker if vars.include}}{{vars.include|format_list("import {}")|join_unique}}
      {%- set import_converters = [] -%}
      {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
      {%- for base in base_types_converters -%}
      {%-   do collect_import_converters(base, import_converters) -%}
      {%- endfor -%}
      {%- set desc_import_converters = [] -%}
      {%- do collect_desc_import_converters(get_type_converter(cxx.type), desc_import_converters) -%}
      {%- for import_converter, _ in import_converters -%}
      {%-   if import_converter.kotlin_include is defined -%}
      {{marker}}{{import_converter.kotlin_include.snippet(full_package=vars.full_package)}}
      {%-   endif -%}
      {%- endfor -%}
      {%- for desc_import_converter, gen_for_impl in desc_import_converters -%}
      {#- we need to import implementation classes for object construction (`gen_for_impl` is for tracking nested types) -#}
      {%-   if desc_import_converter.kotlin_include is defined -%}
      {{marker}}{{desc_import_converter.kotlin_include.snippet(interface_class=(gen_for_impl and desc_import_converter.type_info.vars.action=='gen_interface'), full_package=vars.full_package)}}
      {%-   endif -%}
      {%- endfor -%}

class:
  kotlin:
    include: *var_class_kotlin_include
    body:
      scopes:
        - head
        - properties
        - body
        - companion
        - private_external
      content:
        !concat
        - !include kotlin_macros.yaml&special_functions.class
        - |
          {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
          {%-   do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
          {%- endif -%}
          {%- if vars.header_code_fragment -%}
          {{new_line}}{{vars.header_code_fragment}}
          {% endif -%}
          {%- set converter = get_type_converter(cxx.type) %}
          {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
          {%- set base_interfaces = base_types_converters|selectattr('type_info.vars.action', 'eq', 'gen_interface')|map(attribute='kotlin.target_type_name')|list -%}
          {%- set is_root_class = base_interfaces|length == base_types_converters|length %}
          {%- set ancestor_infos = cxx.ancestors|type_info(error=False)|reject('none')|selectattr('has_api')|list %}
          {%- set bases_specifiers = base_interfaces + base_types_converters|map(attribute='kotlin.target_type_name')|reject('in', base_interfaces)|format_list('{}(obj)') + vars.bases_list + (['AutoCloseable'] if not base_types_converters or is_root_class else []) + (['Exception()'] if vars.is_exception and not ancestor_infos|selectattr('vars.is_exception', 'equalto', True)|list else []) -%}
          {%- if base_types_converters|rejectattr('type_info.vars.action', 'equalto', 'gen_interface')|list|length > 1 %}
          {%-   do Error.critical(cxx.type_name + ' has more than 1 non abstract base type.') %}
          {%- endif %}
          {%- if ancestor_infos|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
          {%-   do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
          {%- endif %}
          {%- if vars.comment %}
          {{vars.comment|make_doxygen_comment}}
          {%- endif %}
          {{'open ' if cxx.is_open}}class {{converter.kotlin.get_target_type_name(definition=True)}}
          internal constructor(obj: CppBindObject){{' : ' + bases_specifiers|join(', ') if bases_specifiers}} {
              companion object {
          {%- if vars.c_wrapper_lib_name and is_root_class %}
                  init {
                      System.loadLibrary("{{vars.c_wrapper_lib_name}}")
                  }
          {%- endif %}
                  {{companion|string|indent(8)}}
                  /**
                   * An internal property to keep an information about the underlying C++ object type.
                   * It is intended to be used by the generated code.
                   */
                  const val cppbindCxxTypeName: String = "{{cxx.type_name}}"
                  {%- if (vars.descendants if vars.descendants is not none else descendants) and cxx.is_polymorphic %}

                  /**
                   * An internal method to create a Kotlin object from a C++ object.
                   * It is intended to be used by the generated code.
                   */
                  public fun cppbindConstructObject(id: Long, owner: Boolean = false): {{converter.kotlin.target_type_name}} {
                      {{converter.kotlin_obj_construction.snippet(name="id")|indent(12)}}
                  }
          {%- endif %}
              }
              {% if is_root_class %}
              protected var cppbindObj = obj
              private var refs: MutableList<Any> = mutableListOf()

              /**
               * An internal method to bind the lifetimes of the current and another object.
               * It is intended to be used by the generated code.
               */
              {{'override ' if base_types_converters}}fun keepCppBindReference(ref: Any) {
                  refs.add(ref)
              }
          {%- endif %}
          {%- if base_types_converters|selectattr('type_info.vars.action', 'equalto', 'gen_interface')|list or not base_types_converters %}
              /**
               * An internal getter to get the id of an object.
               * It is intended to be used by the generated code.
               */
          {%- if base_types_converters %}
              {{'override '}}
          {%- else %}
              {{'open '}}
          {%- endif -%}
              val cppbindObjId: Long
                  get() {
                      if (cppbindObj.id == 0L) {
                          throw RuntimeException("Object is not allocated")
                      }
                      return cppbindObj.id
                  }
          {%- endif -%}
          {%- if is_root_class %}

              /**
               * An internal property returning underlying C++ object id.
               * It is intended to be used by the generated code.
               */
              internal val cxxId: Long by lazy {
                  jGetcxxid(cppbindObj.id)
              }

              /**
               * An internal property returning underlying C++ type name.
               * It is intended to be used by the generated code.
               */
              internal val cxxTypeName: String by lazy {
                  jGettypebyid(cppbindObj.id)
              }
          {%- endif %}
          {%- if head %}
              {{head|string|indent}}
          {%- endif %}
          {%- if properties %}
              {{properties|string|indent}}
          {%- endif %}
          {%- if body %}
              {{body|string|indent}}
          {%- endif %}
          {%- if is_root_class %}
          {%-   if hash_decl not in body|string %}

              {{gen_default_hash_function()|indent(4)}}
          {%-   endif %}
          {%-   if equals_decl not in body|string %}

              {{gen_default_equals_function()|indent(4)}}
          {%-   endif %}
          {%-   if tostring_decl not in body|string %}

              {{gen_default_tostring_function()|indent(4)}}
          {%-   endif %}

              override fun close() {
                  if (cppbindObj.owner && cppbindObj.id != 0L) {
                      jFinalize(cppbindObj.id)
                      cppbindObj.id = 0L
                  }
              }

              /**
               * Finalize and deletes the object
               */
              protected fun finalize() {
                  close()
              }
          {%- endif %}
          {%- if private_external or is_root_class %}

              ///// External wrapper functions ////////////
          {%- endif %}
          {%- if private_external %}
              {{private_external|string|indent}}
          {%- endif %}
          {%- if is_root_class %}
              private external fun jFinalize(id: Long): Unit
              private external fun jGetcxxid(id: Long): Long
          {%- endif %}
          }
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {% endif -%}
  cxx: *var_class_cxx

interface:
  kotlin:
    include: *var_class_kotlin_include
    body:
      scopes:
        - head
        - properties
        - body
        - companion
        - interface_external
      content:
        !concat
        - !include kotlin_macros.yaml&special_functions.class
        - |
          {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
          {%-   do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
          {%- endif -%}
          {%- if vars.header_code_fragment -%}
          {{new_line}}{{vars.header_code_fragment}}
          {% endif -%}
          {%- set converter = get_type_converter(cxx.type) %}
          {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
          {%- set bases_specifiers = base_types_converters|map(attribute='kotlin.target_type_name')|list + vars.bases_list %}
          {%- if base_types_converters|rejectattr('type_info.vars.action', 'equalto', 'gen_interface')|list %}
          {%-   do Error.critical(cxx.type_name + ' interface cannot inherit from a class.') %}
          {%- endif %}
          {%- set ancestor_infos = cxx.ancestors|type_info(error=False)|reject('none')|selectattr('has_api')|list %}
          {%- if ancestor_infos|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
          {%-   do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
          {%- endif %}
          {% if vars.comment %}
          {{vars.comment|make_doxygen_comment}}
          {%- endif %}
          interface {{converter.kotlin.get_target_type_name(definition=True)}}{{' : ' + bases_specifiers|join(', ') if bases_specifiers else ' : AutoCloseable'}} {
          {%- if not base_types_converters %}
              /**
               * An internal getter to get the id of an object.
               * It is intended to be used by the generated code.
               */
              val cppbindObjId: Long
              /**
               * An internal method to bind the lifetimes of the current and another object.
               * It is intended to be used by the generated code.
               */
              fun keepCppBindReference(ref: Any)
          {%- endif %}
              {{properties|string|indent}}
              {{body|string|indent}}
          {%- if (vars.descendants if vars.descendants is not none else descendants) and cxx.is_polymorphic %}

              companion object {
                  /**
                   * An internal method to create a Kotlin object from a C++ object.
                   * It is intended to be used by the generated code.
                   */
                  public fun cppbindConstructObject(id: Long, owner: Boolean = false): {{converter.kotlin.target_type_name}} {
                      {{converter.kotlin_obj_construction.snippet(name="id")|indent(12)}}
                  }
              }
          {%- endif %}
          }

          {% if interface_external %}
          class {{converter.kotlin.get_target_type_name(definition=True)}}Helper {
              companion object {
                  {{interface_external|string|indent(8)}}
              }
          }
          {% endif %}

          {{'open ' if cxx.is_open}}class {{converter.kotlin.get_target_type_name(interface_class=True, definition=True)}}
          internal constructor(obj : CppBindObject) : {{converter.kotlin.target_type_name}} {
              companion object {
          {%- if vars.c_wrapper_lib_name %}
                  init {
                      System.loadLibrary("{{vars.c_wrapper_lib_name}}")
                  }
          {%- endif %}
                  {{companion|string|indent(8)}}
                  /**
                   * An internal property to keep an information about the underlying C++ object type.
                   * It is intended to be used by the generated code.
                   */
                  const val cppbindCxxTypeName: String = "{{cxx.type_name}}"
              }

              protected var cppbindObj = obj
              private var refs: MutableList<Any> = mutableListOf()

              override fun keepCppBindReference(ref: Any) {
                  refs.add(ref)
              }

              override val cppbindObjId: Long
                  get() {
                      if (cppbindObj.id == 0L) {
                          throw RuntimeException("Object is not allocated")
                      }
                      return cppbindObj.id
                  }

              /**
               * An internal property returning underlying C++ object id.
               * It is intended to be used by the generated code.
               */
              internal val cxxId: Long by lazy {
                  jGetcxxid(cppbindObj.id)
              }

              /**
               * An internal property returning underlying C++ type name.
               * It is intended to be used by the generated code.
               */
              internal val cxxTypeName: String by lazy {
                  jGettypebyid(cppbindObj.id)
              }
          {%- if head %}
              {{head|string|indent}}
          {%- endif %}
          {%- if not base_types_converters|rejectattr('type_info.vars.action', 'equalto', 'gen_interface')|list %}

              override fun close() {
                  if (cppbindObj.owner && cppbindObj.id != 0L) {
                      jFinalize(cppbindObj.id)
                      cppbindObj.id = 0L
                  }
              }

              /**
              * Finalize and deletes the object
              */
              protected fun finalize() {
                  close()
              }
          {% endif %}
              {{gen_default_hash_function()|indent(4)}}

              {{gen_default_equals_function(True)|indent(4)}}

              {{gen_default_tostring_function()|indent(4)}}

              ///// External wrapper functions ////////////
              private external fun jFinalize(id: Long): Unit
              private external fun jGetcxxid(id: Long): Long
          }
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {% endif -%}
  cxx: *var_class_cxx


var_method_kotlin_include: &var_method_kotlin_include
  unique_content:
    !concat
    - !include kotlin_macros.yaml&includes.kotlin
    - |
      {%- for arg_converter in cxx.args|type_converter(attribute='type') -%}
      {{gen_import(arg_converter)}}
      {%- endfor -%}
      {%- if cxx.result_type -%}
      {{gen_import(get_type_converter(cxx.result_type))}}
      {%- endif -%}

var_method_cxx_include: &var_method_cxx_include
  unique_content:
    !concat
    - !include cxx_macros.yaml&includes
    - !include common_macros.yaml&includes.cxx
    - |
      {%- if vars.is_proj_type -%}
      {{marker}}#include "{{vars.prj_rel_file_name}}"
      {%- endif -%}
      {%- for arg in cxx.args -%}
      {{gen_include(get_type_converter(arg.type))}}
      {%- endfor -%}
      {%- if cxx.result_type -%}
      {{gen_include(get_type_converter(cxx.result_type))}}
      {%- endif -%}
      {%- set includes = gen_user_defined_cxx_includes(vars) -%}
      {%- if includes -%}{{includes}}{%- endif -%}

var_method_cxx_forward_decl: &var_method_cxx_forward_decl
  unique_content:
    !concat
    - !include common_macros.yaml&forward_declarations.method
    - |
      {{gen_fwd_decl()}}

var_method_cxx_glob_decl: &var_method_cxx_glob_decl
  unique_content:
    !concat
    - !include common_macros.yaml&global_declarations.method
    - |
      {{gen_glob_decl()}}

constructor:
  kotlin:
    include: *var_method_kotlin_include
    head: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', cxx.args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%-   do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), cxx.parent.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {#- this should go to shared macro #}
      {%- macro gen_func(args, target_overloading_index=none) -%}
      {%-   if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%-   endif %}
      {%- set comma = joiner(', ') %}
      constructor({%- for arg in args -%}
      {%- set arg_converter = get_type_converter(arg.type) -%}
      {%- set arg_type_info = get_type_info(arg.type) -%}
      {{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg_converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
      {%-     if arg.default -%}
      {%-       if arg.type.is_enum %}
      {%-         set enum_case_name = arg.default.split('::')|last %}
      {%-         if enum_case_name in arg_type_info.vars.enum_excluded_cases -%}
      {%-           do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} constructor argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.parent.displayname, cxx.displayname)) -%}
      {%-         else %} = {{arg_converter.kotlin.target_type_name}}.{{arg_type_info.vars.enum_case_names.get(enum_case_name, arg_type_info.vars.enum_case_name_prefix + enum_case_name)}}
      {%-         endif -%}
      {%-       else -%}
      {%-         if arg.default_is_literal %} = {{arg.default}}{{'F' if arg.type.is_float}}{{'L' if arg.type.is_long}}{{'u' if arg.type.is_uchar}}
      {%-         elif arg.default_is_nullptr %} = null
      {%-         endif %}
      {%-       endif %}
      {%-     endif -%}
      {%-   endfor -%}): this(CppBindObject(constructHelper({{args|join(', ', attribute='name')}}), true)) {
      {#-   This should go to shared macro -#}
      {%-   if vars.keep_alive %}
      {%-     set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%-     if invalid_args  %}
      {%-       do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
      {%-     endif %}
      {%-     for arg_idx in vars.keep_alive %}
      {%-       set converter = get_type_converter(args[arg_idx - 1].type) %}
      {%-       if converter.kotlin_keep_alive %}
          {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
      {%-       endif %}
      {%-     endfor %}
      {%-   endif %}
      }
      {%- endmacro -%}
      {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(cxx.args)}}
    companion:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - !include kotlin_macros.yaml&constructor
      - |
        {#- this should go to shared macro #}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   if vars.comment %}
        {{vars.comment|make_doxygen_comment}}
        {%-   endif %}
        {%-   set comma = joiner(', ') %}
        protected fun constructHelper({%- for arg in args -%}
        {{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{get_type_converter(arg.type).kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{%- endfor-%}): Long {
        {%-   set call_args = [] %}
        {%-   for arg in args %}
        {%-     set converter = get_type_converter(arg.type).kotlin_to_jdk %}
        {%-     set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
        {%-     set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-     if conversion %}
            {{conversion|indent}}
        {%-     endif %}
        {%-     do call_args.append(converter.converted_name(arg_name)) %}
        {%-   endfor %}
        {#-   extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
        {%-   for arg in args %}
        {%-     set arg_name = vars.argument_name.get(arg.name, arg.name) %}
        {%-     do call_args.append(arg_name) if not arg_name in call_args %}
        {%-   endfor %}
            val id = {{constructor_jvm_name}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}({{call_args|join(', ')}})
            return id
        }
        {%    set comma = joiner(', ') %}
        @JvmStatic
        private external fun {{constructor_jvm_name}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}({%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{get_type_converter(arg.type).jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): Long
        {%- endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(cxx.args)}}
  cxx:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - !include kotlin_macros.yaml&constructor
      - |
        {#- this should go to shared macro #}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {%-   set parent_class_info = parent_class_converter.type_info -%}
        {%-   set parent_type_name = parent_class_converter.kotlin.get_target_type_name(interface_class=parent_class_info.vars.action == 'gen_interface') %}
        extern "C" JNIEXPORT jobjectid {{get_constructor_jni_name(target_overloading_index)}}([[maybe_unused]] JNIEnv* env, jobject{{', ' if args}}
        {%-   set comma = joiner(', ') -%}
        {%    for arg in args -%}
        {{comma()}}{{get_type_converter(arg.type).jni.target_type_name}} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
        {%-   endfor %}{{', ...' if args}}){
        {%-   if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%-   endif %}
        {%-   set call_args = [] -%}
        {%-   for arg in args -%}
        {%-     set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%      set converter = get_type_converter(arg.type).jni_to_cxx %}
            {{converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr)|indent(4)}}
        {%-     do call_args.append(converter.converted_name(arg_name)) -%}
        {%-   endfor %}
        {%-   if 'no_throw' not in vars.throws %}
            void* err_ptr = nullptr;
        {%-   endif %}
            try {
        {%-   if cxx.kind_name in ('constructor',  'constructor_template') %}
                {{cxx.parent.type_name}}* this_object = new {{cxx.parent.type_name}}({{call_args|join(', ')}});
        {%-   else %}
                auto this_object = {{cxx.parent.type_name}}::{{cxx.name}}({{call_args|join(', ')}});
        {%-   endif %}
        {%-   if not parent_class_info.vars.shared_ref %}
                return reinterpret_cast<jlong>(new CppBindCObject {strdup({{parent_class_converter.cxx_type_name_global.snippet()}}), this_object});
        {%-   else %}
                return reinterpret_cast<jlong>(new CppBindCObject {strdup({{parent_class_converter.cxx_type_name_global.snippet()}}), new std::shared_ptr<{{cxx.parent.type_name}}>(this_object)});
        {%-   endif %}
            }
        {%-   if 'no_throw' not in vars.throws %}
        {%-     for exc_type in vars.throws -%}
            catch (const {{exc_type}}& e) {
                err_ptr = new {{exc_type}}(e);
        {%-       set exc_info = get_type_info(exc_type) %}
        {%-       set exc_conv = get_type_converter(exc_type) %}
                jclass excCls = env->FindClass("{{[exc_info.vars.full_package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
                jclass cppbindObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'CppBindObject']|map('replace', '.', pat_sep)|path_join}}");
                jmethodID cppbindConstructor = env->GetMethodID(cppbindObjClass, "<init>", "(JZ)V");
                jobject cppbindObj = env->NewObject(cppbindObjClass, cppbindConstructor, reinterpret_cast<jobjectid>(new CppBindCObject {strdup({{exc_conv.cxx_type_name_global.snippet()}}), err_ptr}), true);
                jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'CppBindObject']|map('replace', '.', pat_sep)|path_join}};)V");
                jobject excObj = env->NewObject(excCls, excConstructor, cppbindObj);
                env->Throw(jthrowable(excObj));
            }
        {%-     endfor %}
        {%-   endif %}
        {%-   if not 'std::exception' in vars.throws %}
            catch (const std::exception& e) {
                jclass handlerCls = env->FindClass({{"\"{}/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
                jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
                env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
            }
        {%-   endif %}
            catch (...) {
                jclass handlerCls = env->FindClass({{"\"{}/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
                jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
                env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
            }
            jobjectid result {};
            return result;
        }
        {%- endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(cxx.args)}}

method:
  kotlin:
    include: *var_method_kotlin_include
    body:
      !concat
      - !include common_macros.yaml&utils
      - !include kotlin_macros.yaml&validations
      - !include kotlin_macros.yaml&special_functions.method
      - !include common_macros.yaml&templates
      - !include kotlin_macros.yaml&templates
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- set parent_class_info = get_type_info(cxx.parent.type) -%}
        {%- do run_method_validations() -%}
        {%- if cxx.name == vars.hash_method -%}
        {{gen_hash_function()}}
        {%- elif cxx.name == vars.equals_method or (vars.name == "equals" and vars.is_operator) -%}
        {{gen_equals_function()}}
        {%- elif cxx.name == vars.tostring_method -%}
        {{gen_tostring_function()}}
        {%- else -%}
        {%-   if not cxx.is_static %}
        {#-     this should go to shared macro #}
        {%-     macro gen_func(args, target_overloading_index=none) -%}
        {%-       set comma = joiner(', ') -%}
        {%-       if vars.comment %}
        {{vars.comment|make_doxygen_comment}}
        {%-       endif %}
        {%-       set jvm_name = get_jvm_name(args) %}
        {%-       if jvm_name %}
        {{jvm_name}}
        {%-       endif %}
        {{'open ' if cxx.is_open}}{{'operator ' if vars.is_operator}}{{gen_override_keyword(cxx, vars)}}fun {{vars.name}}(
        {%-       for arg in args -%}
        {%-         set arg_converter = get_type_converter(arg.type) -%}
        {%-         set arg_type_info = get_type_info(arg.type) -%}
        {{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg_converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
        {%-         if arg.default -%}
        {%-           if arg.type.is_enum %}
        {%-             set enum_case_name = arg.default.split('::')|last %}
        {%-             if enum_case_name in arg_type_info.vars.enum_excluded_cases -%}
        {%-               do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.parent.displayname, cxx.displayname)) -%}
        {%-             else %} = {{arg_converter.kotlin.target_type_name}}.{{arg_type_info.vars.enum_case_names.get(enum_case_name, arg_type_info.vars.enum_case_name_prefix + enum_case_name)}}
        {%-             endif -%}
        {%-           else -%}
        {%-             if arg.default_is_literal %} = {{arg.default}}{{'F' if arg.type.is_float}}{{'L' if arg.type.is_long}}{{'u' if arg.type.is_uchar}}
        {%-             elif arg.default_is_nullptr %} = null
        {%-             endif %}
        {%-           endif %}
        {%-         endif -%}
        {%-       endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if vars.nullable_return}} {
        {%-       set call_args = ['cppbindObjId'] -%}
        {%-       set result_converter = rconverter.jdk_to_kotlin -%}
        {%-       for arg in args %}
        {%-         set converter = get_type_converter(arg.type).kotlin_to_jdk -%}
        {%-         set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
        {%-         set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) -%}
        {%-         if conversion %}
            {{conversion|indent}}
        {%-         endif %}
        {%-         do call_args.append(converter.converted_name(arg_name)) %}
        {%-       endfor %}
        {#-       extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
        {%-       for arg in args %}
        {%-         set arg_name = vars.argument_name.get(arg.name, arg.name) %}
        {%-         do call_args.append(arg_name) if not arg_name in call_args %}
        {%-       endfor %}
        {%-       if parent_class_info.vars.action == 'gen_interface' %}
            val result = {{get_type_converter(cxx.parent.type).kotlin.target_type_name}}Helper.j{{vars.name|capitalize}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}({{call_args|join(', ')}})
        {%-       else %}
            val result = j{{vars.name|capitalize}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}({{call_args|join(', ')}})
        {%-       endif %}
            {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
        {%-       if vars.keep_alive and not (vars.is_operator and vars.name == 'get') %}
        {%-         set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
        {%-         if invalid_args  %}
        {%-           do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
        {%-         endif %}
        {%-         for arg_idx in vars.keep_alive %}
        {%-           set converter = get_type_converter(args[arg_idx - 1].type) %}
        {%-           if converter.kotlin_keep_alive %}
            {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
        {%-           endif %}
        {%-         endfor %}
        {%-       endif %}
        {%-       set result_is_shared = rconverter.type_info.vars.shared_ref|default(False) %}
        {%-       if not result_is_shared and vars.return_value_policy == 'reference_internal' and rconverter.kotlin_ref_internal is defined and (cxx.result_type.is_lval_reference or cxx.result_type.is_pointer) %}
        {%-         set conversion = rconverter.kotlin_ref_internal.snippet(result_converter.converted_name('result'), reference='this', nullable=vars.nullable_return) -%}
        {%-         if conversion %}
            {{conversion|indent(4)}}{% endif %}
        {%-         endif %}
            return {{result_converter.converted_name('result')}}
        }
        {%-     endmacro -%}
        {%-     set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%-     for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {%      endfor -%}{{gen_func(cxx.args)}}


        {%-     if vars.is_operator and vars.name == 'get' and not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference %}
        {%        set setter_var_name = 'value' %}

        {{'open ' if cxx.is_open}}{{'operator ' if vars.is_operator}}{{gen_override_keyword(cxx, vars)}}fun set(
        {%-       for arg in cxx.args -%}
        {%-         set arg_converter = get_type_converter(arg.type) -%}
        {{vars.argument_name.get(arg.name, arg.name)}}: {{arg_converter.kotlin.target_type_name}}, {{setter_var_name}}: {{rconverter.kotlin.target_type_name}}
        {%-       endfor-%}){
        {%-       set call_args = ['cppbindObjId'] -%}
        {%-       for arg in cxx.args %}
        {%-         set converter = get_type_converter(arg.type).kotlin_to_jdk -%}
        {%-         set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
        {%-         set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) -%}
        {%-         if conversion %}
            {{conversion|indent}}
        {%-         endif %}
        {%-         do call_args.append(converter.converted_name(arg_name)) %}
        {%-       endfor %}
        {#-       extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
        {%-       set extra_call_args = [] -%}
        {%-       for arg in cxx.args %}
        {%-         set arg_name = vars.argument_name.get(arg.name, arg.name) %}
        {%-         do extra_call_args.append(arg_name) if not arg_name in call_args %}
        {%-       endfor %}
        {%-       if parent_class_info.vars.action == 'gen_interface' %}
            {{get_type_converter(cxx.parent.type).kotlin.target_type_name}}Helper.jSet{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}({{call_args|join(', ')}}, {{setter_var_name}})
        {%-       else %}
            jSet{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}({{call_args|join(', ')}}, {{setter_var_name}})
        {#-       This should go to shared macro -#}
        {%-       if vars.keep_alive %}
        {%-         set args = cxx.args + [namespace(name='value', converter=rconverter)] -%}
        {%-         set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
        {%-         if invalid_args  %}
        {%-           do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
        {%-         endif %}
        {%-         for arg_idx in vars.keep_alive %}
        {%-           set converter = get_type_converter(args[arg_idx - 1].type) %}
        {%-           if converter.kotlin_keep_alive %}
            {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
        {%-           endif %}
        {%-         endfor %}
        {%-       endif %}
        {%-   endif %}
        }

        {%- endif %}

        {%- endif %}
        {%- endif %}
    companion:
      !concat
      - !include common_macros.yaml&templates
      - !include kotlin_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- if cxx.is_static %}
        {#-   this should go to shared macro #}
        {%-   macro gen_func(args, target_overloading_index=none) -%}
        {%-     if vars.return_value_policy == 'reference_internal' -%}
        {%        do Error.critical("Cannot apply reference internal policy on a static method's return value: {}::{}".format(cxx.parent.type_name, cxx.name)) -%}
        {%-     endif -%}
        {#-     This should go to shared macro -#}
        {%-     if vars.keep_alive %}
        {%-       do Error.critical('Cannot apply keep alive policy for a static member function: {}.{}'.format(cxx.name, cxx.parent.type_name)) -%}
        {%-     endif %}
        {%-     set comma = joiner(', ') -%}
        {%-     if vars.comment %}
        {{vars.comment|make_doxygen_comment}}
        {%-     endif %}
        {%-     set jvm_name = get_jvm_name(args) %}
        {%-     if jvm_name %}
        {{jvm_name}}
        {%-     endif %}
        fun {{vars.name}}({%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{get_type_converter(arg.type).kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{%- endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if vars.nullable_return}} {
        {%-     set call_args = [] %}
        {%-     set result_converter = rconverter.jdk_to_kotlin -%}
        {%-     for arg in args -%}
        {%-       set converter = get_type_converter(arg.type).kotlin_to_jdk -%}
        {%-       set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
        {%-       set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) -%}
        {%-       if conversion %}
            {{conversion|indent}}
        {%-       endif %}
        {%-       do call_args.append(converter.converted_name(arg_name)) %}
        {%-     endfor %}
        {#-     extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
        {%-     for arg in args %}
        {%-       set arg_name = vars.argument_name.get(arg.name, arg.name) %}
        {%-       do call_args.append(arg_name) if not arg_name in call_args %}
        {%-     endfor %}
        {%-     if get_type_info(cxx.parent.type).vars.action == 'gen_interface' %}
            val result = {{get_type_converter(cxx.parent.type).kotlin.target_type_name}}Helper.j{{vars.name|capitalize}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}({{call_args|join(', ')}})
        {%-     else %}
            val result = j{{vars.name|capitalize}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}({{call_args|join(', ')}})
        {%-     endif %}
            {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent}}
            return {{result_converter.converted_name('result')}}
        }
        {%- set comma = joiner(', ') %}
        @JvmStatic
        private external fun j{{vars.name|capitalize}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}({%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{get_type_converter(arg.type).jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): {{rconverter.jdk.target_type_name}}
        {%-   endmacro -%}
        {%-   set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%-   for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {%    endfor -%}{{gen_func(cxx.args)}}
        {%- endif %}
    private_external:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- if get_type_info(cxx.parent.type).vars.action == 'gen_class' -%}
        {%-   if not cxx.is_static %}
        {#-     this should go to shared macro #}
        {%-     macro gen_func(args, target_overloading_index=none) -%}
        {%-       set comma = joiner(', ') -%}
        private external fun j{{vars.name|capitalize}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{get_type_converter(arg.type).jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): {{rconverter.jdk.target_type_name}}
        {%-     endmacro -%}
        {%-     set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%-     for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {%      endfor -%}{{gen_func(cxx.args)}}
        {%-     if vars.is_operator and vars.name == 'get' and not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference %}
        {%-       set comma = joiner(', ') -%}
        {%-       set setter_var_name = 'value' %}
        private external fun jSet{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}(id: Long{{', ' if cxx.args}}{%- for arg in cxx.args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{get_type_converter(arg.type).jdk.target_type_name}}{%- endfor-%}, {{setter_var_name}}: {{rconverter.kotlin.target_type_name}}{{', vararg extraObjs: Any?' if cxx.args}})
        {%-     endif %}
        {%-   endif %}
        {%- endif -%}
    interface_external:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- if get_type_info(cxx.parent.type).vars.action == 'gen_interface' -%}
        {%-   if not cxx.is_static %}
        {#-     this should go to shared macro #}
        {%-     macro gen_func(args, target_overloading_index=none) -%}
        {%-       set comma = joiner(', ') -%}
        @JvmStatic
        external fun j{{vars.name|capitalize}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{get_type_converter(arg.type).jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): {{rconverter.jdk.target_type_name}}
        {%-     endmacro -%}
        {%-     set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%-     for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {%      endfor -%}{{gen_func(cxx.args)}}
        {%-     if vars.is_operator and vars.name == 'get' and not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference %}
        {%-       set comma = joiner(', ') %}
        {%-       set setter_var_name = 'value' %}
        @JvmStatic
        external fun jSet{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}(id: Long{{', ' if cxx.args}}{%- for arg in cxx.args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{get_type_converter(arg.type).jdk.target_type_name}}{%- endfor-%}, {{setter_var_name}}: {{rconverter.kotlin.target_type_name}}{{', vararg extraObjs: Any?' if cxx.args}})
        {%-     endif %}
        {%-   endif %}
        {%- endif %}
  cxx:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {#- this should go to shared macro #}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {%-   set parent_class_info = parent_class_converter.type_info -%}
        {%-   set parent_type_name = parent_class_converter.kotlin.target_type_name + 'Helper' if parent_class_info.vars.action == 'gen_interface' else parent_class_converter.kotlin.target_type_name %}
        {%-   set setter_var_name = 'value' -%}
        {%-   macro args_snippet(args, call_args) -%}
        {%-     for arg in args -%}
        {%-       set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%-       set converter = get_type_converter(arg.type).jni_to_cxx %}
        {{converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr)}}
        {%-       do call_args.append(converter.converted_name(arg_name))%}
        {%      endfor %}
        {%-   endmacro -%}
        {%-   macro call_code(prefix, call_args, is_set_op=false) -%}
        {%-     if 'no_throw' not in vars.throws %}
        void* err_ptr = nullptr;
        {%-     endif -%}
        {%      if rconverter.jni.target_type_name != 'void' and not is_set_op %}
        try {
            decltype(auto) result = {{prefix}}{{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}({{call_args|join(', ')}});
            {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
            return {{rconverter.cxx_to_jni.converted_name('result')}};
        }
        {%-     else %}
        try {
            {{prefix}}{{cxx.name}}({{call_args|join(', ')}}){{' = ' + setter_var_name if is_set_op}};
            return;
        }
        {%-     endif %}
        {%-     if 'no_throw' not in vars.throws %}
        {%-       for exc_type in vars.throws -%}
        catch (const {{exc_type}}& e) {
            err_ptr = new {{exc_type}}(e);
        {%-       set exc_info = get_type_info(exc_type) %}
        {%-       set exc_conv = get_type_converter(exc_type) %}
            jclass excCls = env->FindClass("{{[exc_info.vars.full_package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
            jclass cppbindObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'CppBindObject']|map('replace', '.', pat_sep)|path_join}}");
            jmethodID cppbindConstructor = env->GetMethodID(cppbindObjClass, "<init>", "(JZ)V");
            jobject cppbindObj = env->NewObject(cppbindObjClass, cppbindConstructor, reinterpret_cast<jobjectid>(new CppBindCObject {strdup({{exc_conv.cxx_type_name_global.snippet()}}), err_ptr}), true);
            jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'CppBindObject']|map('replace', '.', pat_sep)|path_join}};)V");
            jobject excObj = env->NewObject(excCls, excConstructor, cppbindObj);
            env->Throw(jthrowable(excObj));
        }
        {%-       endfor %}
        {%-     endif %}
        {%-     if not 'std::exception' in vars.throws %}
        catch (const std::exception& e) {
            jclass handlerCls = env->FindClass({{"\"{}/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
            jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
            env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
        }
        {%-     endif %}
        catch (...) {
            jclass handlerCls = env->FindClass({{"\"{}/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
            jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
            env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
        }
  
        {%      if rconverter.jni.target_type_name != 'void' and not is_set_op -%}
        {{rconverter.jni.target_type_name}} result {};
        return result;
        {%-     endif %}
        {%-   endmacro -%}
        {%-   macro gen_method(is_set_op=false) -%}
        {%-     set target_overloading_index = target_overloading_index|string if target_overloading_index else '' %}
        {%-     set func_name="j%s%s%s%s"|format('Set' if is_set_op else vars.name|capitalize, get_overloading_postfix(vars), get_template_postfix(cxx), target_overloading_index) %}
        {%-     set jni_name = cppbind_helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}

        extern "C" JNIEXPORT {{ 'void' if is_set_op else rconverter.jni.target_type_name }} {{jni_name}}([[maybe_unused]] JNIEnv* env, jobject{{", jobjectid id" if not cxx.is_static}}{{', ' if args}}
        {%-     set comma = joiner(', ') -%}
        {%-     for arg in args -%}
        {{comma()}}{{get_type_converter(arg.type).jni.target_type_name}} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
        {%-     endfor %}{{', ' + rconverter.jni.target_type_name + ' ' + setter_var_name if is_set_op}}{{', ...' if args}}){
        {%- if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%- endif %}
        {%-     set call_args = [] %}
            {{args_snippet(args, call_args)|indent(4)}}
        {%-     if not cxx.is_static %}
            validateID(id);
        {%-       set this_converter = get_type_converter('std::shared_ptr<' + cxx.parent.type_name + '>').jni_to_cxx if parent_class_info.vars.shared_ref else parent_class_converter.jni_to_cxx -%}
            {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
            {{call_code(this_converter.converted_name('id') + "->", call_args, is_set_op)|indent(4)}}
        {%-     else %}
            {{call_code(cxx.parent.type_name + "::", call_args, is_set_op)|indent(4)}}
        {%-     endif %}
        }
        {%-   endmacro -%}
        {{gen_method()}}
        {%-   if vars.is_operator and vars.name == 'get' and not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference %}
        {{gen_method(is_set_op=true)}}
        {%-   endif %}
        {%- endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(cxx.args)}}

function:
  kotlin:
    include: *var_method_kotlin_include
    body:
      !concat
      - !include common_macros.yaml&templates
      - !include kotlin_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- if vars.return_value_policy == 'reference_internal' -%}
        {%    do Error.critical("Cannot apply reference internal policy on a non member function's return value: {} in {}".format(cxx.name, cxx.source_file_name)) -%}
        {%- endif -%}
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', cxx.args|map(attribute='name'))|list -%}
        {%- if incorrect_nullable_args -%}
        {%-   do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), cxx.parent.displayname, cxx.displayname) -%}
        {%- endif -%}
        {#- this should go to shared macro #}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   set comma = joiner(', ') -%}
        {%-   if vars.comment %}
        {{vars.comment|make_doxygen_comment}}
        {%-   endif %}
        {%-   set jvm_name = get_jvm_name(args) %}
        {%-   if jvm_name %}
        {{jvm_name}}
        {%-   endif %}
        fun {{vars.name}}({%- for arg in args -%}
        {%-     set arg_converter = get_type_converter(arg.type) -%}
        {%-     set arg_type_info = get_type_info(arg.type) -%}
        {{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{arg_converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
        {%-     if arg.default -%}
        {%-       if arg.type.is_enum %}
        {%-         set enum_case_name = arg.default.split('::')|last %}
        {%-         if enum_case_name in arg_type_info.vars.enum_excluded_cases -%}
        {%-           do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.parent.displayname, cxx.displayname)) -%}
        {%-         else %} = {{arg_converter.kotlin.target_type_name}}.{{arg_type_info.vars.enum_case_names.get(enum_case_name, arg_type_info.vars.enum_case_name_prefix + enum_case_name)}}
        {%-       endif -%}
        {%-     else -%}
        {%-       if arg.default_is_literal %} = {{arg.default}}{{'F' if arg.type.is_float}}{{'L' if arg.type.is_long}}{{'u' if arg.type.is_uchar}}
        {%-       elif arg.default_is_nullptr %} = null
        {%-       endif %}
        {%-     endif %}
        {%-   endif -%}
        {%-   endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if vars.nullable_return}} {
        {%-   set call_args = [] -%}
        {%-   set result_converter = rconverter.jdk_to_kotlin -%}
        {%-   for arg in args %}
        {%-     set converter = get_type_converter(arg.type).kotlin_to_jdk -%}
        {%-     set arg_name = vars.argument_name.get(arg.name, arg.name) -%}
        {%-     set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) -%}
        {%-     if conversion %}
            {{conversion|indent}}
        {%-     endif %}
        {%-     do call_args.append(converter.converted_name(arg_name)) %}
        {%-   endfor %}
        {#-   extra arguments are passed since after conversion the relation between the original and newly created objects can be lost, and GC can delete original object before its usage -#}
        {%-   for arg in args %}
        {%-     set arg_name = vars.argument_name.get(arg.name, arg.name) %}
        {%-     do call_args.append(arg_name) if not arg_name in call_args %}
        {%-   endfor %}
            val result = j{{vars.name|capitalize}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}({{call_args|join(', ')}})
            {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent}}
            return {{result_converter.converted_name('result')}}
        }
        {%- endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(cxx.args)}}
    glob_external:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {#- this should go to shared macro #}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   set comma = joiner(', ') -%}
        private external fun j{{vars.name|capitalize}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}{{target_overloading_index|string if target_overloading_index}}({%- for arg in args -%}{{comma()}}{{vars.argument_name.get(arg.name, arg.name)}}: {{get_type_converter(arg.type).jdk.target_type_name}}{%- endfor-%}{{', vararg extraObjs: Any?' if args}}): {{rconverter.jdk.target_type_name}}
        {%- endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(cxx.args)}}
    glob_init:
      unique_content: |
        {%- if vars.c_wrapper_lib_name %}
        private val INIT = run {
            System.loadLibrary("{{vars.c_wrapper_lib_name}}");
        }
        {%- endif %}
  cxx:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {#- this should go to shared macro #}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   set target_overloading_index = target_overloading_index|string if target_overloading_index else '' %}
        {%-   set func_name="j%s%s%s%s"|format(vars.name|capitalize, get_overloading_postfix(vars), get_template_postfix(cxx), target_overloading_index) %}
        {%-   macro args_snippet(args, call_args) %}
        {%-     for arg in args -%}
        {%-       set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%-       set converter = get_type_converter(arg.type).jni_to_cxx %}
        {%-       set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-       if conversion %}
        {{conversion}}
        {%-       endif %}
        {%-       do call_args.append(converter.converted_name(arg_name))%}
        {%-     endfor %}
        {%-   endmacro %}
        {%-   macro call_code(call_args) %}
        {%-     if 'no_throw' not in vars.throws %}
        void* err_ptr = nullptr;
        {%-     endif -%}
        {%-     if rconverter.jni.target_type_name != 'void' %}
        try {
            decltype(auto) result = {{cxx.namespace}}::{{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}({{call_args|join(', ')}});
            {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
            return {{rconverter.cxx_to_jni.converted_name('result')}};
        }
        {%-     else %}
        try {
            {{cxx.namespace}}::{{cxx.name}}({{call_args|join(', ')}});
            return;
        }
        {%-     endif %}
        {%-     if 'no_throw' not in vars.throws %}
        {%-       for exc_type in vars.throws -%}
        catch (const {{exc_type}}& e) {
            err_ptr = new {{exc_type}}(e);
        {%-         set exc_info = get_type_info(exc_type) %}
        {%-         set exc_conv = get_type_converter(exc_type) %}
            jclass excCls = env->FindClass("{{[exc_info.vars.full_package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
            jclass cppbindObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'CppBindObject']|map('replace', '.', pat_sep)|path_join}}");
            jmethodID cppbindConstructor = env->GetMethodID(cppbindObjClass, "<init>", "(JZ)V");
            jobject cppbindObj = env->NewObject(cppbindObjClass, cppbindConstructor, reinterpret_cast<jobjectid>(new CppBindCObject {strdup({{exc_conv.cxx_type_name_global.snippet()}}), err_ptr}), true);
            jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'CppBindObject']|map('replace', '.', pat_sep)|path_join}};)V");
            jobject excObj = env->NewObject(excCls, excConstructor, cppbindObj);
            env->Throw(jthrowable(excObj));
        }
        {%-       endfor %}
        {%-     endif %}
        {%-     if not 'std::exception' in vars.throws %}
        catch (const std::exception& e) {
            jclass handlerCls = env->FindClass({{"\"{}/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
            jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
            env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
        }
        {%-     endif %}
        catch (...) {
            jclass handlerCls = env->FindClass({{"\"{}/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
            jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
            env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
        }
  
        {%      if rconverter.jni.target_type_name != 'void' -%}
        {{rconverter.jni.target_type_name}} result {};
        return result;
        {%-     endif %}
        {%-   endmacro %}
        {%-   set file = path.splitext(path.basename(vars.file_fullname))[0] %}
        {%-   set jni_name = cppbind_helper.get_jni_func_name(vars.full_package, file[0]|upper + file[1:] + 'Kt', func_name) %}
        extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}(JNIEnv* env, jclass{{', ' if args}}
        {%-   set comma = joiner(', ') -%}
        {%-   for arg in args -%}
        {{comma()}}{{get_type_converter(arg.type).jni.target_type_name}} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
        {%-   endfor %}{{', ...' if args}}){
        {%- if cxx.namespace %}
            using namespace {{cxx.namespace}};
        {%- endif %}
        {%-   set call_args = [] %}
            {{args_snippet(args, call_args)|indent(4)}}
            {{call_code(call_args)|indent(4)}}
        }
        {%- endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(cxx.args)}}
  

var_getter_kotlin_include: &var_getter_kotlin_include
  unique_content:
    !concat
    - !include kotlin_macros.yaml&includes.kotlin
    - |
      {{gen_import(get_type_converter(cxx.result_type))}}

var_getter_cxx_include: &var_getter_cxx_include
  unique_content:
    !concat
    - !include common_macros.yaml&includes.cxx
    - |
      {{gen_include(get_type_converter(cxx.result_type))}}

var_getter_cxx_forward_decl: &var_getter_cxx_forward_decl
  unique_content:
    !concat
    - !include common_macros.yaml&forward_declarations.getter
    - |
      {{gen_fwd_decl()}}

var_property_getter_setter: &var_property_getter_setter
  kotlin:
    include: *var_getter_kotlin_include
    properties: |
      {%- if not cxx.is_public -%}
      {%-   do Error.critical("{}.{} is not a public field. Make it public or remove cppbind API.".format(cxx.parent.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- set rconverter = get_type_converter(cxx.result_type) -%}
      {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
      {%- set parent_class_info = parent_class_converter.type_info -%}
      {%- set parent_name = parent_class_converter.kotlin.target_type_name -%}
      {% set result_converter = rconverter.jdk_to_kotlin %}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {{'var' if vars.action == 'gen_property_setter' else 'val'}} {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}}
          get() {
      {%- if parent_class_info.vars.action == 'gen_interface' %}
              val result = {{parent_name}}Helper.j{{vars.name|capitalize}}(cppbindObjId)
      {%- else %}
              val result = j{{vars.name|capitalize}}(cppbindObjId)
      {%- endif %}
              {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(8)}}
      {%- set result_is_shared = rconverter.type_info.vars.shared_ref|default(False) %}
      {%- if not result_is_shared and vars.return_value_policy == 'reference_internal' and rconverter.kotlin_ref_internal is defined and (cxx.result_type.is_lval_reference or cxx.result_type.is_pointer) %}
      {%-   set conversion = rconverter.kotlin_ref_internal.snippet(result_converter.converted_name('result'), reference='this', nullable=vars.nullable_return) -%}
      {%-   if conversion %}
              {{conversion|indent(8)}}{% endif %}
      {%- endif %}
              return {{result_converter.converted_name('result')}}
          }
      {%- if vars.action == 'gen_property_setter' %}
      {%-   set converter = rconverter.kotlin_to_jdk %}
          set(value) {
              {{converter.snippet('value', nullable=vars.nullable_return)|indent(8)}}
      {%-   if parent_class_info.vars.action == 'gen_interface' %}
              {{parent_name}}Helper.jSet{{vars.name|lower}}(cppbindObjId, {{converter.converted_name('value')}}, value)
      {%-   else %}
              jSet{{vars.name|lower}}(cppbindObjId, {{converter.converted_name('value')}}, value)
      {%-   endif %}
      {#-   This should go to shared macro -#}
      {%-   if vars.keep_alive %}
      {%-     set args = [namespace(name='value', converter=rconverter)] %}
      {%-     set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%-     if invalid_args  %}
      {%-       do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
      {%-     endif %}
      {%-     for arg_idx in vars.keep_alive %}
      {%-       set converter = args[arg_idx - 1].converter %}
      {%-       if converter.kotlin_keep_alive %}
              {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(8)}}
      {%-       endif %}
      {%-     endfor %}
      {%-   endif %}
          }
      {%  endif %}
    private_external: |
      {%- set rconverter = get_type_converter(cxx.result_type) -%}
      {%- if get_type_info(cxx.parent.type).vars.action == 'gen_class' -%}
      private external fun j{{vars.name|capitalize}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%-   if vars.action == 'gen_property_setter' %}
      private external fun jSet{{vars.name|lower}}(id: Long, value: {{rconverter.jdk.target_type_name}}, valueObj: Any?): Unit
      {%-   endif %}
      {%- endif %}
    interface_external: |
      {%- set rconverter = get_type_converter(cxx.result_type) -%}
      {%- if get_type_info(cxx.parent.type).vars.action == 'gen_interface' %}

      @JvmStatic
      external fun j{{vars.name|capitalize}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%-   if vars.action == 'gen_property_setter' %}

      @JvmStatic
      external fun jSet{{vars.name|lower}}(id: Long, value: {{rconverter.jdk.target_type_name}}, valueObj: Any?): Unit
      {%-   endif %}
      {%- endif %}
  cxx:
    include: *var_getter_cxx_include
    forward_decl: *var_getter_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {%- set rconverter = get_type_converter(cxx.result_type) -%}
      {%- set parent_class_converter = get_type_converter(cxx.parent.type) %}
      {%- set parent_class_info = parent_class_converter.type_info %}
      {%- set parent_type_name = parent_class_converter.kotlin.target_type_name + 'Helper' if parent_class_info.vars.action == 'gen_interface' else parent_class_converter.kotlin.target_type_name %}
      {%- set func_name="j%s"|format(vars.name|capitalize) %}
      {%- set jni_name = cppbind_helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}
      {%- set this_converter = get_type_converter('std::shared_ptr<' + cxx.parent.type_name + '>').jni_to_cxx if parent_class_info.vars.shared_ref else parent_class_converter.jni_to_cxx -%}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}([[maybe_unused]] JNIEnv* env, jobject, jobjectid id){
      {%- if cxx.parent.namespace %}
          using namespace {{cxx.parent.namespace}};
      {%- endif %}
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          decltype(auto) result = {{this_converter.converted_name('id')}}->{{cxx.name}};
          {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
          return {{rconverter.cxx_to_jni.converted_name('result')}};
      }
      {%- if vars.action == 'gen_property_setter' %}
      {%    set func_name="jSet%s"|format(vars.name|lower) %}
      {%-   set jni_name = cppbind_helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}
      extern "C" JNIEXPORT void {{jni_name}}([[maybe_unused]] JNIEnv* env, jobject, jobjectid id, {{rconverter.jni.target_type_name}} value, ...){
      {%- if cxx.parent.namespace %}
          using namespace {{cxx.parent.namespace}};
      {%- endif %}
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
      {%    set converter = rconverter.jni_to_cxx %}
          {{converter.snippet('value', nullable=vars.nullable_return)|indent(4)}}
          {{this_converter.converted_name('id')}}->{{cxx.name}} = {{converter.converted_name('value')}};
      }
      {% endif %}

property_getter: *var_property_getter_setter

property_setter: *var_property_getter_setter

getter:
  kotlin:
    include: *var_getter_kotlin_include
    properties:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- do cppbind_helper.validate_getter(cxx, vars, setter|default(none)) -%}
        {%- do cppbind_helper.validate_template_getter_setter(cxx, vars, setter|default(none)) -%}
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {%- set parent_class_info = parent_class_converter.type_info -%}
        {%- set parent_name = parent_class_converter.kotlin.target_type_name -%}
        {% set result_converter = rconverter.jdk_to_kotlin %}
        {%- if vars.comment %}
        {{vars.comment|make_doxygen_comment}}
        {%- endif %}
        {{'open ' if cxx.is_open}}{{gen_override_keyword(cxx, vars)}}{{'var ' if setter is defined else 'val '}}
        {%- if cxx.is_template -%}
        {{get_template_getter_name(cxx, template_args_postfixes)}}
        {%- else %}{{vars.name}}
        {%- endif -%}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}}
            get() {
        {%- if parent_class_info.vars.action == 'gen_interface' %}
                val result = {{parent_name}}Helper.j{{vars.name|capitalize}}{{get_template_postfix(cxx)}}(cppbindObjId)
        {%- else %}
                val result = j{{vars.name|capitalize}}{{get_template_postfix(cxx)}}(cppbindObjId)
        {%- endif %}
                {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(8)}}
        {%- set result_is_shared = rconverter.type_info.vars.shared_ref|default(False) %}
        {%- if not result_is_shared and vars.return_value_policy == 'reference_internal' and rconverter.kotlin_ref_internal is defined and (cxx.result_type.is_lval_reference or cxx.result_type.is_pointer) %}
        {%-   set conversion = rconverter.kotlin_ref_internal.snippet(result_converter.converted_name('result'), reference='this', nullable=vars.nullable_return) -%}
        {%-   if conversion %}
                {{conversion|indent(8)}}{%- endif %}
        {%-   endif %}
                return {{result_converter.converted_name('result')}}
            }
        {%-   if setter is defined %}
        {%-     set incorrect_nullable_args = setter.vars.nullable_arg|reject('in', setter.cxx.args|map(attribute='name'))|list -%}
        {%-     if incorrect_nullable_args -%}
        {%-       do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), setter.cxx.parent.displayname, setter.cxx.displayname)) -%}
        {%-     endif -%}
        {%-     set converter = get_type_converter(setter.cxx.args[0].type).kotlin_to_jdk %}
        {%-     if gen_override_keyword(cxx, vars) %}
            set(value) {
                super.{{vars.name}} = value
            }
        {%-     else %}
            set(value) {
                {{converter.snippet('value', nullable=vars.nullable_return)|indent(8)}}
        {%-     if parent_class_info.vars.action == 'gen_interface' %}
                {{parent_name}}Helper.j{{setter.vars.name|capitalize}}{{get_template_postfix(cxx)}}(cppbindObjId, {{converter.converted_name('value')}}, value)
        {%-     else %}
                j{{setter.vars.name|capitalize}}{{get_template_postfix(cxx)}}(cppbindObjId, {{converter.converted_name('value')}}, value)
        {%-     endif %}
        {%-     if setter.vars.keep_alive %}
        {%-       set args = [namespace(name='value', converter=rconverter)] %}
        {%-       set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
        {%-       if invalid_args  %}
        {%-         do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
        {%-       endif %}
        {%-       for arg_idx in vars.keep_alive %}
        {%-         set converter = args[arg_idx - 1].converter %}
        {%-         if converter.kotlin_keep_alive %}
                {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(8)}}
        {%-         endif %}
        {%-       endfor %}
        {%-     endif %}
            }
        {%-   endif %}
        {%- endif %}
    private_external:
      !concat
      - !include common_macros.yaml&templates
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- if get_type_info(cxx.parent.type).vars.action == 'gen_class' -%}
        private external fun j{{vars.name|capitalize}}{{get_template_postfix(cxx)}}(id: Long): {{rconverter.jdk.target_type_name}}
        {%-   if setter is defined %}
        private external fun j{{setter.vars.name|capitalize}}{{get_template_postfix(cxx)}}(id: Long, value: {{get_type_converter(setter.cxx.args[0].type).jdk.target_type_name}}, valueObj: Any?): Unit
        {%-   endif %}
        {%- endif %}
    interface_external:
      !concat
      - !include common_macros.yaml&templates
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- if get_type_info(cxx.parent.type).vars.action == 'gen_interface' -%}
        @JvmStatic
        external fun j{{vars.name|capitalize}}{{get_template_postfix(cxx)}}(id: Long): {{rconverter.jdk.target_type_name}}
        {%-   if setter is defined %}
  
        @JvmStatic
        external fun j{{setter.vars.name|capitalize}}{{get_template_postfix(cxx)}}(id: Long, value: {{get_type_converter(setter.cxx.args[0].type).jdk.target_type_name}}, valueObj: Any?): Unit
        {%-   endif %}
        {%- endif %}
  cxx:
    include: *var_getter_cxx_include
    forward_decl: *var_getter_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body:
      !concat
      - !include common_macros.yaml&templates
      - |
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- macro gen_exc_try_block(vars) -%}
        {%-   if 'no_throw' not in vars.throws %}
        {%-     for exc_type in vars.throws -%}
            catch (const {{exc_type}}& e) {
                err_ptr = new {{exc_type}}(e);
        {%-       set exc_info = get_type_info(exc_type) %}
        {%-       set exc_conv = get_type_converter(exc_type) %}
                jclass excCls = env->FindClass("{{[exc_info.vars.full_package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
                jclass cppbindObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'CppBindObject']|map('replace', '.', pat_sep)|path_join}}");
                jmethodID cppbindConstructor = env->GetMethodID(cppbindObjClass, "<init>", "(JZ)V");
                jobject cppbindObj = env->NewObject(cppbindObjClass, cppbindConstructor, reinterpret_cast<jobjectid>(new CppBindCObject {strdup({{exc_conv.cxx_type_name_global.snippet()}}), err_ptr}), true);
                jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'CppBindObject']|map('replace', '.', pat_sep)|path_join}};)V");
                jobject excObj = env->NewObject(excCls, excConstructor, cppbindObj);
                env->Throw(jthrowable(excObj));
            }
        {%-     endfor %}
        {%-   endif %}
        {%-   if not 'std::exception' in vars.throws %}
            catch (const std::exception& e) {
                jclass handlerCls = env->FindClass({{"\"{}/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
                jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
                env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
            }
        {%-   endif %}
            catch (...) {
                jclass handlerCls = env->FindClass({{"\"{}/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
                jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
                env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
            }
        {%- endmacro -%}
        {%- set func_name="j%s%s"|format(vars.name|capitalize, get_template_postfix(cxx)) %}
        {%- set parent_class_converter = get_type_converter(cxx.parent.type) %}
        {%- set parent_class_info = parent_class_converter.type_info %}
        {%- set parent_type_name = parent_class_converter.kotlin.target_type_name + 'Helper' if parent_class_info.vars.action == 'gen_interface' else parent_class_converter.kotlin.target_type_name %}
        {%- set jni_name = cppbind_helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}
        {%- set this_converter = get_type_converter('std::shared_ptr<' + cxx.parent.type_name + '>').jni_to_cxx if parent_class_info.vars.shared_ref else parent_class_converter.jni_to_cxx %}
        extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}([[maybe_unused]] JNIEnv* env, jobject, jobjectid id){
        {%- if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%- endif %}
            validateID(id);
            {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
        {%- if 'no_throw' not in vars.throws %}
            void* err_ptr = nullptr;
        {%- endif %}
            try {
                decltype(auto) result = {{this_converter.converted_name('id')}}->{{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}();
                {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(8)}}
                return {{rconverter.cxx_to_jni.converted_name('result')}};
            }
            {{gen_exc_try_block(vars)}}
  
            {{rconverter.jni.target_type_name}} result {};
            return result;
        }
        {%- if setter is defined %}
        {%    set func_name="j%s%s"|format(setter.vars.name|capitalize, get_template_postfix(cxx)) %}
        {%-   set jni_setter_name = cppbind_helper.get_jni_func_name(vars.full_package, parent_type_name, func_name) %}
        extern "C" JNIEXPORT void {{jni_setter_name}}([[maybe_unused]] JNIEnv* env, jobject, jobjectid id, {{get_type_converter(setter.cxx.args[0].type).jni.target_type_name}} {{setter.cxx.args[0].name}}, ...){
        {%- if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%- endif %}
            validateID(id);
            {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
        {%-   set converter = get_type_converter(setter.cxx.args[0].type).jni_to_cxx %}
            {{converter.snippet(setter.cxx.args[0].name, nullable=vars.nullable_return)|indent(4)}}
        {%-   if 'no_throw' not in setter.vars.throws %}
            void* err_ptr = nullptr;
        {%-   endif %}
            try {
               {{this_converter.converted_name('id')}}->{{setter.cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}({{converter.converted_name(setter.cxx.args[0].name)}});
            }
            {{gen_exc_try_block(setter.vars)}}
        }
        {% endif %}
