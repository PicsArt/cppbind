# Copyright (c) 2022 PicsArt, Inc.
# All rights reserved. Use of this source code is governed by a
# MIT-style license that can be found in the LICENSE file.

file:
  python_init:
    file_path: |
      {%- set outpath = vars.out_dir + pat_sep + vars.full_package|replace('.', pat_sep) -%}
      {{outpath if vars.action == 'gen_package' else path.dirname(outpath)}}{{pat_sep}}__init__.py
    scopes:
      - include
      - code_fragment
    content: |
      {{[banner_logo, vars.banner_comment]|make_py_docstring}}
      {{include}}
      {%- if code_fragment %}
      {{code_fragment}}
      {%- else %}
      {%- endif %}{{new_line}}
  python:
    file_path: |
      {{vars.out_dir + pat_sep + vars.full_package|replace('.', pat_sep)}}.py
    scopes:
      - body
      - include
    content: |
      {{[banner_logo, vars.banner_comment]|make_py_docstring}}
      {%- set future_import = 'from __future__ import annotations' %}
      {%- set typing_import = 'from typing import *' %}
      {%- set pybind_import = 'import ' + [vars.pybind_module, vars.package, vars.file]|join('.') + ' as pybind_' + vars.full_package.split('.')[-1] %}
      {%- if vars.helpers_package_prefix %}
      {%- set bind_import = 'from ' + vars.helpers_package_prefix + '.cppbind_utils{} import *'.format(vars.file_postfix) %}
      {%- else %}
      {%- set bind_import = 'from cppbind_utils{} import *'.format(vars.file_postfix) %}
      {%- endif %}
      {%- set helpers = helper_includes|format_list('from {} import *')|join_unique %}
      {{[future_import, typing_import, pybind_import, include, helpers, bind_import]|join(new_line)|sort_python_code}}
      {{body}}{{new_line}}
  cxx:
    file_path: |
      {{vars.c_file_fullname}}
    scopes:
      - include
      - header
      - body
      - footer
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include <cxxabi.h>
      #include <memory>
      #include <pybind11/pybind11.h>
      #include <pybind11/stl.h>
      #include <pybind11/functional.h>

      {{include}}

      namespace py = pybind11;

      {{header}}
          {{body|string|indent(4)}}
      {{footer}}{{new_line}}
  hpp:
    file_path: |
      {{vars.h_file_fullname}}
    scopes:
      - header
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      {% set filename = vars.full_package|replace('.', '_') -%}
      #ifndef {{filename}}_hpp
      #define {{filename}}_hpp

      #include <pybind11/pybind11.h>

      namespace py = pybind11;

      {{header}}

      #endif{{new_line}}
  pybind_module_cxx:
    file_path: |
      {{vars.c_pybind_filename}}
    scopes:
      - body
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include <pybind11/pybind11.h>
      #include "{{path.relpath(vars.h_pybind_filename, vars.out_prj_dir)}}"

      namespace py = pybind11;

      void bind{{vars.pybind_module.replace('.', '_')|capitalize|to_camel_case}}(py::module& m) {
          {{body|string|indent}}
      }{{new_line}}
  pybind_module_hpp:
    file_path: |
      {{vars.h_pybind_filename}}
    scopes:
      - include
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      {% set package = vars.pybind_module.replace('.', '_') -%}
      #ifndef {{package}}_hpp
      #define {{package}}_hpp

      {{include}}
      #include <pybind11/pybind11.h>

      namespace py = pybind11;
      void bind{{vars.pybind_module.replace('.', '_')|capitalize|to_camel_case}}(py::module& m);

      #endif{{new_line}}
  pybind_package:
    file_path: |
      {{vars.pybind_module_filename}}
    gen: false
    scopes:
      - body
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}
      {% set packages = vars.pybind_module.split('.') %}
      #include <pybind11/pybind11.h>
      #include "{{path.relpath(vars.h_pybind_filename, vars.out_prj_dir)}}"

      namespace py = pybind11;
      PYBIND11_MODULE({{packages[0]}}, m) {
          py::module_ parent = m;
          {%- for p in packages[1:] %}
          {%- set parent_module = packages[loop.index - 1] %}
          py::module_ {{parent_module}} = parent.def_submodule("{{p}}", "{{p}}");
          parent = {{parent_module}};
          {%- endfor %}
          bind{{vars.pybind_module.replace('.', '_').split('_')|map('capitalize')|join}}(parent);
      }{{new_line}}
  bind: !include bind_snippet.yaml

var_pybind_module_cxx: &var_pybind_module
  body:
    unique_content: |
      {%- set package_name = vars.package|replace('.', '_') -%}
      {{marker}}py::module_ {{package_name}} = m.def_submodule("{{vars.package}}", "{{vars.package}}");
      {{marker}}py::module_ {{package_name}}_{{vars.file}} = {{package_name}}.def_submodule("{{vars.file}}", "{{vars.file}}");
      {{marker}}bind{{vars.full_package|replace('.', '_')|to_camel_case(capitalize=True)}}({{package_name}}_{{vars.file}});

package:
  python_init:
    code_fragment:
      unique_content: |
        {%- if vars.code_fragment -%}
        {{marker}}
        {{vars.code_fragment}}
        {%- endif -%}
    include:
      unique_content: |
        {{vars.include|format_list('from {} import *')|join_unique}}

var_pybind_module_hpp: &var_pybind_module_hpp
  include:
    unique_content: |
      #include "{{path.relpath(vars.h_file_fullname, vars.out_prj_dir)}}"

var_hpp_header: &var_hpp_header
  unique_content: |
    void bind{{vars.full_package|replace('.', '_')|to_camel_case(capitalize=True)}}(py::module& m);


var_cxx_header: &var_cxx_header
  unique_content: |
    void bind{{vars.full_package|replace('.', '_')|to_camel_case(capitalize=True)}}(py::module& m) {

var_cxx_footer: &var_cxx_footer
  unique_content: |
    } /* bind{{vars.full_package|replace('.', '_')|to_camel_case(capitalize=True)}} */


enum:
  python:
    body: |
      {%- if vars.header_code_fragment %}
      {{vars.header_code_fragment}}{{new_line}}
      {%- endif %}
      {% set m = 'pybind_' + vars.full_package.split('.')[-1] %}
      class {{vars.name}}({{vars.bases_list|join(', ')}}{{', ' if vars.bases_list}}metaclass=CppBindEnumMetaclass):
          {{vars.comment|make_py_docstring|indent}}
          {%- for case in enum_cases -%}
          {%- if case.name not in vars.enum_excluded_cases -%}
          {%- if case.comment %}
          {{case.comment|make_py_comment|indent}}
          {%- endif %}
          {%- set case_name = vars.enum_case_names.get(case.name, vars.enum_case_name_prefix + case.name) %}
          {{case_name}} = {{m}}.{{vars.name}}.{{case_name}}
          {%- endif %}
          {%- endfor %}

          def __int__(self):
              return self.value
          {%- if vars.code_fragment %}

          {{vars.code_fragment|indent(4)}}
          {%- endif %}
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {%- endif %}
  python_init:
    include:
      unique_content: |
        from .{{vars.full_package.split('.')[-1]}} import {{vars.name}}
  cxx:
    header: *var_cxx_header
    footer: *var_cxx_footer
    body: |
      {
          {%- if cxx.namespace %}
          using namespace {{cxx.namespace}};
          {%- endif %}
          py::enum_<{{cxx.type_name}}>(m, "{{vars.name}}")
              {%- for case in enum_cases %}
              {%- if case.name not in vars.enum_excluded_cases %}
              .value("{{vars.enum_case_names.get(case.name, vars.enum_case_name_prefix + case.name)}}", {{cxx.type_name}}::{{case.name}})
              {%- endif %}
              {%- endfor -%};
      }
    include:
      unique_content:
        !concat
        - !include cxx_macros.yaml&cxx_include
        - |
          {%- if vars.is_proj_type -%}
          {{marker}}#include "{{vars.prj_rel_file_name}}"
          {%- endif -%}
          {%- set includes = gen_cxx_include(vars) -%}
          {%- if includes -%}{{includes}}{%- endif -%}
  hpp:
    header: *var_hpp_header
  pybind_module_cxx: *var_pybind_module
  pybind_module_hpp: *var_pybind_module_hpp
  pybind_package:
    body:

var_class: &var_class
  python:
    include:
      unique_content: |
        {%- if cxx.is_abstract -%}
        {{marker}}from abc import abstractmethod
        {%- endif -%}
        {%- if vars.include -%}
        {{marker}}{{vars.include|select('match_regexp', '^import\s.*$', '^from\s.*$')|join_unique}}
        {{marker}}{{vars.include|reject('match_regexp', '^import\s.*$', '^from\s.*$')|format_list('from {} import *')|join_unique}}
        {%- endif -%}
        {#- this should go to shared macro python_include -#}
        {%- macro gen_import(converter) -%}
        {%- if converter.python_include -%}
        {{marker}}{{converter.python_include.snippet(full_package=vars.full_package)}}
        {%- endif -%}
        {%- if converter.python -%}
        {%- for arg_converter in converter.python.args_converters -%}
        {{gen_import(arg_converter)}}
        {%- endfor -%}
        {%- endif -%}
        {%- endmacro -%}
        {%- for base in base_types_converters -%}
        {{gen_import(base)}}
        {%- endfor -%}
    body:
      scopes:
        - constructor_body
        - properties
        - body
      content:
        !concat
        - !include python_macros.yaml&special_functions.class.python
        - |
          {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
          {%- do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
          {%- endif -%}
          {%- if ancestors|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
          {%- do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
          {%- endif %}
          {%- if vars.header_code_fragment %}
          {{vars.header_code_fragment}}{{new_line}}
          {%- endif %}
          {%- set bases_specifiers = [] -%}
          {%- for base_type_converter in base_types_converters -%}
          {%- do bases_specifiers.append(base_type_converter.python.get_target_type_name(full_package=vars.full_package)) -%}
          {%- endfor -%}
          {%- do bases_specifiers.extend(vars.bases_list) -%}
          {%- do bases_specifiers.append('metaclass=CppBindMetaclass') %}
  
          class {{converter.python.target_type_name}}({{bases_specifiers|join(', ')}}):
              {%- if vars.comment %}
              {{vars.comment|make_py_docstring|indent}}
              {%- endif %}
              {%- if not cxx.is_abstract %}
              {%- if constructor_body %}
              {{constructor_body|string|indent}}
              {%- endif %}
              {%- else %}
              @abstractmethod
              def __init__(self, *args, **kwargs):
                  pass
              {%- endif %}
              {%- if properties %}
              {{properties|string|indent}}
              {%- endif %}
              {%- if body %}
              {{body|string|indent}}
              {%- endif %}
              {%- if (not cxx.is_abstract, not constructor_body, not properties, not body)|all %}
              pass
              {%- endif %}
              {%- if not base_types_converters and repr_decl not in body|string %}
              {#- add __repr__ based on C++ type and id to be used for debugging purposes #}

              {{gen_repr_function()|indent(4)}}
              {%- endif %}
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {%- endif %}
  python_init:
    include:
      unique_content: |
        {%- if not converter.python.parent_type_info -%}{#- do not generate an import for nested type in __init__.py -#}
        from .{{vars.full_package.split('.')[-1]}} import {{converter.python.target_type_name}}
        {%- endif -%}
  cxx:
    header: *var_cxx_header
    footer: *var_cxx_footer
    include:
      unique_content:
        !concat
        - !include cxx_macros.yaml&cxx_include
        - |
          {#- this should go to shared macro cxx_include -#}
          {%- macro gen_include(converter) -%}
          {%- if converter.cxx_include -%}
          {{marker}}{{converter.cxx_include.snippet()}}
          {%- endif -%}
          {%- if converter.python -%}
          {%- for arg_converter in converter.python.args_converters -%}
          {{gen_include(arg_converter)}}
          {%- endfor -%}
          {%- endif -%}
          {%- endmacro -%}
          {{gen_include(converter)}}
          {%- for base_converter in base_types_converters -%}
          {{gen_include(base_converter)}}
          {%- endfor -%}
          {%- set includes = gen_cxx_include(vars) -%}
          {%- if includes -%}{{includes}}{%- endif -%}
    body:
      scopes:
        - body
      content:
        !concat
        - !include python_macros.yaml&special_functions.class.pybind
        - |
          {
              {%- if cxx.namespace %}
              using namespace {{cxx.namespace}};
              {%- endif %}
              {% set comma = joiner(', ') -%}
              {% set shared_ptr = 'std::shared_ptr<' + cxx.type_name + '>' -%}
              py::class_<{{cxx.type_name}} {%- if vars.shared_ref -%}
                                            , std::shared_ptr<{{cxx.type_name}}>
                                           {%- endif %}
                                           {%- if base_types_converters -%}
                                           , {% for base_info in base_types_infos -%}
                                           {{comma()}}{{base_info.cxx.type_name}}
                                           {%- endfor -%}
                                           {%- endif %}> {{converter.python.target_type_name|decapitalize}}(m, "{{converter.python.target_type_name}}"{{', py::is_final()' if not cxx.is_open}});
              {{body|string|indent(4)}}
              {#- add __repr__ based on C++ type and id to be used for debugging purposes -#}
              {%- if not base_types_converters and 'def("__repr__"' not in body|string %}
              {{gen_repr_function()|indent(4)}}
              {%- endif %}  
          }
  hpp:
    header: *var_hpp_header
  pybind_module_cxx: *var_pybind_module
  pybind_module_hpp: *var_pybind_module_hpp
  pybind_package:
    body:

class: *var_class

interface: *var_class


var_bind_method: &var_bind_method
  converter:
    unique_content: |
      {%- for arg in args -%}
      {%- set converter = arg.converter.python_to_pybind -%}
      {%- set snippet = converter.snippet('arg') -%}
      {%- if snippet -%}
      {{marker}}if type_hint == '{{arg.converter.python.target_type_name}}':
          {{snippet|indent}}
          return {{converter.converted_name('arg')}}
      {%- endif -%}
      {%- endfor -%}

var_method_python_include: &var_method_python_include
  unique_content: |
    {#- this should go to shared macro python_include -#}
    {%- macro gen_import(converter) -%}
    {%- if converter.python_include -%}
    {{marker}}{{converter.python_include.snippet(full_package=vars.full_package)}}
    {%- endif -%}
    {%- if converter.python -%}
    {%- for arg_converter in converter.python.args_converters -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {%- for arg in args -%}
    {{gen_import(arg.converter)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_import(rconverter)}}
    {%- endif -%}

var_method_cxx_include: &var_method_cxx_include
  unique_content:
    !concat
    - !include cxx_macros.yaml&cxx_include
    - |
      {%- if vars.is_proj_type -%}
      {{marker}}#include "{{vars.prj_rel_file_name}}"
      {%- endif -%}
      {#- this should go to shared macro cxx_include -#}
      {%- macro gen_include(converter) -%}
      {%- if converter.cxx_include -%}
      {{marker}}{{converter.cxx_include.snippet()}}
      {%- endif -%}
      {%- if converter.python -%}
      {%- for arg_converter in converter.python.args_converters -%}
      {{gen_include(arg_converter)}}
      {%- endfor -%}
      {%- endif -%}
      {%- endmacro -%}
      {%- for arg in args -%}
      {{gen_include(arg.converter)}}
      {%- endfor -%}
      {%- if rconverter is defined -%}
      {{gen_include(rconverter)}}
      {%- endif -%}
      {%- set includes = gen_cxx_include(vars) -%}
      {%- if includes -%}{{includes}}{%- endif -%}

constructor:
  python:
    include: *var_method_python_include
    constructor_body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
        {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {% set comma = joiner(', ') %}
      @bind
      def __init__(self{{', ' if args}}{%- for arg in args -%}
                                       {%- set arg_converter = arg.converter.python %}
                                       {%- set arg_type_hint = arg_converter.get_target_type_name(full_package=vars.full_package) -%}
                                       {{comma()}}{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}: {{'Optional['  if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{{arg_type_hint}}{{']' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
                                       {%- if arg.default -%}
                                       {%- if arg.is_enum %}
                                       {%- set enum_case_name = arg.default.split('::')|last %}
                                       {%- if enum_case_name in arg.type_info.vars.enum_excluded_cases -%}
                                       {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} constructor argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
                                       {%- else %} = {{arg_type_hint}}.{{arg.type_info.vars.enum_case_names.get(enum_case_name, arg.type_info.vars.enum_case_name_prefix + enum_case_name)}}
                                       {%- endif -%}
                                       {%- else -%}
                                       {%- if arg.default_is_literal %} = {{arg.default|capitalize if arg.is_bool else arg.default}}
                                       {%- else %} = None
                                       {%- endif %}
                                       {%- endif %}
                                       {%- endif -%}
                                       {%- endfor %}):
          {{vars.comment|make_py_docstring|to_snake_case(args|map(attribute='name'))|indent}}
          pass
  bind: *var_bind_method
  cxx:
    include: *var_method_cxx_include
    body: |
      {%- set comma = joiner(', ') %}
      {{owner_class.converter.python.target_type_name|decapitalize}}.def(py::init<{%- for arg in args -%}
                                                                                          {{comma()}}{{arg.type_info.cxx.type_name}}
                                                                                          {%- endfor -%}>(){{', ' if args}}
                                                                                          {%- set comma = joiner(', ') -%}
                                                                                          {%- for arg in args -%}
                                                                                          {{comma()}}py::arg("{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}")
                                                                                          {%- if arg.default %}{{' = ' + arg.default if not (arg.is_enum and arg.default.split('::')|last in arg.type_info.vars.enum_excluded_cases)}}
                                                                                          {%- endif -%}
                                                                                          {%- endfor -%}
                                                                                          {#- This should go to shared macro -#}
                                                                                          {%- if vars.keep_alive -%}
                                                                                          {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
                                                                                          {%- if invalid_args -%}
                                                                                          {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
                                                                                          {%- endif -%}
                                                                                            , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
                                                                                          {%- endif %});



method:
  python:
    include: *var_method_python_include
    body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname) -%}
      {%- endif -%}
      {%- set _name = vars.name|to_snake_case %}
      {%- if cxx.name == vars.hash_method %}
      {%- set _name = '__hash__' %}
      {%- elif cxx.name == vars.equals_method %}
      {%- set _name = '__eq__' %}
      {%- elif cxx.name == vars.tostring_method %}
      {%- set _name = '__str__' %}
      {%- endif %}
      {%- set comma = joiner(', ') -%}
      {%- if cxx.is_static %}
      @classmethod
      {%- endif %}
      {%- set rconverter = rconverter.python %}
      {%- set comment = vars.comment|to_snake_case(args|map(attribute='name')) %}
      @bind
      def {{_name}}({{'self' if not cxx.is_static else 'cls'}}{{', ' if args}}
                                                          {%- set rtype_hint = rconverter.get_target_type_name(full_package=vars.full_package) -%}
                                                          {%- for arg in args -%}
                                                          {%- set arg_converter = arg.converter.python %}
                                                          {%- set arg_type_hint = arg_converter.get_target_type_name(full_package=vars.full_package) -%}
                                                          {{comma()}}{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}: {{'Optional['  if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{{arg_type_hint}}{{']' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
                                                          {%- if arg.default -%}
                                                          {%- if arg.is_enum %}
                                                          {%- set enum_case_name = arg.default.split('::')|last %}
                                                          {%- if enum_case_name in arg.type_info.vars.enum_excluded_cases -%}
                                                          {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
                                                          {%- else %} = {{arg_type_hint}}.{{arg.type_info.vars.enum_case_names.get(enum_case_name, arg.type_info.vars.enum_case_name_prefix + enum_case_name)}}
                                                          {%- endif -%}
                                                          {%- else -%}
                                                          {%- if arg.default_is_literal %} = {{arg.default|capitalize if arg.is_bool else arg.default}}
                                                          {%- else %} = None
                                                          {%- endif %}
                                                          {%- endif %}
                                                          {%- endif -%}
                                                          {%- endfor %}) -> {{'Optional[' if vars.nullable_return}}{{rtype_hint}}{{']' if vars.nullable_return}}:
          {{comment|make_py_docstring|indent}}
          pass

      {%- set setter_var_name = 'value' -%}
      {%- if vars.is_operator and vars.name == '__getitem__' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}

      @bind
      def __setitem__({{'self' if not cxx.is_static else 'cls'}}{{', ' if args}}
                                                          {%- set rtype_hint = rconverter.get_target_type_name(full_package=vars.full_package) -%}
                                                          {%- for arg in args -%}
                                                          {%- set arg_converter = arg.converter.python %}
                                                          {%- set arg_type_hint = arg_converter.get_target_type_name(full_package=vars.full_package) -%}
                                                          {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}: {{arg_type_hint}}{{comma()}}{{setter_var_name}}: {{rtype_hint}}
                                                          {%- endfor %}):
          {{comment|make_py_docstring|indent}}
          pass
      {%- endif %}

  bind: *var_bind_method
  cxx:
    include: *var_method_cxx_include
    body: |
      {%- set _name = vars.name|to_snake_case %}
      {%- if cxx.name == vars.hash_method %}
      {%- set _name = '__hash__' %}
      {%- elif cxx.name == vars.equals_method %}
      {%- set _name = '__eq__' %}
      {%- elif cxx.name == vars.tostring_method %}
      {%- set _name = '__str__' %}
      {%- endif %}
      {%- set comma = joiner(', ') -%}
      {{owner_class.converter.python.target_type_name|decapitalize}}.def{{'_static' if cxx.is_static }}("{{_name}}"{%- if cxx.is_overloaded -%}
      , py::overload_cast<
      {%- for arg in args -%}
      {{comma()}}{{arg.type_info.cxx.type_name}}
      {%- endfor -%}>(&{{owner_class.cxx.type_name}}::{{cxx.name}}{{', py::const_' if cxx.is_const}})
      {%- else -%}
      , &{{owner_class.cxx.type_name}}::{{cxx.name}}
      {%- endif -%}
      {%- if cxx.is_template -%}
      <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
      {%- endif -%}
      {{', ' if args}}
      {%- set comma = joiner(', ') -%}
      {%- for arg in args -%}
      {{comma()}}py::arg("{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}")
      {%- if arg.default %}{{' = ' + arg.default if not (arg.is_enum and arg.default.split('::')|last in arg.type_info.vars.enum_excluded_cases)}}
      {%- endif -%}
      {%- endfor -%}
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive and not (vars.is_operator and vars.name == '__getitem__') -%}
      {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%- if cxx.is_static -%}
      {%- do Error.critical('Cannot apply keep alive policy for a static member function: {}.{}'.format(name, owner)) -%}
      {%- endif -%}
      {%- if invalid_args -%}
      {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
      {%- endif -%}
      , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%- endif -%}
      {%- if return_type_info.cxx.type_name != 'void' and vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
      {%- set setter_var_name = 'value' -%}
      {%- if vars.is_operator and vars.name == '__getitem__' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
      {{owner_class.converter.python.target_type_name|decapitalize}}.def("__setitem__", []({{owner_class.cxx.type_name}}& self,{%- for arg in args %} {{arg.type_info.cxx.type_name}} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor -%}, {{return_type_info.cxx.unqualified_resolved_type_name}} {{setter_var_name}}){ self[{{args[0].name|to_snake_case}}] = {{setter_var_name}}; }
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive -%}
      {%- set args = args + [rconverter] %}
      {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%- if invalid_args -%}
      {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
      {%- endif -%}
      , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%- endif -%});
      {%- endif %}



function:
  python_init:
    include:
      unique_content: |
        {%- set template_postfix = '_' + template_type_converters|format_list("{arg.python.target_type_name}", 'arg')|join|to_snake_case|lower if cxx.is_template else '' -%}
        from .{{vars.full_package.split('.')[-1]}} import {{vars.name|to_snake_case}}{{'_' + vars.overloading_postfix|to_snake_case if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix|replace('_', '')}}{{template_postfix}}
  python:
    include: *var_method_python_include
    body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list %}
      {%- if incorrect_nullable_args %}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname) %}
      {%- endif %}
      {%- set template_postfix = '_' + template_type_converters|format_list("{arg.python.target_type_name}", 'arg')|join|to_snake_case|lower if cxx.is_template else '' %}
      {%- set comma = joiner(', ') %}
      {% set rconverter = rconverter.python %}
      @bind
      def {{vars.name|to_snake_case}}{{'_' + vars.overloading_postfix|to_snake_case if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix|replace('_', '')}}{{template_postfix}}(
                                      {%- set rtype_hint = rconverter.get_target_type_name(full_package=vars.full_package) -%}
                                      {%- for arg in args -%}
                                      {%- set arg_converter = arg.converter.python %}
                                      {%- set arg_type_hint = arg_converter.get_target_type_name(full_package=vars.full_package) -%}
                                      {{comma()}}{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}: {{'Optional['  if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{{arg_type_hint}}{{']' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
                                      {%- if arg.default -%}
                                      {%- if arg.is_enum %}
                                      {%- set enum_case_name = arg.default.split('::')|last %}
                                      {%- if enum_case_name in arg.type_info.vars.enum_excluded_cases -%}
                                      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
                                      {%- else %} = {{arg_type_hint}}.{{arg.type_info.vars.enum_case_names.get(enum_case_name, arg.type_info.vars.enum_case_name_prefix + enum_case_name)}}
                                      {%- endif -%}
                                      {%- else -%}
                                      {%- if arg.default_is_literal %} = {{arg.default|capitalize if arg.is_bool else arg.default}}
                                      {%- else %} = None
                                      {%- endif %}
                                      {%- endif %}
                                      {%- endif -%}
                                      {%- endfor %}) -> {{'Optional[' if vars.nullable_return}}{{rtype_hint}}{{']' if vars.nullable_return}}:
          {{vars.comment|make_py_docstring|to_snake_case(args|map(attribute='name'))|indent}}
          pass
  bind: *var_bind_method
  hpp:
    header: *var_hpp_header
  cxx:
    include: *var_method_cxx_include
    header: *var_cxx_header
    footer: *var_cxx_footer
    body: |
      {
          {%- if cxx.namespace %}
          using namespace {{cxx.namespace}};
          {%- endif %}
          {%- set template_postfix = template_type_converters|format_list("{arg.python.target_type_name}", 'arg')|join if cxx.is_template else '' -%}
          {%- set comma = joiner(', ') %}
          m.def("{{vars.name|to_snake_case}}{{'_' + vars.overloading_postfix|to_snake_case if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix|replace('_', '')}}{{'_' + template_postfix|to_snake_case|lower if template_postfix}}"{%- if cxx.is_overloaded -%}
          , py::overload_cast<
          {%- for arg in args -%}
          {{comma()}}{{arg.type_info.cxx.type_name}}
          {%- endfor -%}>(&{{cxx.namespace}}::{{cxx.name}}{{', py::const_' if cxx.is_const}})
          {%- else -%}
          , &{{cxx.namespace}}::{{cxx.name}}
          {%- endif -%}
          {%- if cxx.is_template -%}
          <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
          {%- endif -%}
          {{', ' if args}}
          {%- set comma = joiner(', ') -%}
          {%- for arg in args -%}
          {{comma()}}py::arg("{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}")
          {%- if arg.default %}{{' = ' + arg.default if not (arg.is_enum and arg.default.split('::')|last in arg.type_info.vars.enum_excluded_cases)}}
          {%- endif -%}
          {%- endfor -%}{%- if return_type_info.cxx.type_name != 'void' and vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
      }
  pybind_module_hpp: *var_pybind_module_hpp
  pybind_module_cxx: *var_pybind_module
  pybind_package:
    body:

var_bind_getter: &var_bind_getter
  converter:
    unique_content: |
      {%- set converter = rconverter.python_to_pybind -%}
      {%- set snippet = converter.snippet('arg') -%}
      {%- if snippet -%}
      {{marker}}if type_hint == '{{rconverter.python.target_type_name}}':
          {{snippet|indent}}
          return {{converter.converted_name('arg')}}
      {%- endif -%}

var_getter_python_include: &var_getter_python_include
  unique_content: |
    {#- this should go to shared macro python_include-#}
    {%- macro gen_import(converter) -%}
    {%- if converter.python_include -%}
    {{marker}}{{converter.python_include.snippet(full_package=vars.full_package)}}
    {%- endif -%}
    {%- if converter.python -%}
    {%- for arg_converter in converter.python.args_converters -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {{gen_import(rconverter)}}

var_getter_cxx_include: &var_getter_cxx_include
  unique_content: |
    {#- this should go to shared macro cxx_include -#}
    {%- macro gen_include(converter) -%}
    {%- if converter.cxx_include -%}
    {{marker}}{{converter.cxx_include.snippet()}}
    {%- endif -%}
    {%- if converter.python -%}
    {%- for arg_converter in converter.python.args_converters -%}
    {{gen_include(arg_converter)}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {{gen_include(rconverter)}}

property_getter:
  python:
    include: *var_getter_python_include
    properties: |
      {%- if not cxx.is_public -%}
        {%- do Error.critical("{}.{} is not a public field. Make it public or remove cppbind API.".format(owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- set _name = vars.name|to_snake_case -%}
      {%- set rconverter = rconverter.python -%}
      {% set arg_type_hint = rconverter.get_target_type_name(full_package=vars.full_package) %}
      @property
      @bind
      def {{_name}}(self) -> {{'Optional[' if vars.nullable_return}}{{arg_type_hint}}{{']' if vars.nullable_return}}:
          {{vars.comment|make_py_docstring|indent}}
          pass
      {% if vars.action == 'gen_property_setter' %}
      @{{_name}}.setter
      @bind
      def {{_name}}(self, value: {{'Optional[' if vars.nullable_return}}{{arg_type_hint}}{{']' if vars.nullable_return}}):
          {{vars.comment|make_py_docstring|indent}}
          pass
      {%- endif %}
  bind: *var_bind_getter
  cxx:
    include: *var_getter_cxx_include
    body: |
      {%- set _name = vars.name|to_snake_case -%}
      {%- if vars.action == 'gen_property_setter' -%}
      {{owner_class.converter.python.target_type_name|decapitalize}}.def_readwrite("{{_name}}", &{{owner_class.cxx.type_name}}::{{cxx.name}}
      {%- if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif -%}
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive -%}
      {%- set args = [rconverter] %}
      {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%- if invalid_args -%}
      {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
      {%- endif -%}
      , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%- endif -%});
      {%- else -%}
      {{owner_class.converter.python.target_type_name|decapitalize}}.def_readonly("{{_name}}", &{{owner_class.cxx.type_name}}::{{cxx.name}}{%- if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
      {%- endif -%}

getter:
  python:
    include: *var_getter_python_include
    properties: |
      {%- do helper.validate_getter(cxx, vars, args, owner_class, setter|default(none)) -%}
      {%- do helper.validate_template_getter_setter(cxx, vars, owner_class, setter|default(none)) -%}
      {%- macro gen_name() -%}
      {%- if cxx.is_template -%}
      {%- for name in template_args_postfixes or [] %}
      {%- if name != None %}{{name}}{% else %}{{template_type_converters[loop.index - 1].custom.tname}}{% endif %}
      {%- endfor %}
      {%- else %}{{vars.name}}
      {%- endif -%}
      {%- endmacro -%}
      {%- set rconverter = rconverter.python %}
      {%- set arg_type_hint = rconverter.get_target_type_name(full_package=vars.full_package) %}
      @property
      @bind
      def {{gen_name()|to_snake_case}}(self) -> {{'Optional[' if vars.nullable_return}}{{arg_type_hint}}{{']' if vars.nullable_return}}:
          {{vars.comment|make_py_docstring|indent}}
          pass
      {%- if setter is defined %}
      {%- set incorrect_nullable_args = setter.vars.nullable_arg|reject('in', setter.args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
        {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), setter.owner_class.cxx.displayname, setter.cxx.displayname)) -%}
      {%- endif %}

      @{{gen_name()|to_snake_case}}.setter
      @bind
      def {{gen_name()|to_snake_case}}(self, value: {{'Optional[' if vars.nullable_return}}{{arg_type_hint}}{{']' if vars.nullable_return}}):
          {{vars.comment|make_py_docstring|indent}}
          pass
      {%- endif -%}
  bind: *var_bind_getter
  cxx:
    include: *var_getter_cxx_include
    body: |
      {%- macro gen_name() -%}
      {%- if cxx.is_template -%}
      {%- for name in template_args_postfixes or [] %}
      {%- if name != None %}{{name}}{% else %}{{template_type_converters[loop.index - 1].custom.tname}}{% endif %}
      {%- endfor %}
      {%- else %}{{vars.name}}
      {%- endif -%}
      {%- endmacro -%}
      {%- if cxx.is_template -%}
      {%- set template_args = '<' + template_choice.values()|format_list("{type}", 'type')|join(', ') + '>' %}
      {%- else %}
      {%- set template_args = '' %}
      {%- endif %}
      {%- if setter is defined %}
      {{owner_class.converter.python.target_type_name|decapitalize}}.def_property("{{gen_name()|to_snake_case}}", py::cpp_function(&{{owner_class.cxx.type_name}}::{{cxx.name}}{{template_args}}
      {%- if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %}), &{{owner_class.cxx.type_name}}::{{setter.cxx.name}}{{template_args}}
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive -%}
      {%- set args = [rconverter] %}
      {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%- if invalid_args -%}
      {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
      {%- endif -%}
      , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%- endif -%});
      {%- else %}
      {{owner_class.converter.python.target_type_name|decapitalize}}.def_property_readonly("{{gen_name()|to_snake_case}}", &{{owner_class.cxx.type_name}}::{{cxx.name}}{{template_args}}
      {%- if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
      {%- endif %}
