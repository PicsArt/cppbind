# Copyright (c) 2022 PicsArt, Inc.
# All rights reserved. Use of this source code is governed by a
# MIT-style license that can be found in the LICENSE file.

file:
  python_init:
    file_path: |
      {%- set outpath = vars.out_dir + pat_sep + vars.full_package|replace('.', pat_sep) -%}
      {{outpath if vars.action == 'gen_package' else path.dirname(outpath)}}{{pat_sep}}__init__.py
    scopes:
      - include
      - code_fragment
    content: |
      {{[banner_logo, vars.banner_comment]|make_py_docstring}}
      {{include}}
      {%- if code_fragment %}
      {{code_fragment}}
      {%- else %}
      {%- endif %}{{new_line}}
  python:
    file_path: |
      {{vars.out_dir + pat_sep + vars.full_package|replace('.', pat_sep)}}.py
    scopes:
      - body
      - base_type_include
      - type_hint_include
      - argument_default_value_include
    content: |
      {{[banner_logo, vars.banner_comment]|make_py_docstring}}
      {%- set future_import = 'from __future__ import annotations' %}
      {%- set typing_import = 'from typing import *' %}
      {%- set pybind_import = 'import ' + [vars.pybind_module, vars.package, vars.file]|join('.') + ' as pybind_' + vars.full_package.split('.')[-1] %}
      {%- if vars.helpers_package_prefix %}
      {%-   set bind_import = 'from ' + vars.helpers_package_prefix + '.cppbind_utils{} import *'.format(vars.file_postfix) %}
      {%- else %}
      {%-   set bind_import = 'from cppbind_utils{} import *'.format(vars.file_postfix) %}
      {%- endif %}
      {%- set helpers = helper_includes|format_list('from {} import *')|join_unique %}
      {{[future_import, typing_import, pybind_import, argument_default_value_include, base_type_include, helpers, bind_import]|join(new_line)|sort_python_code}}
      {%- set type_hint_includes = ((type_hint_include|string).split(new_line)|set - (base_type_include|string).split(new_line)|set - (argument_default_value_include|string).split(new_line)|set)|join(new_line) %}
      {%- if type_hint_includes %}

      if TYPE_CHECKING:
          {{type_hint_includes|sort_python_code|indent(4)}}
      {%- endif %}
      {{body}}{{new_line}}
  cxx:
    file_path: |
      {{vars.c_file_fullname}}
    scopes:
      - include
      - header
      - body
      - footer
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include <cxxabi.h>
      #include <memory>
      #include <pybind11/pybind11.h>
      #include <pybind11/stl.h>
      #include <pybind11/functional.h>

      {{include}}

      namespace py = pybind11;

      {{header}}
          {{body|string|indent(4)}}
      {{footer}}{{new_line}}
  hpp:
    file_path: |
      {{vars.h_file_fullname}}
    scopes:
      - header
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      {% set filename = vars.full_package|replace('.', '_') -%}
      #ifndef {{filename}}_hpp
      #define {{filename}}_hpp

      #include <pybind11/pybind11.h>

      namespace py = pybind11;

      {{header}}

      #endif{{new_line}}
  pybind_module_cxx:
    file_path: |
      {{vars.c_pybind_filename}}
    scopes:
      - body
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include <pybind11/pybind11.h>
      #include "{{path.relpath(vars.h_pybind_filename, vars.out_prj_dir)}}"

      namespace py = pybind11;

      void bind{{vars.pybind_module.replace('.', '_')|capitalize|to_camel_case}}(py::module& m) {
          {{body|string|indent}}
      }{{new_line}}
  pybind_module_hpp:
    file_path: |
      {{vars.h_pybind_filename}}
    scopes:
      - include
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      {% set package = vars.pybind_module.replace('.', '_') -%}
      #ifndef {{package}}_hpp
      #define {{package}}_hpp

      {{include}}
      #include <pybind11/pybind11.h>

      namespace py = pybind11;
      void bind{{vars.pybind_module.replace('.', '_')|capitalize|to_camel_case}}(py::module& m);

      #endif{{new_line}}
  pybind_package:
    file_path: |
      {{vars.pybind_module_filename}}
    gen: false
    scopes:
      - body
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}
      {% set packages = vars.pybind_module.split('.') %}
      #include <pybind11/pybind11.h>
      #include "{{path.relpath(vars.h_pybind_filename, vars.out_prj_dir)}}"

      namespace py = pybind11;
      PYBIND11_MODULE({{packages[0]}}, m) {
          py::module_ parent = m;
          {%- for p in packages[1:] %}
          {%- set parent_module = packages[loop.index - 1] %}
          py::module_ {{parent_module}} = parent.def_submodule("{{p}}", "{{p}}");
          parent = {{parent_module}};
          {%- endfor %}
          bind{{vars.pybind_module.replace('.', '_').split('_')|map('capitalize')|join}}(parent);
      }{{new_line}}
  bind: !include bind_snippet.yaml

var_pybind_module_cxx: &var_pybind_module
  body:
    unique_content: |
      {%- set package_name = vars.full_package|replace('.', '_') -%}
      {{marker}}py::module_ {{package_name}} = m.def_submodule("{{vars.package}}", "{{vars.package}}");
      {{marker}}py::module_ {{package_name}}_{{vars.file}} = {{package_name}}.def_submodule("{{vars.file}}", "{{vars.file}}");
      {{marker}}bind{{vars.full_package|replace('.', '_')|to_camel_case(capitalize=True)}}({{package_name}}_{{vars.file}});

package:
  python_init:
    code_fragment:
      unique_content: |
        {%- if vars.code_fragment -%}
        {{marker}}
        {{vars.code_fragment}}
        {%- endif -%}
    include:
      unique_content: |
        {{vars.include|format_list('from {} import *')|join_unique}}

var_pybind_module_hpp: &var_pybind_module_hpp
  include:
    unique_content: |
      #include "{{path.relpath(vars.h_file_fullname, vars.out_prj_dir)}}"

var_hpp_header: &var_hpp_header
  unique_content: |
    void bind{{vars.full_package|replace('.', '_')|to_camel_case(capitalize=True)}}(py::module& m);


var_cxx_header: &var_cxx_header
  unique_content: |
    void bind{{vars.full_package|replace('.', '_')|to_camel_case(capitalize=True)}}(py::module& m) {

var_cxx_footer: &var_cxx_footer
  unique_content: |
    } /* bind{{vars.full_package|replace('.', '_')|to_camel_case(capitalize=True)}} */


enum:
  python:
    body: |
      {%- if vars.header_code_fragment %}
      {{vars.header_code_fragment}}{{new_line}}
      {%- endif %}
      {% set m = 'pybind_' + vars.full_package.split('.')[-1] %}
      class {{vars.name}}({{vars.bases_list|join(', ')}}{{', ' if vars.bases_list}}metaclass=CppBindEnumMetaclass):
          {{vars.comment|make_py_docstring|indent}}
      {%- for case in cxx.enum_cases -%}
      {%-   if case.name not in vars.enum_excluded_cases -%}
      {%-     if case.comment %}
          {{case.comment|make_py_comment|indent}}
      {%-     endif %}
      {%-     set case_name = vars.enum_case_names.get(case.name, vars.enum_case_name_prefix + case.name) %}
          {{case_name}} = {{m}}.{{vars.name}}.{{case_name}}
      {%-   endif %}
      {%- endfor %}

          def __int__(self):
              return self.value
      {%- if vars.code_fragment %}

          {{vars.code_fragment|indent(4)}}
      {%- endif %}
      {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
      {%- endif %}
  python_init:
    include:
      unique_content: |
        from .{{vars.full_package.split('.')[-1]}} import {{vars.name}}
  cxx:
    header: *var_cxx_header
    footer: *var_cxx_footer
    body: |
      {
          {%- if cxx.namespace %}
          using namespace {{cxx.namespace}};
          {%- endif %}
          py::enum_<{{cxx.type_name}}>(m, "{{vars.name}}")
          {%- for case in cxx.enum_cases %}
          {%-   if case.name not in vars.enum_excluded_cases %}
              .value("{{vars.enum_case_names.get(case.name, vars.enum_case_name_prefix + case.name)}}", {{cxx.type_name}}::{{case.name}})
          {%-   endif %}
          {%- endfor -%};
      }
    include:
      unique_content:
        !concat
        - !include cxx_macros.yaml&includes
        - |
          {%- if vars.is_proj_type -%}
          {{marker}}#include "{{vars.prj_rel_file_name}}"
          {%- endif -%}
          {%- set includes = gen_user_defined_cxx_includes(vars) -%}
          {%- if includes -%}{{includes}}{%- endif -%}
  hpp:
    header: *var_hpp_header
  pybind_module_cxx: *var_pybind_module
  pybind_module_hpp: *var_pybind_module_hpp
  pybind_package:
    body:

var_class: &var_class
  python:
    base_type_include:
      unique_content:
        !concat
        - !include python_macros.yaml&includes.python
        - |
          {%- if cxx.is_abstract -%}
          {{marker}}from abc import abstractmethod
          {%- endif -%}
          {%- if vars.include -%}
          {{marker}}{{vars.include|select('match_regex', '^import\s.*$', '^from\s.*$')|join_unique}}
          {{marker}}{{vars.include|reject('match_regex', '^import\s.*$', '^from\s.*$')|format_list('from {} import *')|join_unique}}
          {%- endif -%}
          {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
          {%- for base in base_types_converters -%}
          {{gen_import(base)}}
          {%- endfor -%}
    body:
      scopes:
        - constructor_body
        - properties
        - body
      content:
        !concat
        - !include python_macros.yaml&special_functions.class.python
        - |
          {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
          {%-   do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
          {%- endif -%}
          {%- set ancestor_infos = cxx.ancestors|type_info(error=False)|reject('none')|selectattr('has_api')|list %}
          {%- if ancestor_infos|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
          {%-   do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
          {%- endif %}
          {%- if vars.header_code_fragment %}
          {{vars.header_code_fragment}}{{new_line}}
          {%- endif %}
          {%- set bases_specifiers = [] -%}
          {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
          {%- for base_type_converter in base_types_converters -%}
          {%-   do bases_specifiers.append(base_type_converter.python.get_target_type_name(full_package=vars.full_package)) -%}
          {%- endfor -%}
          {%- do bases_specifiers.extend(vars.bases_list) -%}
          {%- do bases_specifiers.append('metaclass=CppBindMetaclass') %}
          
          class {{get_type_converter(cxx.type).python.target_type_name}}({{bases_specifiers|join(', ')}}):
          {%- if vars.comment %}
              {{vars.comment|make_py_docstring|indent}}
          {%- endif %}
          {%- if not cxx.is_abstract %}
          {%-   if constructor_body %}
              {{constructor_body|string|indent}}
          {%-   endif %}
          {%- else %}
              @abstractmethod
              def __init__(self, *args, **kwargs):
                  pass
          {%- endif %}
          {%- if properties %}
              {{properties|string|indent}}
          {%- endif %}
          {%- if body %}
              {{body|string|indent}}
          {%- endif %}
          {%- if (not cxx.is_abstract, not constructor_body, not properties, not body)|all %}
              pass
          {%- endif %}
          {%- if not base_types_converters and repr_decl not in body|string %}
              {#- add __repr__ based on C++ type and id to be used for debugging purposes #}

              {{gen_repr_function()|indent(4)}}
          {%- endif %}
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {%- endif %}
  python_init:
    include:
      unique_content: |
        {%- set converter = get_type_converter(cxx.type) -%}
        {%- if not (converter.type_info.cxx.parent_type and get_type_info(converter.type_info.cxx.parent_type, error=False)) -%}{#- do not generate an import for nested type in __init__.py -#}
        from .{{vars.full_package.split('.')[-1]}} import {{converter.python.target_type_name}}
        {%- endif -%}
  cxx:
    header: *var_cxx_header
    footer: *var_cxx_footer
    include:
      unique_content:
        !concat
        - !include cxx_macros.yaml&includes
        - !include common_macros.yaml&includes.cxx
        - |
          {{gen_include(get_type_converter(cxx.type))}}
          {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
          {%- for base_converter in base_types_converters -%}
          {{gen_include(base_converter)}}
          {%- endfor -%}
          {%- set includes = gen_user_defined_cxx_includes(vars) -%}
          {%- if includes -%}{{includes}}{%- endif -%}
    body:
      scopes:
        - body
      content:
        !concat
        - !include python_macros.yaml&special_functions.class.pybind
        - |
          {%- set converter = get_type_converter(cxx.type) -%}
          {
              {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
              {%- if cxx.namespace %}
              using namespace {{cxx.namespace}};
              {%- endif %}
              {% set comma = joiner(', ') -%}
              {% set shared_ptr = 'std::shared_ptr<' + cxx.type_name + '>' -%}
              py::class_<{{cxx.type_name}} {%- if vars.shared_ref -%}
                                            , std::shared_ptr<{{cxx.type_name}}>
              {%- endif %}
              {%- if base_types_converters -%}
                                           , {% for base_type_converter in base_types_converters -%}
                                           {{comma()}}{{base_type_converter.type_info.cxx.type_name}}
              {%-   endfor -%}
              {%- endif %}> {{converter.python.target_type_name|decapitalize}}(m, "{{converter.python.target_type_name}}"{{', py::is_final()' if not cxx.is_open}});
              {{body|string|indent(4)}}
              {#- add __repr__ based on C++ type and id to be used for debugging purposes -#}
              {%- if not base_types_converters and 'def("__repr__"' not in body|string %}
              {{gen_repr_function()|indent(4)}}
              {%- endif %}  
          }
  hpp:
    header: *var_hpp_header
  pybind_module_cxx: *var_pybind_module
  pybind_module_hpp: *var_pybind_module_hpp
  pybind_package:
    body:

class: *var_class

interface: *var_class


var_bind_method: &var_bind_method
  converter:
    unique_content: |
      {%- for arg in cxx.args -%}
      {%-   set arg_converter = get_type_converter(arg.type) -%}
      {%-   set converter = arg_converter.python_to_pybind -%}
      {%-   set snippet = converter.snippet('arg') -%}
      {%-   if snippet -%}
      {{marker}}if type_hint == '{{arg_converter.python.target_type_name}}':
          {{snippet|indent}}
          return {{converter.converted_name('arg')}}
      {%-   endif -%}
      {%- endfor -%}

var_method_python_type_hint_include: &var_method_python_type_hint_include
  unique_content:
    !concat
    - !include python_macros.yaml&includes.python
    - |
      {%- for arg in cxx.args -%}
      {{gen_import(get_type_converter(arg.type))}}
      {%- endfor -%}
      {%- if cxx.result_type -%}
      {{gen_import(get_type_converter(cxx.result_type))}}
      {%- endif -%}

var_method_python_argument_default_value_include: &var_method_python_argument_default_value_include
  unique_content:
    !concat
    - !include python_macros.yaml&includes.python
    - |
      {%- for arg in cxx.args -%}
      {%-   if arg.default and arg.type.is_enum -%}
      {{gen_import(get_type_converter(arg.type))}}
      {%-   endif -%}
      {%- endfor -%}

var_method_cxx_include: &var_method_cxx_include
  unique_content:
    !concat
    - !include cxx_macros.yaml&includes
    - !include common_macros.yaml&includes.cxx
    - |
      {%- if vars.is_proj_type -%}
      {{marker}}#include "{{vars.prj_rel_file_name}}"
      {%- endif -%}
      {%- for arg in cxx.args -%}
      {{gen_include(get_type_converter(arg.type))}}
      {%- endfor -%}
      {%- if cxx.result_type -%}
      {{gen_include(get_type_converter(cxx.result_type))}}
      {%- endif -%}
      {%- set includes = gen_user_defined_cxx_includes(vars) -%}
      {%- if includes -%}{{includes}}{%- endif -%}

constructor:
  python:
    type_hint_include: *var_method_python_type_hint_include
    argument_default_value_include: *var_method_python_argument_default_value_include
    constructor_body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', cxx.args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%-   do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), cxx.parent.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {% set comma = joiner(', ') %}
      @bind
      def __init__(self{{', ' if cxx.args}}{%- for arg in cxx.args -%}
      {%-   set arg_converter = get_type_converter(arg.type).python %}
      {%-   set arg_type_hint = arg_converter.get_target_type_name(full_package=vars.full_package) -%}
                                       {{comma()}}{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}: {{'Optional['  if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{{arg_type_hint}}{{']' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
      {%-   if arg.default -%}
      {%-     if arg.type.is_enum %}
      {%-       set arg_type_info = get_type_info(arg.type) %}
      {%-       set enum_case_name = arg.default.split('::')|last %}
      {%-       if enum_case_name in arg_type_info.vars.enum_excluded_cases -%}
      {%-         do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} constructor argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.parent.displayname, cxx.displayname)) -%}
      {%-       else %} = {{arg_type_hint}}.{{arg_type_info.vars.enum_case_names.get(enum_case_name, arg_type_info.vars.enum_case_name_prefix + enum_case_name)}}
      {%-       endif -%}
      {%-     else -%}
      {%-       if arg.default_is_literal %} = {{arg.default|capitalize if arg.type.is_bool else arg.default}}
      {%-       else %} = None
      {%-       endif %}
      {%-     endif %}
      {%-   endif -%}
      {%- endfor %}):
          {{vars.comment|make_py_docstring|to_snake_case(cxx.args|map(attribute='name'))|indent}}
          pass
  bind: *var_bind_method
  cxx:
    include: *var_method_cxx_include
    body: |
      {%- set comma = joiner(', ') %}
      {{get_type_converter(cxx.parent.type).python.target_type_name|decapitalize}}.def(py::init{%- if cxx.kind_name in ('constructor',  'constructor_template') -%}
      <{%-  for arg in cxx.args -%}
                                                                                          {{comma()}}{{get_type_info(arg.type).cxx.type_name}}
      {%-   endfor -%}>()
      {%- else -%}
      {%-   if cxx.is_overloaded -%}
                                                                                          (py::overload_cast<
      {%-     for arg in cxx.args -%}
                                                                                          {{comma()}}{{get_type_info(arg.type).cxx.type_name}}
      {%-     endfor -%}>
      {%-   endif -%}(&{{cxx.parent.type_name}}::{{cxx.name}}){{')' if cxx.is_overloaded}}
      {%- endif -%}
                                                                                          {{', ' if cxx.args}}
      {%- set comma = joiner(', ') -%}
      {%- for arg in cxx.args -%}
                                                                                          {{comma()}}py::arg("{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}")
      {%-   if arg.default %}{{' = ' + arg.default if not (arg.type.is_enum and arg.default.split('::')|last in get_type_info(arg.type).vars.enum_excluded_cases)}}
      {%-   endif -%}
      {%- endfor -%}
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive -%}
      {%-   set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', cxx.args|length)|list %}
      {%-     if invalid_args -%}
      {%-       do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args|join(','))) -%}
      {%-     endif -%}
        , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%- endif %});



method:
  python:
    type_hint_include: *var_method_python_type_hint_include
    argument_default_value_include: *var_method_python_argument_default_value_include
    body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', cxx.args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%-   do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), cxx.parent.displayname, cxx.displayname) -%}
      {%- endif -%}
      {%- set _name = vars.name|to_snake_case %}
      {%- if cxx.name == vars.hash_method %}
      {%-   set _name = '__hash__' %}
      {%- elif cxx.name == vars.equals_method %}
      {%-   set _name = '__eq__' %}
      {%- elif cxx.name == vars.tostring_method %}
      {%-   set _name = '__str__' %}
      {%- endif %}
      {%- set comma = joiner(', ') -%}
      {%- if cxx.is_static %}
      @classmethod
      {%- endif %}
      {%- set rconverter = get_type_converter(cxx.result_type).python %}
      {%- set comment = vars.comment|to_snake_case(cxx.args|map(attribute='name')) %}
      @bind
      def {{_name}}({{'self' if not cxx.is_static else 'cls'}}{{', ' if cxx.args}}
      {%- set rtype_hint = rconverter.get_target_type_name(full_package=vars.full_package) -%}
      {%- for arg in cxx.args -%}
      {%-   set arg_converter = get_type_converter(arg.type).python %}
      {%-   set arg_type_hint = arg_converter.get_target_type_name(full_package=vars.full_package) -%}
                                                          {{comma()}}{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}: {{'Optional['  if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{{arg_type_hint}}{{']' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
      {%-   if arg.default -%}
      {%-     if arg.type.is_enum %}
      {%-       set arg_type_info = get_type_info(arg.type) %}
      {%-       set enum_case_name = arg.default.split('::')|last %}
      {%-       if enum_case_name in arg_type_info.vars.enum_excluded_cases -%}
      {%-         do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.parent.displayname, cxx.displayname)) -%}
      {%-       else %} = {{arg_type_hint}}.{{arg_type_info.vars.enum_case_names.get(enum_case_name, arg_type_info.vars.enum_case_name_prefix + enum_case_name)}}
      {%-       endif -%}
      {%-     else -%}
      {%-       if arg.default_is_literal %} = {{arg.default|capitalize if arg.type.is_bool else arg.default}}
      {%-       else %} = None
      {%-       endif %}
      {%-     endif %}
      {%-   endif -%}
      {%- endfor %}) -> {{'Optional[' if vars.nullable_return}}{{rtype_hint}}{{']' if vars.nullable_return}}:
          {{comment|make_py_docstring|indent}}
          pass

      {%- set setter_var_name = 'value' -%}
      {%- if vars.is_operator and vars.name == '__getitem__' and not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference %}

      @bind
      def __setitem__({{'self' if not cxx.is_static else 'cls'}}{{', ' if cxx.args}}
      {%-   set rtype_hint = rconverter.get_target_type_name(full_package=vars.full_package) -%}
      {%-   for arg in cxx.args -%}
      {%-     set arg_converter = get_type_converter(arg.type).python %}
      {%-     set arg_type_hint = arg_converter.get_target_type_name(full_package=vars.full_package) -%}
                                                          {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}: {{arg_type_hint}}{{comma()}}{{setter_var_name}}: {{rtype_hint}}
      {%-   endfor %}):
          {{comment|make_py_docstring|indent}}
          pass
      {%- endif %}

  bind: *var_bind_method
  cxx:
    include: *var_method_cxx_include
    body:
      !concat
      - !include python_macros.yaml&templates
      - |
        {%- set _name = vars.name|to_snake_case %}
        {%- if cxx.name == vars.hash_method %}
        {%-   set _name = '__hash__' %}
        {%- elif cxx.name == vars.equals_method %}
        {%-   set _name = '__eq__' %}
        {%- elif cxx.name == vars.tostring_method %}
        {%-   set _name = '__str__' %}
        {%- endif %}
        {%- set comma = joiner(', ') -%}
        {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {{parent_class_converter.python.target_type_name|decapitalize}}.def{{'_static' if cxx.is_static }}("{{_name}}"{%- if cxx.is_overloaded -%}
        , py::overload_cast<
        {%-   for arg in cxx.args -%}
        {{comma()}}{{get_type_info(arg.type).cxx.type_name}}
        {%-   endfor -%}>(&{{cxx.parent.type_name}}::{{cxx.name}}{{', py::const_' if cxx.is_const}})
        {%- else -%}
        , &{{cxx.parent.type_name}}::{{cxx.name}}
        {%- endif -%}
        {%- if cxx.is_template -%}
        {{gen_template_instantiation(cxx)}}
        {%- endif -%}
        {{', ' if cxx.args}}
        {%- set comma = joiner(', ') -%}
        {%- for arg in cxx.args -%}
        {{comma()}}py::arg("{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}")
        {%-   if arg.default %}{{' = ' + arg.default if not (arg.type.is_enum and arg.default.split('::')|last in get_type_info(arg.type).vars.enum_excluded_cases)}}
        {%-   endif -%}
        {%- endfor -%}
        {#- This should go to shared macro -#}
        {%- if vars.keep_alive and not (vars.is_operator and vars.name == '__getitem__') -%}
        {%-   set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', cxx.args|length)|list %}
        {%-   if cxx.is_static -%}
        {%-     do Error.critical('Cannot apply keep alive policy for a static member function: {}.{}'.format(name, owner)) -%}
        {%-   endif -%}
        {%-   if invalid_args -%}
        {%-     do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args|join(','))) -%}
        {%-   endif -%}
        , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
        {%- endif -%}
        {%- if cxx.result_type.type_name != 'void' and vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
        {%-   set setter_var_name = 'value' -%}
        {%-   if vars.is_operator and vars.name == '__getitem__' and not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference %}
        {{parent_class_converter.python.target_type_name|decapitalize}}.def("__setitem__", []({{cxx.parent.type_name}}& self,{%- for arg in cxx.args %} {{get_type_info(arg.type).cxx.type_name}} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor -%}, {{cxx.result_type.resolved_type.unqualified_type_name}} {{setter_var_name}}){ self[{{cxx.args[0].name|to_snake_case}}] = {{setter_var_name}}; }
        {#-   This should go to shared macro -#}
        {%-   if vars.keep_alive -%}
        {%-     set args = cxx.args + [get_type_converter(cxx.result_type)] %}
        {%-     set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
        {%-     if invalid_args -%}
        {%-       do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args|join(','))) -%}
        {%-     endif -%}
        , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
        {%-   endif -%});
        {%- endif %}


function:
  python_init:
    include:
      unique_content:
        !concat
        - !include python_macros.yaml&templates
        - !include python_macros.yaml&overloading_postfix
        - |
          from .{{vars.full_package.split('.')[-1]}} import {{vars.name|to_snake_case}}{{get_overloading_postfix(vars)}}{{get_python_template_postfix()}}
  python:
    type_hint_include: *var_method_python_type_hint_include
    argument_default_value_include: *var_method_python_argument_default_value_include
    body:
      !concat
      - !include python_macros.yaml&templates
      - !include python_macros.yaml&overloading_postfix
      - |
        {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', cxx.args|map(attribute='name'))|list %}
        {%- if incorrect_nullable_args %}
        {%-   do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), cxx.parent.displayname, cxx.displayname) %}
        {%- endif %}
        {%- set comma = joiner(', ') %}
        {% set rconverter = get_type_converter(cxx.result_type).python %}
        @bind
        def {{vars.name|to_snake_case}}{{get_overloading_postfix(vars)}}{{get_python_template_postfix()}}(
        {%- set rtype_hint = rconverter.get_target_type_name(full_package=vars.full_package) -%}
        {%- for arg in cxx.args -%}
        {%-   set arg_converter = get_type_converter(arg.type).python %}
        {%-   set arg_type_hint = arg_converter.get_target_type_name(full_package=vars.full_package) -%}
                                        {{comma()}}{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}: {{'Optional['  if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{{arg_type_hint}}{{']' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
        {%-   if arg.default -%}
        {%-     if arg.type.is_enum %}
        {%-       set arg_type_info = get_type_info(arg.type) %}
        {%-       set enum_case_name = arg.default.split('::')|last %}
        {%-       if enum_case_name in arg_type_info.vars.enum_excluded_cases -%}
        {%-         do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.parent.displayname, cxx.displayname)) -%}
        {%-       else %} = {{arg_type_hint}}.{{arg_type_info.vars.enum_case_names.get(enum_case_name, arg_type_info.vars.enum_case_name_prefix + enum_case_name)}}
        {%-       endif -%}
        {%-     else -%}
        {%-       if arg.default_is_literal %} = {{arg.default|capitalize if arg.type.is_bool else arg.default}}
        {%-       else %} = None
        {%-       endif %}
        {%-     endif %}
        {%-   endif -%}
        {%- endfor %}) -> {{'Optional[' if vars.nullable_return}}{{rtype_hint}}{{']' if vars.nullable_return}}:
            {{vars.comment|make_py_docstring|to_snake_case(cxx.args|map(attribute='name'))|indent}}
            pass
  bind: *var_bind_method
  hpp:
    header: *var_hpp_header
  cxx:
    include: *var_method_cxx_include
    header: *var_cxx_header
    footer: *var_cxx_footer
    body:
      !concat
      - !include python_macros.yaml&templates
      - !include common_macros.yaml&templates
      - !include python_macros.yaml&overloading_postfix
      - |
        {
            {%- if cxx.namespace %}
            using namespace {{cxx.namespace}};
            {%- endif %}
            {%- set comma = joiner(', ') %}
            m.def("{{vars.name|to_snake_case}}{{get_overloading_postfix(vars)}}{{get_python_template_postfix()}}"{%- if cxx.is_overloaded -%}
            , py::overload_cast<
            {%-   for arg in cxx.args -%}
            {{comma()}}{{get_type_info(arg.type).cxx.type_name}}
            {%-   endfor -%}>(&{{cxx.namespace}}::{{cxx.name}}{{', py::const_' if cxx.is_const}})
            {%- else -%}
            , &{{cxx.namespace}}::{{cxx.name}}
            {%- endif -%}
            {%- if cxx.is_template -%}
            {{gen_template_instantiation(cxx)}}
            {%- endif -%}
            {{', ' if cxx.args}}
            {%- set comma = joiner(', ') -%}
            {%- for arg in cxx.args -%}
            {{comma()}}py::arg("{{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}")
            {%-   if arg.default %}{{' = ' + arg.default if not (arg.type.is_enum and arg.default.split('::')|last in get_type_info(arg.type).vars.enum_excluded_cases)}}
            {%-   endif -%}
            {%- endfor -%}{%- if cxx.result_type.type_name != 'void' and vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
        }
  pybind_module_hpp: *var_pybind_module_hpp
  pybind_module_cxx: *var_pybind_module
  pybind_package:
    body:

var_bind_getter: &var_bind_getter
  converter:
    unique_content: |
      {%- set rconverter = get_type_converter(cxx.result_type) -%}
      {%- set snippet = rconverter.python_to_pybind.snippet('arg') -%}
      {%- if snippet -%}
      {{marker}}if type_hint == '{{rconverter.python.target_type_name}}':
          {{snippet|indent}}
          return {{rconverter.python_to_pybind.converted_name('arg')}}
      {%- endif -%}

var_getter_python_type_hint_include: &var_getter_python_type_hint_include
  unique_content:
    !concat
    - !include python_macros.yaml&includes.python
    - |
      {{gen_import(get_type_converter(cxx.result_type))}}

var_getter_cxx_include: &var_getter_cxx_include
  unique_content:
    !concat
    - !include common_macros.yaml&includes.cxx
    - |
      {{gen_include(get_type_converter(cxx.result_type))}}

var_property_getter_setter: &var_property_getter_setter
  python:
    type_hint_include: *var_getter_python_type_hint_include
    properties: |
      {%- if not cxx.is_public -%}
      {%-   do Error.critical("{}.{} is not a public field. Make it public or remove cppbind API.".format(cxx.parent.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- set _name = vars.name|to_snake_case -%}
      {%- set rconverter = get_type_converter(cxx.result_type).python -%}
      {% set arg_type_hint = rconverter.get_target_type_name(full_package=vars.full_package) %}
      @property
      @bind
      def {{_name}}(self) -> {{'Optional[' if vars.nullable_return}}{{arg_type_hint}}{{']' if vars.nullable_return}}:
          {{vars.comment|make_py_docstring|indent}}
          pass
      {% if vars.action == 'gen_property_setter' %}
      @{{_name}}.setter
      @bind
      def {{_name}}(self, value: {{'Optional[' if vars.nullable_return}}{{arg_type_hint}}{{']' if vars.nullable_return}}):
          {{vars.comment|make_py_docstring|indent}}
          pass
      {%- endif %}
  bind: *var_bind_getter
  cxx:
    include: *var_getter_cxx_include
    body: |
      {%- set _name = vars.name|to_snake_case -%}
      {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
      {%- if vars.action == 'gen_property_setter' -%}
      {{parent_class_converter.python.target_type_name|decapitalize}}.def_readwrite("{{_name}}", &{{cxx.parent.type_name}}::{{cxx.name}}
      {%-   if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif -%}
      {#-     This should go to shared macro -#}
      {%-     if vars.keep_alive -%}
      {%-       set args = [get_type_converter(cxx.result_type)] %}
      {%-       set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%-       if invalid_args -%}
      {%-         do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args|join(','))) -%}
      {%-       endif -%}
      , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%-     endif -%});
      {%-   else -%}
      {{parent_class_converter.python.target_type_name|decapitalize}}.def_readonly("{{_name}}", &{{cxx.parent.type_name}}::{{cxx.name}}{%- if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
      {%- endif -%}

property_getter: *var_property_getter_setter

property_setter: *var_property_getter_setter

getter:
  python:
    type_hint_include: *var_getter_python_type_hint_include
    properties:
      !concat
      - !include common_macros.yaml&templates
      - |
        {%- do cppbind_helper.validate_getter(cxx, vars, setter|default(none)) -%}
        {%- do cppbind_helper.validate_template_getter_setter(cxx, vars, setter|default(none)) -%}
        {%- macro gen_name() -%}
        {%-   if cxx.is_template -%}
        {{get_template_getter_name(cxx,  template_args_postfixes)}}
        {%-   else %}{{vars.name}}
        {%-   endif -%}
        {%- endmacro -%}
        {%- set rconverter = get_type_converter(cxx.result_type).python %}
        {%- set arg_type_hint = rconverter.get_target_type_name(full_package=vars.full_package) %}
        @property
        @bind
        def {{gen_name()|to_snake_case}}(self) -> {{'Optional[' if vars.nullable_return}}{{arg_type_hint}}{{']' if vars.nullable_return}}:
            {{vars.comment|make_py_docstring|indent}}
            pass
        {%- if setter is defined %}
        {%-   set incorrect_nullable_args = setter.vars.nullable_arg|reject('in', setter.cxx.args|map(attribute='name'))|list -%}
        {%-   if incorrect_nullable_args -%}
        {%-     do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), setter.cxx.parent.displayname, setter.cxx.displayname)) -%}
        {%-   endif %}
        
        @{{gen_name()|to_snake_case}}.setter
        @bind
        def {{gen_name()|to_snake_case}}(self, value: {{'Optional[' if vars.nullable_return}}{{arg_type_hint}}{{']' if vars.nullable_return}}):
            {{vars.comment|make_py_docstring|indent}}
            pass
        {%- endif -%}
  bind: *var_bind_getter
  cxx:
    include: *var_getter_cxx_include
    body:
      !concat
      - !include common_macros.yaml&templates
      - |
        {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {%- macro gen_name() -%}
        {%-   if cxx.is_template -%}
        {{get_template_getter_name(cxx,  template_args_postfixes)}}
        {%-   else %}{{vars.name}}
        {%-   endif -%}
        {%- endmacro -%}
        {%- if setter is defined %}
        {{parent_class_converter.python.target_type_name|decapitalize}}.def_property("{{gen_name()|to_snake_case}}", py::cpp_function(&{{cxx.parent.type_name}}::{{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}
        {%-   if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %}), &{{cxx.parent.type_name}}::{{setter.cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}
        {#-   This should go to shared macro -#}
        {%-   if vars.keep_alive -%}
        {%-     set args = [get_type_converter(cxx.result_type)] %}
        {%-     set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
        {%-     if invalid_args -%}
        {%-       do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args|join(','))) -%}
        {%-     endif -%}
        , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
        {%-   endif -%});
        {%- else %}
        {{parent_class_converter.python.target_type_name|decapitalize}}.def_property_readonly("{{gen_name()|to_snake_case}}", &{{cxx.parent.type_name}}::{{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}
        {%-     if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
        {%- endif %}
