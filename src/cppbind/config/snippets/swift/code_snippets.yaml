# Copyright (c) 2022 PicsArt, Inc.
# All rights reserved. Use of this source code is governed by a
# MIT-style license that can be found in the LICENSE file.

file:
  swift:
    file_path: |
      {{vars.file_fullname}}
    scopes:
      - include
      - body
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      {{[include, 'import Foundation', 'import ' + vars.c_wrapper_lib_name]|sort_snippets(cmp=helper.imports_comparator)|join(new_line)}}

      {{body}}
  cc:
    file_path: |
      {{vars.c_file_fullname}}
    scopes:
      - namespace
      - body
      - include
      - glob_decl
      - glob_def
      - forward_decl
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include <iostream>
      #include <stdlib.h>
      #include <string.h>
      #include <cxxabi.h>
      #include <memory>
      #include <type_traits>
      #include "{{path.relpath(vars.h_file_fullname, vars.out_prj_dir)}}"
      {{include}}
      {%- if glob_decl %}

      {{glob_decl}}
      {%- endif %}
      {%- if glob_def %}

      {{glob_def}}
      {%- endif %}
      {%- if forward_decl %}

      {{forward_decl}}
      {%- endif %}
      {{namespace}}

      {{body}}{{new_line}}
  ch:
    file_path: |
      {{vars.h_file_fullname}}
    scopes:
      - body
      - include
    content: |
      {%- set file_rel_path_id = path.relpath(vars.h_file_fullname, vars.out_prj_dir)|replace(pat_sep, '_')|replace('.', '_')|upper -%}
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #ifndef _{{file_rel_path_id}}_
      #define _{{file_rel_path_id}}_
      {% set include_format = '#include <{}>' if vars.is_c_wrapper_external else '#include "{}"' %}
      {{cxx_helper_includes|format_list(include_format)|join(new_line)}}
      {{include}}
      #include <stdbool.h>

      #if __cplusplus
      extern "C" {
      #endif
          {{body | string | indent}}
      #if __cplusplus
      }
      #endif
      #endif /* ifndef _{{file_rel_path_id}}_ */{{new_line}}

package:

enum:
  swift:
    body: |
      {%- if vars.header_code_fragment -%}
      {{vars.header_code_fragment}}{{new_line}}
      {% endif -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      public enum {{vars.name}}: CInt{{', ' if vars.bases_list}}{{vars.bases_list|join(', ')}} {
        {%- for case in enum_cases -%}
        {%- if case.name not in vars.enum_excluded_cases -%}
        {%- if case.comment %}
        {{case.comment|make_doxygen_comment|indent(2)}}
        {%- endif %}
        case {{vars.enum_case_names.get(case.name, vars.enum_case_name_prefix + case.name)}} = {{case.value}}
        {%- endif %}
        {%- endfor %}
        {%- if vars.code_fragment %}

        {{vars.code_fragment|indent(2)}}
        {%- endif %}
      }
      {%- if vars.footer_code_fragment -%}
      {{new_line}}{{vars.footer_code_fragment}}
      {%- endif %}{{new_line}}

var_class_cxx_include: &var_class_cxx_include
    unique_content:
      !concat
      - !include cxx_macros.yaml&cxx_include
      - |
       {%- macro collect_includes(converter, includes) -%}
        {%- if converter.cxx_include -%}
        {%- do includes.append(converter.cxx_include.snippet()) -%}
        {%- endif -%}
        {%- for arg_converter in converter.swift.args_converters -%}
        {%- do collect_includes(arg_converter, includes) -%}
        {%- endfor -%}
        {%- endmacro -%}
        {%- macro collect_desc_includes(converter, desc_includes) -%}
        {%- if converter.swift.vars and converter.swift.vars.descendants is defined -%}
        {%- for descendant in (converter.swift.vars.descendants if converter.swift.vars.descendants is not none else converter.swift.descendants) -%}
        {%- do collect_includes(make_type_converter(descendant), desc_includes) -%}
        {%- endfor -%}
        {%- endif -%}
        {%- for arg_converter in converter.swift.args_converters -%}
        {%- do collect_desc_includes(arg_converter, desc_includes) -%}
        {%- endfor -%}
        {%- endmacro -%}
        {%- set includes = [] -%}
        {%- do collect_includes(converter, includes) -%}
        {%- do collect_desc_includes(converter, includes) -%}
        {%- if includes -%}
        {{includes|join(marker)}}
        {%- endif -%}
        {%- set includes = gen_cxx_include(vars) -%}
        {%- if includes -%}{{includes}}{%- endif -%}

var_class_cxx_glob_decl: &var_class_cxx_glob_decl
    unique_content: |
      {#- this should go to shared macro -#}
      {%- macro collect_include_type_infos(type_info, include_type_infos) -%}
      {%- if type_info.vars -%}
      {%- do include_type_infos.append(type_info) -%}
      {%- endif -%}
      {%- for arg_type_info in type_info.arg_types_infos -%}
          {%- do collect_include_type_infos(arg_type_info, include_type_infos) -%}
      {%- endfor -%}
      {%- endmacro -%}
      {%- macro collect_desc_include_type_infos(type_info, desc_include_type_infos) -%}
      {%- if type_info.vars and type_info.vars.descendants is defined -%}
      {%- for descendant in (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) -%}
          {%- do collect_include_type_infos(get_type_info(descendant), desc_include_type_infos) -%}
      {%- endfor -%}
      {%- endif -%}
      {%- for arg_type_info in type_info.arg_types_infos -%}
          {%- do collect_desc_include_type_infos(arg_type_info, desc_include_type_infos) -%}
      {%- endfor -%}
      {%- endmacro -%}
      {%- set desc_include_type_infos = [] -%}
      {%- do collect_desc_include_type_infos(type_info, desc_include_type_infos) -%}
      {%- for desc_type_info in desc_include_type_infos -%}
      {%- if desc_type_info.vars.c_file_fullname != vars.c_file_fullname -%}
      {{marker}}{{'extern const char* ' + make_type_converter(desc_type_info.cxx.type_name).cxx_type_name_global.snippet() + ';'}}
      {%- endif -%}
      {%- endfor -%}

var_class_swift_include: &var_class_swift_include
  unique_content: |
    {{marker if vars.include}}{{vars.include|format_list("import {}")|join_unique}}
    {%- macro collect_import_converters(converter, import_converters, gen_for_impl=false) -%}
    {%- if converter.swift.parent_type_info -%}
    {#- in case of nested cases we don't need `gen_for_impl` anymore, so we don't pass it deeper -#}
    {%- do collect_import_converters(make_type_converter(converter.swift.parent_type_info.cxx.type_name), import_converters) -%}
    {%- else %}
    {%- do import_converters.append((converter, gen_for_impl)) -%}
    {%- endif -%}
    {%- for arg_converter in converter.swift.args_converters -%}
    {%- do collect_import_converters(arg_converter, import_converters, gen_for_impl) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- macro collect_desc_import_converters(converter, desc_import_converters) -%}
    {%- if converter.swift.vars and converter.swift.vars.descendants is defined -%}
    {%- for descendant in (converter.swift.vars.descendants if converter.swift.vars.descendants is not none else converter.swift.descendants) -%}
    {%- do collect_import_converters(make_type_converter(descendant), desc_import_converters, gen_for_impl=true) -%}
    {%- endfor -%}
    {%- endif -%}
    {%- for arg_converter in converter.swift.args_converters -%}
    {%- do collect_desc_import_converters(arg_converter, desc_import_converters) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- set import_converters = [] -%}
    {%- for base in base_types_converters -%}
    {%- do collect_import_converters(base, import_converters) -%}
    {%- endfor -%}
    {%- set desc_import_converters = [] -%}
    {%- do collect_desc_import_converters(converter, desc_import_converters) -%}
    {%- for import_converter, _ in import_converters -%}
    {%- if import_converter.swift_include -%}
    {{marker}}{{import_converter.swift_include.snippet(full_package=vars.full_package)}}
    {%- endif -%}
    {%- endfor -%}
    {%- for desc_import_converter, gen_for_impl in desc_import_converters -%}
    {#- we need to import implementation classes for object construction (`gen_for_impl` is for tracking nested types) -#}
    {%- if desc_import_converter.swift_include -%}
    {{marker}}{{desc_import_converter.swift_include.snippet(interface_class=(gen_for_impl and desc_import_converter.swift.vars.action=='gen_interface'))}}
    {%- endif -%}
    {%- endfor -%}

class:
  swift:
    include: *var_class_swift_include
    body:
      scopes:
        - head
        - properties
        - body
        - private_external
      content:
        !concat
        - !include swift_macros.yaml&exception_handling
        - !include swift_macros.yaml&special_functions.declarations
        - |
          {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
          {%- do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
          {%- endif -%}
          {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
          {%- if vars.header_code_fragment -%}
          {{vars.header_code_fragment}}{{new_line}}
          {% endif -%}
          {%- set base_interfaces = base_types_converters|map(attribute='swift')|selectattr('vars.action', 'equalto', 'gen_interface')|map(attribute='target_type_name')|list -%}
          {%- set base_classes = base_types_converters|map(attribute='swift')|rejectattr('vars.action', 'equalto', 'gen_interface')|map(attribute='target_type_name')|list -%}
          {%- set bases_specifiers =  base_classes + base_interfaces + vars.bases_list -%}
          {%- if base_types_converters|map(attribute='swift')|rejectattr('vars.action', 'equalto', 'gen_interface')|list|length > 1 %}
          {%- do Error.critical(cxx.type_name + ' has more than 1 non abstract base type.') %}
          {%- endif %}
          {%- if ancestors|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
          {%- do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
          {%- endif %}
          {%- if vars.comment -%}
          {{vars.comment|make_doxygen_comment}}
          {% endif -%}
          {%- set hash_fns = (body|string).split(new_line)|select('contains', hash_decl)|list -%}
          {%- set is_hashable = hash_fns|length == 1 and hash_fns|select('contains', 'override')|list|length == 0 -%}
          {%- set string_fns = (body|string).split(new_line)|select('contains', tostring_decl)|list -%}
          {%- set is_string_convertible = string_fns|length == 1 and string_fns|select('contains', 'override')|list|length == 0 -%}
          {%- set class_name = converter.swift.get_target_type_name(definition=True) -%}
          {#- NOTE: in case of equatable currently we cannot identify whether the base class has defined it or not so incorrect comformance will be generated for overriden equals#}
          {%- set is_equatable = equals_decl|replace('Self', class_name) in body|string -%}
          {%- if is_hashable -%}
          {%- do bases_specifiers.append('Hashable') -%}
          {%- endif -%}
          {%- if is_equatable and not is_hashable-%}
          {%- do bases_specifiers.append('Equatable') -%}
          {%- endif -%}
          {%- if is_string_convertible %}
          {%- do bases_specifiers.append('CustomStringConvertible') -%}
          {%- endif -%}
          {%- if vars.is_exception and not ancestors|selectattr('vars.is_exception', 'equalto', True)|list -%}
          {%- do bases_specifiers.append('Error') -%}
          {%- endif -%}
          public class {{class_name}}{{': ' + bases_specifiers|join(', ') if bases_specifiers}} {
            {%- if not base_types_infos|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}

            /**
             * An internal property to keep a reference to the original C++ object.
             * It is intended to be used by the generated code.
             */
            public let cself: {{converter.sc.target_type_name}}

            /**
             * An internal property to keep track whether Swift is responsible for deallocating the underlying C++ object or not.
             * It is intended to be used by the generated code.
             */
            public let owner: Bool
            private var refs: [Any]

            /// internal main initializer
            internal required init(_ _cself: {{converter.sc.target_type_name}}, _ _owner: Bool = false) {
              self.cself = _cself
              self.owner = _owner
              self.refs = []
            }

            deinit {
              release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.target_type_name|replace('.',  '_')}}(cself, owner)
            }

            /**
             * An internal method to bind the lifetimes of the current and another object.
             * It is intended to be used by the generated code.
             */
            public func keepCppBindReference(_ object: Any) {
              self.refs.append(object)
            }{{new_line}}
            {%- else %}
            /// internal main initializer
            internal required init(_ _cself: CppBindCObject, _ _owner: Bool = false) {
              super.init(_cself, _owner)
            }{{new_line}}
            {%- endif %}
            {%- if descendants %}
            /// internal dummy initializer to prevent automatic initializer inheritance
            internal init(_cself: {{converter.sc.target_type_name}}, _self: {{converter.swift.target_type_name}}) {
              fatalError("A dummy internal initializer should not be called.")
            }{{new_line}}
            {%- endif %}
            {%- if head %}
            {{head|string|indent(2)}}
            {%- endif %}
            {%- if properties %}
            {{properties|string|indent(2)}}
            {%- endif %}
            {%- if body %}
            {{body|string|indent(2)}}
            {%- endif %}
            /**
             * An internal property to keep an information about the underlying C++ object type.
             * It is intended to be used by the generated code.
             */
            {{'override ' if base_classes}}class var cppbindCxxTypeName : String { return "{{cxx.unqualified_canonical_type_name}}" }
            {%- if (vars.descendants if vars.descendants is not none else descendants) and cxx.is_polymorphic %}
            {%- set polymorphic_base = base_types_converters|map(attribute='swift')|selectattr('vars.action', 'equalto', 'gen_class')|selectattr('cxx.is_polymorphic', 'equalto', true)|first|default(none) %}

            /**
             * An internal method to create a Swift object from a C++ object.
             * It is intended to be used by the generated code.
             */
            {{'override ' if polymorphic_base and (polymorphic_base.vars.descendants if polymorphic_base.vars.descendants is not none else polymorphic_base.descendants)}}class func cppbindConstructObject(_ cppbindObj: CppBindCObject, _ owner: Bool = false) -> {{converter.swift.target_type_name}} {
              {{converter.swift_obj_construction.snippet(name="cppbindObj")|indent(4)}}
            }
            {%- endif %}
          }
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {%- endif %}{{new_line}}
  cc:
    include: *var_class_cxx_include
    glob_decl: *var_class_cxx_glob_decl
    glob_def:
      unique_content: |
        const char* {{converter.cxx_type_name_global.snippet()}} = "{{cxx.unqualified_canonical_type_name}}";
    namespace:
      unique_content: |
        {%- if cxx.namespace %}
        using namespace {{cxx.namespace}};
        {%- endif %}
    body:
      content: |
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
        {%- set has_no_base_cls = not base_types_infos|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}
        {%- if has_no_base_cls -%}
        void release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.target_type_name|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner) {
            {%- if not vars.shared_ref and cxx.is_polymorphic and (vars.descendants if vars.descendants is not none else descendants) %}
            static_assert(std::has_virtual_destructor<{{cxx.unqualified_resolved_type_name}}>::value, {{'"{} type must have virtual destructor"'.format(cxx.unqualified_resolved_type_name)}});
            {%- endif %}
            if (owner) {
                {#- here is used almost the same logic as for c_to_cxx section of Object/std::shared_ptr type converter (instead of constructing target value we delete it here) -#}
                {%- set descendants = vars.descendants if vars.descendants is not none else descendants %}
                {%- if descendants %}
                if (strcmp(cself.type, {{converter.cxx_type_name_global.snippet()}}) == 0)
                {%- if vars.shared_ref %}
                    delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(cself.ptr);
                {%- else %}
                    delete static_cast<{{cxx.unqualified_resolved_type_name}}*>(cself.ptr);
                {%- endif %}
                {%- for descendant in descendants %}
                else if (strcmp(cself.type, {{make_type_converter(descendant).cxx_type_name_global.snippet()}}) == 0)
                {%- if vars.shared_ref %}
                    delete static_cast<std::shared_ptr<{{descendant}}>*>(cself.ptr);
                {%- else %}
                    delete static_cast<{{descendant}}*>(cself.ptr);
                {%- endif %}
                {%- endfor %}
                else {
                    std::cerr << "Unexpected object type: " << cself.type << std::endl;
                    exit(1);
                }
                {%- else -%}
                {%- if vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(cself.ptr);
                {%- else %}
                delete static_cast<{{cxx.unqualified_resolved_type_name}}*>(cself.ptr);
                {%- endif %}
                {%- endif %}
            }
            free(cself.type);
        }
        {% endif -%}
        {#- object recover function is generated for all classes (not only for bases with reusing them for derived types) since the performance would be lowered in case of superbases with deep hierarchy -#}
        {%- if descendants -%}
        {%- set this_converter = make_type_converter('std::shared_ptr<' + cxx.type_name + '>') if vars.shared_ref else converter -%}
        {{new_line if has_no_base_cls}}{{this_converter.cxx_obj_recover_func_decl.snippet(name="cppbindObj")}} {
            {{this_converter.cxx_obj_recover.snippet(name="cppbindObj")|indent(4)}}
        }
        {% endif -%}
  ch:
    body:
      content: |
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
        {%- if not base_types_infos|rejectattr('vars.action', 'equalto', 'gen_interface')|list -%}
        void release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.target_type_name|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner);
        {%- endif -%}


interface:
  swift:
    include: *var_class_swift_include
    body:
      scopes:
        - interface_head
        - interface_properties
        - interface_body
        - head
        - properties
        - body
      content: |
        {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
        {%- do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
        {%- endif -%}
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join -%}
        {%- if vars.header_code_fragment -%}
        {{vars.header_code_fragment}}{{new_line}}
        {% endif -%}
        {%- set bases_specifiers = base_types_converters|map(attribute='swift.target_type_name')|list + vars.bases_list -%}
        {%- if base_types_converters|map(attribute='swift')|rejectattr('vars.action', 'equalto', 'gen_interface')|list|length > 1 %}
        {%- do Error.critical(cxx.type_name + ' has more than 1 non abstract base type.') %}
        {%- endif %}
        {%- if ancestors|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
        {%- do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
        {%- endif %}
        {%- if vars.comment -%}
        {{vars.comment|make_doxygen_comment}}
        {% endif -%}
        public protocol {{converter.swift.get_target_type_name(definition=True)}}{{': ' + bases_specifiers|join(', ') if bases_specifiers}} {

          {%- if not base_types_converters %}
          /**
           * An internal property to keep a reference to the original C++ object.
           * It is intended to be used by the generated code.
           */
          var cself: {{converter.sc.target_type_name}} { get }{{new_line}}
          /**
           * An internal method to bind the lifetimes of the current and another object.
           * It is intended to be used by the generated code.
           */
          func keepCppBindReference(_ object: Any)
          {%- endif %}
          {%- if interface_head %}
          {{interface_head|string|indent(2)}}
          {%- endif %}
          {%- if interface_properties %}
          {{interface_properties|string|indent(2)}}
          {%- endif %}
          {%- if interface_body %}
          {{interface_body|string|indent(2)}}
          {%- endif %}
        }

        extension {{converter.swift.get_target_type_name(definition=True)}} {
          {%- if properties %}
          {{properties|string|indent(2)}}
          {%- endif %}
          {%- if body %}
          {{body|string|indent(2)}}
          {%- endif %}
        }

        public class {{converter.swift.get_target_type_name(interface_class=True, definition=True)}}: {{converter.swift.target_type_name}} {
          public let cself: {{converter.sc.target_type_name}}
          public let owner: Bool
          private var refs: [Any]

          // internal main initializer
          internal required init(_ _cself: {{converter.sc.target_type_name}}, _ _owner: Bool = false) {
            self.cself = _cself
            self.owner = _owner
            self.refs = []
          }

          deinit {
            release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.get_target_type_name(interface_class=True)|replace('.',  '_')}}(cself, owner)
          }

          public func keepCppBindReference(_ object: Any) {
            self.refs.append(object)
          }{{new_line}}
          {%- if head %}
          {{head|string|indent(2)}}
          {%- endif %}
          /**
           * An internal property to keep an information about the underlying C++ object type.
           * It is intended to be used by the generated code.
           */
          {{'override ' if base_types_converters|map(attribute='swift')|rejectattr('vars.action', 'equalto', 'gen_interface')|list}}class var cppbindCxxTypeName : String { return "{{cxx.unqualified_canonical_type_name}}" }
          {#- object construction function is generated for all classes (not only for bases with reusing them for derived types) since the performance would be lowered in case of superbases with deep hierarchy -#}
          {%- if (vars.descendants if vars.descendants is not none else descendants) and cxx.is_polymorphic %}

          /**
           * An internal method to create a Swift object from a C++ object.
           * It is intended to be used by the generated code.
           */
          class func cppbindConstructObject(_ cppbindObj: CppBindCObject, _ owner: Bool = false) -> {{converter.swift.target_type_name}} {
            {{converter.swift_obj_construction.snippet(name="cppbindObj")|indent(4)}}
          }
          {%- endif %}
        }
        {%- if vars.footer_code_fragment %}
        {{new_line}}{{vars.footer_code_fragment}}
        {%- endif %}{{new_line}}
  cc:
    include: *var_class_cxx_include
    glob_decl: *var_class_cxx_glob_decl
    glob_def:
      unique_content: |
        const char* {{converter.cxx_type_name_global.snippet()}} = "{{cxx.unqualified_canonical_type_name}}";
    namespace:
      unique_content: |
        {%- if cxx.namespace %}
        using namespace {{cxx.namespace}};
        {%- endif %}
    body:
      content: |
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join -%}
        void release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.get_target_type_name(interface_class=True)|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner) {
            {%- if not vars.shared_ref and cxx.is_polymorphic and (vars.descendants if vars.descendants is not none else descendants) %}
            static_assert(std::has_virtual_destructor<{{cxx.unqualified_resolved_type_name}}>::value, {{'"{} type must have virtual destructor"'.format(cxx.unqualified_resolved_type_name)}});
            {%- endif %}
            if (owner) {
                {#- here is used almost the same logic as for jni_to_cxx section of Object/std::shared_ptr type converter (instead of constructing target value we delete it here) -#}
                {%- set descendants = vars.descendants if vars.descendants is not none else descendants %}
                {%- if descendants %}
                if (strcmp(cself.type, {{converter.cxx_type_name_global.snippet()}}) == 0)
                {%- if vars.shared_ref %}
                    delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(cself.ptr);
                {%- else %}
                    delete static_cast<{{cxx.unqualified_resolved_type_name}}*>(cself.ptr);
                {%- endif %}
                {%- for descendant in descendants %}
                else if (strcmp(cself.type, {{make_type_converter(descendant).cxx_type_name_global.snippet()}}) == 0)
                {%- if vars.shared_ref %}
                    delete static_cast<std::shared_ptr<{{descendant}}>*>(cself.ptr);
                {%- else %}
                    delete static_cast<{{descendant}}*>(cself.ptr);
                {%- endif %}
                {%- endfor %}
                else {
                    std::cerr << "Unexpected object type: " << cself.type << std::endl;
                    exit(1);
                }
                {%- else -%}
                {%- if vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(cself.ptr);
                {%- else %}
                delete static_cast<{{cxx.unqualified_resolved_type_name}}*>(cself.ptr);
                {%- endif %}
                {%- endif %}
            }
            free(cself.type);
        }
        {% if descendants %}
        {%- set this_converter = make_type_converter('std::shared_ptr<' + cxx.type_name + '>') if vars.shared_ref else converter %}
        {{this_converter.cxx_obj_recover_func_decl.snippet(name="cppbindObj")}} {
            {{this_converter.cxx_obj_recover.snippet(name="cppbindObj")|indent(4)}}
        }{{new_line}}
        {%- endif -%}
  ch:
    body:
      content: |
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join -%}
        void release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.get_target_type_name(interface_class=True)|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner);

var_method_swift_include: &var_method_swift_include
  unique_content: |
    {%- macro gen_import(converter) -%}
    {%- if converter.swift.parent_type_info -%}
    {{gen_import(make_type_converter(converter.swift.parent_type_info.cxx.type_name))}}
    {%- elif converter.swift_include -%}
    {{marker}}{{converter.swift_include.snippet(full_package=vars.full_package)}}
    {%- endif -%}
    {%- for arg_converter in converter.swift.args_converters -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- endmacro -%}
    {%- for arg_converter in args|map(attribute='converter') -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_import(rconverter)}}
    {%- endif -%}

var_method_cxx_include: &var_method_cxx_include
  unique_content:
    !concat
    - !include cxx_macros.yaml&cxx_include
    - |
      {%- if vars.is_proj_type -%}
      {{marker}}#include "{{vars.prj_rel_file_name}}"
      {%- endif -%}
      {#- this should go to shared macro cxx_include -#}
      {%- macro gen_include(converter) -%}
      {%- if converter.cxx_include -%}
      {{marker}}{{converter.cxx_include.snippet()}}
      {%- endif -%}
      {%- if converter.swift -%}
      {%- for arg_converter in converter.swift.args_converters -%}
      {{gen_include(arg_converter)}}
      {%- endfor -%}
      {%- endif -%}
      {%- endmacro -%}
      {%- for arg in args -%}
      {{gen_include(arg.converter)}}
      {%- endfor -%}
      {%- if rconverter is defined -%}
      {{gen_include(rconverter)}}
      {%- endif -%}
      {%- set includes = gen_cxx_include(vars) -%}
      {%- if includes -%}{{includes}}{%- endif -%}

var_method_c_include: &var_method_c_include
  unique_content: |
    {%- macro gen_include(converter) -%}
    {%- if converter.c_include -%}
    {{marker}}{{converter.c_include.snippet()}}
    {%- endif -%}
    {%- endmacro -%}
    {%- for arg in args|default([]) -%}
    {{gen_include(arg.converter)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_include(rconverter)}}
    {%- endif -%}

var_method_cxx_forward_decl: &var_method_cxx_forward_decl
  unique_content: |
    {%- macro collect_fwd_decl_type_infos(type_info, fwd_decl_type_infos) -%}
    {#- Type comparison is done when the type has descendants. Forward decl is not needed when the object recover function is generated in the same file as current function/method. -#}
    {%- if type_info.vars and type_info.vars.descendants is defined and (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) and vars.c_file_fullname != type_info.vars.c_file_fullname -%}
    {%- do fwd_decl_type_infos.append(type_info) -%}
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
        {%- do collect_fwd_decl_type_infos(arg_type_info, fwd_decl_type_infos) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- set fwd_decl_type_infos = [] -%}
    {%- for arg in args -%}
        {%- do collect_fwd_decl_type_infos(arg.type_info, fwd_decl_type_infos) -%}
    {%- endfor -%}
    {%- for fwd_decl_type_info in fwd_decl_type_infos -%}
    {%- set fwd_decl_type_converter = make_type_converter('std::shared_ptr<' + fwd_decl_type_info.cxx.type_name + '>' if fwd_decl_type_info.vars.shared_ref else fwd_decl_type_info.cxx.type_name) -%}
    {{marker}}{{fwd_decl_type_converter.cxx_obj_recover_func_decl.snippet(is_fwd_decl=True)}};
    {%- endfor -%}

var_method_cxx_glob_decl: &var_method_cxx_glob_decl
  unique_content: |
    {#- this should go to shared macro -#}
    {%- macro collect_type_info_names(type_info, result_type_info_names) -%}
    {%- if type_info.vars -%}
    {%- do result_type_info_names.append(type_info.cxx.unqualified_canonical_type_name) -%}
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
        {%- do collect_type_info_names(arg_type_info, result_type_info_names) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- macro gen_glob_decl(type_names) -%}
    {%- for type_name in type_names -%}
        {%- set type_conv = make_type_converter(type_name) -%}
        {%- set type_info = get_type_info(type_name) -%}
        {#- `cxx_type_name_global` is none for enum types -#}
        {%- if type_conv.cxx_type_name_global is not none and type_info.vars.c_file_fullname != vars.c_file_fullname -%}
        {{marker}}{{'extern const char* ' + type_conv.cxx_type_name_global.snippet() + ';'}}
        {%- endif -%}
    {%- endfor -%}
    {%- endmacro -%}
    {#- `return_type_info` is not defined for constructors -#}
    {%- if return_type_info is defined -%}
    {%- set result_type_info_names = [] -%}
    {%- do collect_type_info_names(return_type_info, result_type_info_names) -%}
    {{gen_glob_decl(result_type_info_names)}}
    {%- endif -%}
    {#- `vars.throws` is not defiend for property getters/setters -#}
    {%- if vars.throws is defined and not 'no_throw' in vars.throws -%}
    {{gen_glob_decl(vars.throws)}}
    {%- endif -%}
    {%- if setter is defined and not 'no_throw' in setter.vars.throws -%}
    {{gen_glob_decl(setter.vars.throws)}}
    {%- endif -%}
    {{gen_glob_decl(['std::exception'])}}


constructor:
  swift:
    include: *var_method_swift_include
    head: |
      {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join %}
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {#- this should go to shared macro -#}
      {%- macro gen_func(args, index=none) -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      {%- set comma = joiner(', ') -%}
      public convenience init(
      {%- for arg in args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
      {%- if arg.default -%}
      {%- if arg.is_enum %}
      {%- set enum_case_name = arg.default.split('::')|last %}
      {%- if enum_case_name in arg.type_info.vars.enum_excluded_cases -%}
      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} constructor argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- else %} = {{arg.converter.swift.target_type_name}}.{{arg.type_info.vars.enum_case_names.get(enum_case_name, arg.type_info.vars.enum_case_name_prefix + enum_case_name)}}
      {%- endif -%}
      {%- else -%}
      {%- if arg.default_is_literal %} = {{"\"{}\"".format(arg.default[1]) if arg.is_char else arg.default}}
      {%- elif arg.default_is_nullptr %} = nil
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}{
        {%- set call_args = [] %}
        {%- for arg in args %}
        {%- set converter = arg.converter.swift_to_sc %}
        {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%- if conversion %}
        {{conversion|indent(2)}}
        {%- endif %}
        {%- do call_args.append(converter.converted_name(arg_name)) %}
        {%- endfor %}
        var cppbindErr = CppBindCObject()
        self.init(create_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}{{'_' + index|string if index}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr), true)
        {#- This should go to shared macro -#}
        {%- if vars.keep_alive %}
        {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
        {%- if invalid_args  %}
        {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
        {%- endif %}
        {%- for arg_idx in vars.keep_alive %}
        {%- set converter = args[arg_idx - 1].converter %}
        {%- if converter.swift_keep_alive %}
        {{converter.swift_keep_alive.snippet('self', reference=args[arg_idx - 1].name|to_camel_case)|indent(2)}}
        {%- endif %}
        {%- endfor %}
        {%- endif %}
        {%- for arg in args %}
        {%- if arg.converter.sc_cleanup %}
        {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg_name)) %}
        {%- if cleanup_code_fragment %}
        {{cleanup_code_fragment|indent(2)}}
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        if cppbindErr.type != nil {
          let errorType = String(cString: cppbindErr.type!)
          switch errorType {
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws %}
          case ("{{exc_type}}"):
            {%- set exc_info = get_type_info(exc_type) %}
            throw {{exc_info.vars.name}}(cppbindErr, true)
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          case ("std::exception"):
            {%- set exc_info = get_type_info("std::exception") %}
            let excObj = {{exc_info.vars.name}}(cppbindErr, true)
            ExceptionHandler.handleUncaughtException(excObj.what())
          {%- endif %}
          default:
            cppbindErr.type.deallocate()
            ExceptionHandler.handleUncaughtException("Uncaught Exception")
          }
        }
      }
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}{{new_line}}
  cc:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {#- this should go to shared macro -#}
      {%- macro gen_func(args, index=none) -%}
      {%- set comma = joiner(', ') -%}
      {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set index = '_' + index|string if index else '' -%}
      {{owner_class.converter.c.target_type_name}} create_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix + index}}(
      {%- for arg in args -%}
      {{comma()}}{{arg.converter.c.target_type_name}}
      {%- if arg.converter.c.custom.is_c_pointer_type %} {{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err) {
        {%- set call_args = [] -%}
        {%- for arg in args -%}
        {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%- set converter = arg.converter.c_to_cxx %}
        {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%- if conversion %}
          {{conversion|indent(4)}}
        {%- endif %}
        {%- do call_args.append(converter.converted_name(arg_name)) -%}
        {% endfor %}
          try {
              auto this_object = new {{owner_class.cxx.type_name}}({{call_args|join(', ')}});
              {%- if owner_class.vars.shared_ref %}
              return {strdup({{owner_class.converter.cxx_type_name_global.snippet()}}), new std::shared_ptr<{{owner_class.cxx.type_name}}>(this_object)};
              {%- else %}
              return {strdup({{owner_class.converter.cxx_type_name_global.snippet()}}), this_object};
              {%- endif %}
          }
          {%- if 'no_throw' not in vars.throws -%}
          {%- for exc_type in vars.throws %} catch (const {{exc_type}}& e) {
              {%- set exc_conv = make_type_converter(exc_type) %}
              cppbind_err->type = strdup({{exc_conv.cxx_type_name_global.snippet()}});
              cppbind_err->ptr = new {{exc_type}}(e);
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %} catch (const std::exception& e) {
              {%- set std_exc_conv = make_type_converter('std::exception') %}
              cppbind_err->type = strdup({{std_exc_conv.cxx_type_name_global.snippet()}});
              cppbind_err->ptr = new std::exception(e);
          }
          {%- endif %} catch (...) {
              cppbind_err->type = strdup("Uncaught Exception");
          }
          {{owner_class.converter.c.target_type_name}} result {};
          return result;
      }
      {% endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}
      {% endfor -%}{{gen_func(args)}}
  ch:
    include: *var_method_c_include
    body:
      content: |
        {#- this should go to shared macro -#}
        {%- macro gen_func(args, index=none) -%}
        {%- set comma = joiner(', ') %}
        {%- set index = '_' + index|string if index else '' %}
        {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join %}
        {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' %}
        {{owner_class.converter.c.target_type_name}} create_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix + index}}(
        {%- for arg in args -%}
        {{comma()}}{{arg.converter.c.target_type_name}}
        {%- if arg.converter.c.custom.is_c_pointer_type %} {{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
        {%- endfor -%}
        {{', ' if args}}CppBindCObject* _Nonnull cppbind_err);
        {%- endmacro %}
        {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(args[:args.index(arg_with_default)], loop.index)}}
        {% endfor -%}{{gen_func(args)}}

method:
  swift:
    include: *var_method_swift_include
    body:
      !concat
      - !include swift_macros.yaml&validations
      - !include swift_macros.yaml&exception_handling
      - !include swift_macros.yaml&special_functions.method
      - |
        {%- do run_method_validations() -%}
        {%- if cxx.name == vars.hash_method -%}
        {{gen_hash_function()}}
        {% elif cxx.name == vars.equals_method -%}
        {{gen_equals_function()}}
        {% elif cxx.name == vars.tostring_method -%}
        {{gen_str_function()}}
        {% else -%}
        {%- set cxx_namespace = (owner_class.cxx.namespace.split('::')|map('capitalize')|join + '_') if owner_class.cxx.namespace else '' %}
        {%- set is_override = cxx.is_override and not is_interface_override -%}
        {%- if vars.is_operator and vars.name == '[]' -%}
        {%- set comma = joiner(', ') %}
        {# subscript operator #}
        {%- if vars.comment -%}
        {{vars.comment|make_doxygen_comment}}
        {% endif -%}
        {%- set comma = joiner(', ') -%}
        {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
        {%- macro get_property() %}
        {%- set call_args = ['cself'] -%}
        {%- for arg in args -%}
        {%- set converter = arg.converter.swift_to_sc %}
        {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%- if conversion -%}
        {{conversion|indent(4)}}
        {% endif %}
        {%- do call_args.append(converter.converted_name(arg_name)) %}
        {%- endfor -%}
        let result = {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_getitem_'), vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix)}}({{call_args|join(', ')}})
        {%- set conversion = rconverter.sc_to_swift.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
        {%- if conversion %}
        {{conversion|indent(2)}}
        {%- endif %}
        {%- for arg in args %}
        {%- if arg.converter.sc_cleanup %}
        {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg_name)) %}
        {%- if cleanup_code_fragment %}
        {{cleanup_code_fragment|indent(4)}}
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        {%- if vars.return_value_policy == 'reference_internal' and rconverter.swift_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
        {%- set conversion = rconverter.swift_ref_internal.snippet(rconverter.sc_to_swift.converted_name('result'), reference='self', nullable=vars.nullable_return) %}
        {%- if conversion %}
        {{conversion|indent(4)}}{% endif %}
        {%- endif %}
        return {{rconverter.sc_to_swift.converted_name('result')}}
        {%- endmacro %}
        {%- if vars.is_operator and vars.name == '[]' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference -%}
        {# subscript operator #}
        public subscript({%- for arg in args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{arg.converter.swift.target_type_name}}
                         {%- endfor-%}) -> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
          get {
            {{get_property()|indent(4)}}
          }

          {%- set res_converter = rconverter.swift_to_sc %}

          set(value) {
            {%- set call_args = ['cself'] %}
            {%- for arg in args %}
            {%- set converter = arg.converter.swift_to_sc %}
            {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
            {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
            {%- if conversion %}
            {{conversion|indent(4)}}
            {%- endif %}
            {%- do call_args.append(converter.converted_name(arg_name)) %}
            {%- endfor %}
            {%- set conversion = res_converter.snippet('value', nullable=vars.nullable_return) %}
            {%- if conversion %}
            {{conversion|indent(4)}}
            {%- endif %}
            {%- do call_args.append(res_converter.converted_name('value')) %}
            {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_setitem_'), vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix)}}({{call_args|join(', ')}})
            {#- This should go to shared macro -#}
            {%- if vars.keep_alive %}
            {%- set args = args + [namespace(name='value', converter=rconverter)] -%}
            {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
            {%- if invalid_args %}
            {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
            {%- endif %}
            {%- for arg_idx in vars.keep_alive %}
            {%- set converter = args[arg_idx - 1].converter %}
            {%- if converter.swift_keep_alive %}
            {{converter.swift_keep_alive.snippet('self', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
            {%- endif %}
            {%- endfor %}
            {%- endif %}
            {%- for arg in args %}
            {%- if arg.converter.sc_cleanup %}
            {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
            {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg_name)) %}
            {%- if cleanup_code_fragment %}
            {{cleanup_code_fragment|indent(4)}}
            {%- endif %}
            {%- endif %}
            {%- endfor %}
            {%- if rconverter.sc_cleanup %}
            {%- set cleanup_code_fragment = rconverter.sc_cleanup.snippet(res_converter.converted_name('value')) %}
            {%- if cleanup_code_fragment %}
            {{cleanup_code_fragment|indent(4)}}
            {%- endif %}
            {%- endif %}
          }
        }
        {%- elif vars.is_operator and vars.name == '[]' %}
        public subscript({%- for arg in args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{arg.converter.swift.target_type_name}}
                         {%- endfor-%}) -> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
          {{get_property()|indent(2)}}
        }
        {%- endif %}
        {%- else -%}
        {%- macro gen_func(args, index=none) -%}
        {%- set comma = joiner(', ') -%}
        {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
        {%- if vars.comment -%}
        {{vars.comment|make_doxygen_comment}}
        {% endif -%}
        {%- if vars.is_operator -%}
        public static func {{vars.name}}(cself: {{owner_class.vars.name}}{{', ' if args}}{%- for arg in args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
        {%- set call_args = ['cself.cself'] -%}
        {%- else -%}
        public {{"static " if cxx.is_static}}{{"override " if is_override}}func {{vars.name}}(
        {%- for arg in args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
        {%- if arg.default -%}
        {%- if arg.is_enum %}
        {%- set enum_case_name = arg.default.split('::')|last %}
        {%- if enum_case_name in arg.type_info.vars.enum_excluded_cases -%}
        {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
        {%- else %} = {{arg.converter.swift.target_type_name}}.{{arg.type_info.vars.enum_case_names.get(enum_case_name, arg.type_info.vars.enum_case_name_prefix + enum_case_name)}}
        {%- endif -%}
        {%- else -%}
        {%- if arg.default_is_literal %} = {{"\"{}\"".format(arg.default[1]) if arg.is_char else arg.default}}
        {%- elif arg.default_is_nullptr %} = nil
        {%- endif %}
        {%- endif %}
        {%- endif -%}
        {%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
        {%- set call_args = ['cself'] if not cxx.is_static else [] %}
        {%endif%}
          {%- for arg in args %}
          {%- set converter = arg.converter.swift_to_sc %}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
          {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
          {%- if conversion %}
          {{conversion|indent(2)}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg_name))%}
          {%- endfor %}
          var cppbindErr = CppBindCObject()
          {%- set index = '_' + index|string if index else '' %}
          {%- if rconverter.c.target_type_name != 'void' %}
          let result = {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix + index)}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr)
          {%- else %}
          {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix + index)}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr)
          {%- endif %}
          {#- This should go to shared macro -#}
          {%- if vars.keep_alive %}
          {%- if cxx.is_static %}
          {%- do Error.critical('Cannot apply keep alive policy for a static member function: {}.{}'.format(cxx.name, owner_class.cxx.type_name)) -%}
          {%- endif %}
          {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
          {%- if invalid_args  %}
          {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
          {%- endif %}
          {%- for arg_idx in vars.keep_alive %}
          {%- set converter = args[arg_idx - 1].converter %}
          {%- if converter.swift_keep_alive %}
          {{converter.swift_keep_alive.snippet('self', reference=args[arg_idx - 1].name|to_camel_case)|indent(2)}}
          {%- endif %}
          {%- endfor %}
          {%- endif %}
          {%- for arg in args %}
          {%- if arg.converter.sc_cleanup %}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
          {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg_name)) %}
          {%- if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(2)}}
          {%- endif %}
          {%- endif %}
          {%- endfor %}
          {{gen_exception_handling_code()|indent(2)}}
          {%- if rconverter.c.target_type_name != 'void' %}
          {%- set conversion = rconverter.sc_to_swift.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
          {%- if conversion %}
          {{conversion|indent(2)}}
          {%- endif %}
          {%- if vars.return_value_policy == 'reference_internal' and rconverter.swift_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
          {%- set conversion = rconverter.swift_ref_internal.snippet(rconverter.sc_to_swift.converted_name('result'), reference='self', nullable=vars.nullable_return) %}
          {%- if conversion %}
          {{conversion|indent(2)}}{% endif %}
          {%- endif %}
          return {{rconverter.sc_to_swift.converted_name('result')}}
          {%- endif %}
        }
        {%- endmacro -%}
        {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(args)}}
        {%- endif %}{{new_line}}
        {%- endif %}
    interface_body: |
      {#- this should go to shared macro -#}
      {%- macro gen_func(args, index=none) -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif %}
      {%- set comma = joiner(', ') -%}
      {%- if vars.is_operator and vars.name == '[]' -%}
      subscript({%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{arg.converter.swift.target_type_name}}{% endfor %}) -> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} { get {{'set ' if not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference}}}
      {%- else -%}
      func {{vars.name}}({%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}}
      {%- endif %}
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}
  cc:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join + '_' if owner_class.cxx.namespace else '' %}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set is_subscript_operator = vars.is_operator and vars.name == '[]' -%}
      {%- if not is_subscript_operator -%}
      {%- macro gen_func(args, index=none) -%}
      {%- set comma = joiner(', ') -%}
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix)}}{{'_' + index|string if index}}(
      {%- if not cxx.is_static -%}
      {{owner_class.converter.c.target_type_name}} cself, {% endif -%}
      {%- for arg in args -%}{{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err) {
        {%- set call_args = [] %}
        {%- for arg in args %}
        {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%- set converter = arg.converter.c_to_cxx %}
        {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%- if conversion %}
          {{conversion|indent(4)}}
        {%- endif %}
        {%- do call_args.append(converter.converted_name(arg_name)) %}
        {% endfor %}
        {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.vars.shared_ref else owner_class.converter.c_to_cxx -%}
        {%- if not cxx.is_static -%}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
        {%- endif %}
        {%- if rconverter.c.target_type_name != 'void' %}
          try {
              const auto& result = {%if not cxx.is_static %}{{this_converter.converted_name('cself')}}->
                                   {%- else%}{{owner_class.cxx.type_name}}::{% endif %}{{cxx.name}}
                                   {%- if cxx.is_template -%}
                                   <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>{%- endif -%}({{call_args|join(', ')}});
              {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
              return {{rconverter.cxx_to_c.converted_name('result')}};
          }
        {%- else %}
          try {
              {%if not cxx.is_static %}{{this_converter.converted_name('cself')}}->{%else%}{{owner_class.cxx.type_name}}::{% endif %}{{cxx.name}}({{call_args|join(', ')}});
          }
        {%- endif %}
        {%- if 'no_throw' not in vars.throws -%}
          {%- for exc_type in vars.throws %} catch (const {{exc_type}}& e) {
              {%- set exc_conv = make_type_converter(exc_type) %}
              cppbind_err->type = strdup({{exc_conv.cxx_type_name_global.snippet()}});
              cppbind_err->ptr = new {{exc_type}}(e);
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %} catch (const std::exception& e) {
              {%- set std_exc_conv = make_type_converter('std::exception') %}
              cppbind_err->type = strdup({{std_exc_conv.cxx_type_name_global.snippet()}});
              cppbind_err->ptr = new std::exception(e);
          }
          {%- endif %} catch (...) {
              cppbind_err->type = strdup("Uncaught Exception");
          }

          {%- if rconverter.c.target_type_name != 'void' %}
          {{rconverter.c.target_type_name}} result {};
          return result;
          {%- endif %}
      }
      {% endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}
      {% endfor -%}{{gen_func(args)}}
      {%- else -%}
      {%- set comma = joiner(', ') -%}
      {# subscript operator getter #}
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_getitem_'), vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix)}}({{owner_class.converter.c.target_type_name}} cself,
      {%- for arg in args -%}
      {{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}) {
          {%- set call_args = [] %}
          {%- for arg in args -%}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
          {%- set converter = arg.converter.c_to_cxx %}
          {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg_name)) -%}
          {% endfor %}
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.vars.shared_ref else owner_class.converter.c_to_cxx -%}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          {%- if rconverter.c.target_type_name != 'void' %}
          const auto& result = {{this_converter.converted_name('cself')}}->{{cxx.name}}
                               {%- if cxx.is_template -%}
                               <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>{%- endif -%}({{call_args|join(', ')}});
          {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
          return {{rconverter.cxx_to_c.converted_name('result')}};
          {%- else %}
          {{this_converter.converted_name('cself')}}->{{cxx.name}}({{call_args|join(', ')}});
          {%- endif %}
      }
      {%- if not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
      {# subscript operator setter #}
      {% set comma = joiner(', ') -%}
      void {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_setitem_'), vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix)}}({{owner_class.converter.c.target_type_name}} cself, {% for arg in args -%}
          {{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if args}}{{rconverter.c.target_type_name}}
          {%- if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} value) {
          {%- set call_args = [] %}
          {%- for arg in args -%}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
          {%- set converter = arg.converter.c_to_cxx %}
          {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg_name)) -%}
          {% endfor %}
          {%- set conversion = rconverter.c_to_cxx.snippet('value', nullable=vars.nullable_return) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {% endif %}
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.vars.shared_ref else owner_class.converter.c_to_cxx -%}
          {%- if not cxx.is_static %}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          {%- endif %}
          {{this_converter.converted_name('cself')}}->{{cxx.name}}({{call_args|join(', ')}}) = value;
      }
      {%- endif %}
      {%- endif %}
  ch:
    include: *var_method_c_include
    body:
      content: |
        {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join + '_' if owner_class.cxx.namespace else '' %}
        {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
        {%- set is_subscript_operator = vars.is_operator and vars.name == '[]' -%}
        {%- if not is_subscript_operator -%}
        {%- macro gen_func(args, index=none) -%}
        {%- set comma = joiner(', ') -%}
        {%- set index = '_' + index|string if index else '' -%}
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_getitem_') if is_subscript_operator else vars.name, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix + index)}}(
        {%- if not cxx.is_static -%}{{owner_class.converter.c.target_type_name}} cself, {% endif -%}
        {%- for arg in args -%}
        {{comma()}}{{arg.converter.c.target_type_name}} {% if arg.converter.c.custom.is_c_pointer_type %}{{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
        {%- endfor -%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err);
        {%- endmacro -%}
        {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(args[:args.index(arg_with_default)], loop.index)}}
        {% endfor -%}{{gen_func(args)}}
        {%- else %}
        {# subscript operator #}
        {%- set comma = joiner(', ') %}
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}
        {%- endif %} {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_getitem_') if is_subscript_operator else vars.name, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix)}}({{owner_class.converter.c.target_type_name}} cself, {% for arg in args -%}
        {{comma()}}{{arg.converter.c.target_type_name}} {% if arg.converter.c.custom.is_c_pointer_type %}{{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%});
        {# subscript operator setter #}
        {%- if not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
        {% set comma = joiner(', ') %}
        void {{helper.get_c_func_name(cxx_namespace + owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_setitem_'), vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix)}}({{owner_class.converter.c.target_type_name}} cself, {% for arg in args -%}
        {{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if args}}{{rconverter.c.target_type_name}}
        {%- if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} value);
        {%- endif %}
        {%- endif -%}


function:
  swift:
    include: *var_method_swift_include
    body: |
      {%- if vars.return_value_policy == 'reference_internal' -%}
      {% do Error.critical("Cannot apply reference internal policy on a non member function's return value: {} in {}".format(cxx.name, cxx.source_file_name)) -%}
      {%- endif -%}
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {} does not have such arguments.".format(', '.join(incorrect_nullable_args), cxx.displayname)) -%}
      {%- endif -%}
      {#- this should go to shared macro -#}
      {%- macro gen_func(args, index=none) -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set comma = joiner(', ') -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      public func {{vars.name}}({%- for arg in args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
        {%- if arg.default -%}
        {%- if arg.is_enum %}
        {%- set enum_case_name = arg.default.split('::')|last %}
        {%- if enum_case_name in arg.type_info.vars.enum_excluded_cases -%}
        {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {} function argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.displayname)) -%}
        {%- else %} = {{arg.converter.swift.target_type_name}}.{{arg.type_info.vars.enum_case_names.get(enum_case_name, arg.type_info.vars.enum_case_name_prefix + enum_case_name)}}
        {%- endif -%}
        {%- else -%}
        {%- if arg.default_is_literal %} = {{"\"{}\"".format(arg.default[1]) if arg.is_char else arg.default}}
        {%- elif arg.default_is_nullptr %} = nil
        {%- endif %}
        {%- endif %}
        {%- endif %}
        {%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
        {%- set call_args = [] %}
        {%- for arg in args %}
        {%- set converter = arg.converter.swift_to_sc %}
        {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%- set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%- if conversion %}
        {{conversion|indent(2)}}
        {%- endif %}
        {%- do call_args.append(converter.converted_name(arg_name))%}
        {%- endfor %}
        var cppbindErr = CppBindCObject()
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
        {%- set index = '_' + index|string if index else '' %}
        {%- set c_func_name = helper.get_c_func_name(cxx_namespace, vars.name, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix + index) %}
        {%- if rconverter.c.target_type_name != 'void' %}
        let result = {{c_func_name}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr)
        {%- else %}
        {{c_func_name}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr)
        {%- endif %}
        {%- for arg in args %}
        {%- if arg.converter.sc_cleanup %}
        {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg.name|to_camel_case)) %}
        {%- if cleanup_code_fragment %}
        {{cleanup_code_fragment|indent(2)}}
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        if cppbindErr.type != nil {
          let errorType = String(cString: cppbindErr.type!)
          switch errorType {
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws %}
          case ("{{exc_type}}"):
            {%- set exc_info = get_type_info(exc_type) %}
            throw {{exc_info.vars.name}}(cppbindErr, true)
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          case ("std::exception"):
            {%- set exc_info = get_type_info("std::exception") %}
            let excObj = {{exc_info.vars.name}}(cppbindErr, true)
            ExceptionHandler.handleUncaughtException(excObj.what())
          {%- endif %}
          default:
            cppbindErr.type.deallocate()
            ExceptionHandler.handleUncaughtException("Uncaught Exception")
          }
        }
        {%- if rconverter.c.target_type_name != 'void' %}
        {%- set conversion = rconverter.sc_to_swift.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
        {%- if conversion %}
        {{conversion|indent(2)}}
        {%- endif %}
        return {{rconverter.sc_to_swift.converted_name('result')}}
        {%- endif %}
      }
      {%- endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(args)}}{{new_line}}
  cc:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {#- this should got to shared macro -#}
      {%- macro gen_func(args, index=none) -%}
      {%- set comma = joiner(', ') %}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join -%}
      {%- set index = '_' + index|string if index else '' -%}
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{helper.get_c_func_name(cxx_namespace, vars.name, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix + index)}}(
      {%- set comma = joiner(', ') %}
      {%- for arg in args -%}
      {{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type -%}
      {{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err) {
          {%- set call_args = [] %}
          {%- for arg in args -%}
          {%- set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
          {%- set converter = arg.converter.c_to_cxx %}
          {{converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr)|indent(4)}}
          {%- do call_args.append(converter.converted_name(arg_name)) %}
          {%- endfor %}
          {%- if rconverter.c.target_type_name != 'void' %}
          try {
              const auto& result = {{cxx.namespace}}::{{cxx.name}}
                                   {%- if cxx.is_template -%}
                                   <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                   {%- endif -%}({{call_args|join(', ')}});
              {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
              return {{rconverter.cxx_to_c.converted_name('result')}};
          }
          {%- else %}
          try {
              {{cxx.name}}{%- if cxx.is_template -%}
              <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
              {%- endif -%}({{call_args|join(', ')}});
          }
          {%- endif -%}
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws %} catch (const {{exc_type}}& e) {
              {%- set exc_conv = make_type_converter(exc_type) %}
              cppbind_err->type = strdup({{exc_conv.cxx_type_name_global.snippet()}});
              cppbind_err->ptr = new {{exc_type}}(e);
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %} catch (const std::exception& e) {
              {%- set std_exc_conv = make_type_converter('std::exception') %}
              cppbind_err->type = strdup({{std_exc_conv.cxx_type_name_global.snippet()}});
              cppbind_err->ptr = new std::exception(e);
          }
          {%- endif %} catch (...) {
              cppbind_err->type = strdup("Uncaught Exception");
          }

          {%- if rconverter.c.target_type_name != 'void' %}
          {{rconverter.c.target_type_name}} result {};
          return result;
          {%- endif %}
      }
      {% endmacro -%}
      {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(args[:args.index(arg_with_default)], loop.index)}}
      {% endfor -%}{{gen_func(args)}}
  ch:
    include: *var_method_c_include
    body:
      content: |
        {#- this should got to shared macro #}
        {%- macro gen_func(args, index=none) -%}
        {%- set comma = joiner(', ') %}
        {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' %}
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
        {%- set index = '_' + index|string if index else '' %}
        {%- set c_func_name = helper.get_c_func_name(cxx_namespace, vars.name, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix + template_postfix + index) %}
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{c_func_name}}(
        {%- for arg in args -%}
        {{comma()}}{{arg.converter.c.target_type_name}} {% if arg.converter.c.custom.is_c_pointer_type %}{{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
        {%- endfor -%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err);
        {%- endmacro -%}
        {%- set non_primitive_default_args = args|rejectattr('default', 'none')|rejectattr('is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(args[:args.index(arg_with_default)], loop.index)}}
        {% endfor -%}{{gen_func(args)}}

var_getter_swift_include: &var_getter_swift_include
  unique_content: |
    {%- macro gen_import(converter) -%}
    {%- if converter.swift.parent_type_info -%}
    {{gen_import(make_type_converter(converter.swift.parent_type_info.cxx.type_name))}}
    {%- elif converter.swift_include -%}
    {{marker}}{{converter.swift_include.snippet(full_package=vars.full_package)}}
    {%- endif -%}
    {%- for arg_converter in converter.swift.args_converters -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- endmacro -%}
    {{gen_import(rconverter)}}

var_getter_cxx_include: &var_getter_cxx_include
  unique_content: |
    {#- this should go to shared macro cxx_include -#}
    {%- macro gen_include(converter) -%}
    {%- if converter.cxx_include -%}
    {{marker}}{{converter.cxx_include.snippet()}}
    {%- endif -%}
    {%- if converter.swift -%}
    {%- for arg_converter in converter.swift.args_converters -%}
    {{gen_include(arg_converter)}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {{gen_include(rconverter)}}

var_getter_cxx_forward_decl: &var_getter_cxx_forward_decl
  unique_content: |
    {%- macro collect_fwd_decl_type_infos(type_info, fwd_decl_type_infos) -%}
    {#- Type comparison is done when the type has descendants. Forward decl is not needed when the object recover function is generated in the same file as current getter/setter. -#}
    {%- if type_info.vars and type_info.vars.descendants is defined and (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) and vars.c_file_fullname != type_info.vars.c_file_fullname -%}
    {%- do fwd_decl_type_infos.append(type_info) -%}
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
        {%- do collect_fwd_decl_type_infos(arg_type_info, fwd_decl_type_infos) -%}
    {%- endfor -%}
    {%- endmacro -%}
    {%- set fwd_decl_type_infos = [] -%}
    {%- if setter is defined -%}
        {%- do collect_fwd_decl_type_infos(return_type_info, fwd_decl_type_infos) -%}
    {%- endif -%}
    {%- for fwd_decl_type_info in fwd_decl_type_infos -%}
    {%- set fwd_decl_type_converter = make_type_converter('std::shared_ptr<' + fwd_decl_type_info.cxx.type_name + '>' if fwd_decl_type_info.vars.shared_ref else fwd_decl_type_info.cxx.type_name) -%}
    {{marker}}{{fwd_decl_type_converter.cxx_obj_recover_func_decl.snippet(is_fwd_decl=True)}};
    {%- endfor -%}

property_getter:
  swift:
    include: *var_getter_swift_include
    properties: |
      {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join -%}
      {%- if not cxx.is_public -%}
      {%- do Error.critical("{}.{} is not a public field. Make it public or remove cppbind API.".format(owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- set result_converter = rconverter.sc_to_swift -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      {%- macro get_property() -%}
      let result = _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}(cself)
      {%- set conversion = result_converter.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
      {%- if conversion %}
      {{conversion}}
      {%- endif %}
      {%- if vars.return_value_policy == 'reference_internal' and rconverter.swift_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
      {%- set conversion = rconverter.swift_ref_internal.snippet(rconverter.sc_to_swift.converted_name('result'), reference='self', nullable=vars.nullable_return) -%}
      {%- if conversion %}
      {{conversion}}{% endif %}
      {%- endif %}
      return {{result_converter.converted_name('result')}}
      {%- endmacro -%}
      public var {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} {
        {%- if vars.action == 'gen_property_setter' %}
        {%- set converter = rconverter.swift_to_sc %}
        get {
          {{get_property()|indent(4)}}
        }

        set(value) {
          {%- set conversion = converter.snippet('value', nullable=vars.nullable_return) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.', '_')}}_{{vars.name}}(cself, {{converter.converted_name('value')}})
          {#- This should go to shared macro -#}
          {%- if vars.keep_alive %}
          {%- set args = [namespace(name='value', converter=rconverter)] %}
          {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
          {%- if invalid_args  %}
          {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
          {%- endif %}
          {%- for arg_idx in vars.keep_alive %}
          {%- set converter = args[arg_idx - 1].converter %}
          {%- if converter.swift_keep_alive %}
          {{converter.swift_keep_alive.snippet('self', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
          {%- endif %}
          {%- endfor %}
          {%- endif %}
          {%- if rconverter.sc_cleanup %}
          {%- set cleanup_code_fragment = rconverter.sc_cleanup.snippet(converter.converted_name('value')) %}
          {%- if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(4)}}
          {%- endif %}
          {%- endif %}
        }
        {%- else %}
        {{get_property()|indent(2)}}
        {%- endif %}
      }{{new_line}}
    interface_properties: |
      {%- set result_converter = rconverter.sc_to_swift -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      var {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} { get {% if vars.action == 'gen_property_setter' %}set{% endif %} }
  cc:
    include: *var_getter_cxx_include
    forward_decl: *var_getter_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join -%}
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}({{owner_class.converter.c.target_type_name}} cself) {
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.vars.shared_ref else owner_class.converter.c_to_cxx -%}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          const auto& result = {{this_converter.converted_name('cself')}}->{{cxx.name}};
          {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(4)}}
          return {{rconverter.cxx_to_c.converted_name('result')}};
      }
      {% if vars.action == 'gen_property_setter' %}
      void _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.', '_')}}_{{vars.name}}({{owner_class.converter.c.target_type_name}} cself, {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{vars.name}}) {
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          {{rconverter.c_to_cxx.snippet(vars.name, nullable=vars.nullable_return)|indent(4)}}
          {{this_converter.converted_name('cself')}}->{{cxx.name}} = {{rconverter.c_to_cxx.converted_name(vars.name)}};
      }
      {% endif %}
  ch:
    include: *var_method_c_include
    body:
      content: |
        {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join -%}
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}({{owner_class.converter.c.target_type_name}} cself);
        {%- if vars.action == 'gen_property_setter' %}
        void _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.', '_')}}_{{vars.name}}({{owner_class.converter.c.target_type_name}} cself, {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{vars.name}});
        {% endif %}

getter:
  swift:
    include: *var_getter_swift_include
    properties: |
      {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join %}
      {%- if 'no_throw' not in vars.throws -%}
      {%- do Error.error("{}.{}: swift property getter cannot throw, invalid value of 'throws' variable".format(owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- do helper.validate_getter(cxx, vars, args, owner_class, setter|default(none)) -%}
      {%- do helper.validate_template_getter_setter(cxx, vars, owner_class, setter|default(none)) -%}
      {% set result_converter = rconverter.sc_to_swift -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- macro gen_exc_switch_block() -%}
      if cppbindErr.type != nil {
        let errorType = String(cString: cppbindErr.type!)
        switch errorType {
        case ("std::exception"):
          {%- set exc_info = get_type_info("std::exception") %}
          let excObj = {{exc_info.vars.name}}(cppbindErr, true)
          ExceptionHandler.handleUncaughtException(excObj.what())
        default:
          cppbindErr.type.deallocate()
          ExceptionHandler.handleUncaughtException("Uncaught Exception")
        }
      }
      {%- endmacro -%}
      {% if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      {%- macro get_property() -%}
      var cppbindErr = CppBindCObject()
      let result = _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}(cself, &cppbindErr)
      {{gen_exc_switch_block()}}
      {%- set conversion = result_converter.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
      {%- if conversion %}
      {{conversion}}
      {%- endif %}
      {%- if vars.return_value_policy == 'reference_internal' and rconverter.swift_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
      {%- set conversion = rconverter.swift_ref_internal.snippet(rconverter.sc_to_swift.converted_name('result'), reference='self', nullable=vars.nullable_return) %}
      {%- if conversion %}
      {{conversion}}{% endif %}
      {%- endif %}
      return {{result_converter.converted_name('result')}}
      {%- endmacro %}
      {%- set override = cxx.is_override and not is_interface_override -%}
      public {{'override ' if override}}var {% if cxx.is_template -%}
                                           {%- for name in template_args_postfixes or [] %}
                                           {%- if name != None %}{{name}}{% else %}{{template_type_converters[loop.index - 1].custom.tname}}{% endif %}
                                           {%- endfor %}
                                           {%- else %}{{vars.name}}
                                           {%- endif -%}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} {
        {%- if setter is defined %}
        {%- if 'no_throw' not in vars.throws -%}
        {%- do Error.error("{}.{}: swift property setter cannot throw, invalid value of 'throws' variable".format(setter.owner_class.cxx.displayname, setter.cxx.displayname)) -%}
        {%- endif -%}
        {%- set incorrect_nullable_args = setter.vars.nullable_arg|reject('in', setter.args|map(attribute='name'))|list %}
        {%- if incorrect_nullable_args  %}
        {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), setter.owner_class.cxx.displayname, setter.cxx.displayname)) %}
        {%- endif %}
        {%- set converter = setter.args[0].converter.swift_to_sc %}
        get {
          {{get_property()|indent(4)}}
        }

        set(value) {
          {%- set conversion = converter.snippet('value', nullable=vars.nullable_return) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          var cppbindErr = CppBindCObject()
          _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{setter.vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}(cself, {{converter.converted_name('value')}}, &cppbindErr)
          {%- if rconverter.sc_cleanup %}
          {%- set cleanup_code_fragment = rconverter.sc_cleanup.snippet(converter.converted_name('value')) %}
          {%- if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(4)}}
          {%- endif %}
          {%- endif %}
          {{gen_exc_switch_block()|indent(4)}}
          {%- if setter.vars.keep_alive %}
          {%- set args = [namespace(name='value', converter=rconverter)] %}
          {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
          {%- if invalid_args  %}
          {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
          {%- endif %}
          {%- for arg_idx in vars.keep_alive %}
          {%- set converter = args[arg_idx - 1].converter %}
          {%- if converter.swift_keep_alive %}
          {{converter.swift_keep_alive.snippet('self', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
          {%- endif %}
          {%- endfor %}
          {%- endif %}
        }
        {%- else %}
        {{get_property()|indent(2)}}
        {%- endif %}
      }{{new_line}}
    interface_properties: |
      {%- set result_converter = rconverter.sc_to_swift -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      var {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} { get{% if setter is defined %} set{% endif %} }
  cc:
    include: *var_getter_cxx_include
    forward_decl: *var_getter_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join %}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- if cxx.is_template -%}
      {%- set template_args = '<' + template_choice.values()|format_list("{type}", 'type')|join(', ') + '>' -%}
      {%- else -%}
      {%- set template_args = '' -%}
      {%- endif -%}
      {%- macro gen_exc_catch_block(vars) -%}
      catch (const std::exception& e) {
          {%- set std_exc_conv = make_type_converter('std::exception') %}
          cppbind_err->type = strdup({{std_exc_conv.cxx_type_name_global.snippet()}});
          cppbind_err->ptr = new std::exception(e);
      } catch (...) {
          cppbind_err->type = strdup("Uncaught Exception");
      }
      {%- endmacro -%}
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{owner_class.converter.c.target_type_name}} cself, CppBindCObject* _Nonnull cppbind_err) {
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.vars.shared_ref else owner_class.converter.c_to_cxx -%}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          try {
              const auto& result = {{this_converter.converted_name('cself')}}->{{cxx.name}}{{template_args}}();
              {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
              return {{rconverter.cxx_to_c.converted_name('result')}};
          } {{gen_exc_catch_block(vars)|indent(4)}}
          {{rconverter.c.target_type_name}} result {};
          return result;
      }
      {%- if setter is defined %}
      {% set converter = setter.args[0].converter.c_to_cxx %}
      void _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{setter.vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{owner_class.converter.c.target_type_name}} cself, {{setter.args[0].converter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{setter.args[0].name}}, CppBindCObject* _Nonnull cppbind_err) {
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          {{converter.snippet(setter.args[0].name, nullable=vars.nullable_return)|indent(4)}}
          try {
              {{this_converter.converted_name('cself')}}->{{setter.cxx.name}}{{template_args}}({{converter.converted_name(setter.args[0].name)}});
          } {{gen_exc_catch_block(setter.vars)|indent(4)}}
      }
      {%- endif %}{{new_line}}
  ch:
    include: *var_method_c_include
    body:
      content: |
        {%- set cxx_namespace = owner_class.cxx.namespace.split('::')|map('capitalize')|join %}
        {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{owner_class.converter.c.target_type_name}} cself, CppBindCObject* _Nonnull cppbind_err);
        {%- if setter is defined %}
        {% set converter = setter.args[0].converter.c %}
        void _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{setter.vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{owner_class.converter.c.target_type_name}} cself, {{converter.target_type_name}}
        {%- if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{setter.args[0].name}}, CppBindCObject* _Nonnull cppbind_err);
        {% endif %}
