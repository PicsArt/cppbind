# Copyright (c) 2022 PicsArt, Inc.
# All rights reserved. Use of this source code is governed by a
# MIT-style license that can be found in the LICENSE file.

file:
  swift:
    file_path: |
      {{vars.file_fullname}}
    scopes:
      - include
      - body
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      {{[include, 'import Foundation', 'import ' + vars.c_wrapper_lib_name]|sort_snippets(cmp=cppbind_helper.imports_comparator)|join(new_line)}}

      {{body}}
  cc:
    file_path: |
      {{vars.c_file_fullname}}
    scopes:
      - body
      - include
      - glob_decl
      - glob_def
      - forward_decl
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include <iostream>
      #include <stdlib.h>
      #include <string.h>
      #include <cxxabi.h>
      #include <memory>
      #include <type_traits>
      #include "{{path.relpath(vars.h_file_fullname, vars.out_prj_dir)}}"
      {{cxx_helper_includes|format_list('#include "{}"')|join(new_line)}}
      {{include}}
      {%- if glob_decl %}

      {{glob_decl}}
      {%- endif %}
      {%- if glob_def %}

      {{glob_def}}
      {%- endif %}
      {%- if forward_decl %}

      {{forward_decl}}
      {%- endif %}

      {{body}}{{new_line}}
  ch:
    file_path: |
      {{vars.h_file_fullname}}
    scopes:
      - body
      - include
    content: |
      {%- set file_rel_path_id = path.relpath(vars.h_file_fullname, vars.out_prj_dir)|replace(pat_sep, '_')|replace('.', '_')|upper -%}
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #ifndef _{{file_rel_path_id}}_
      #define _{{file_rel_path_id}}_
      {% set include_format = '#include <{}>' if vars.is_c_wrapper_external else '#include "{}"' %}
      {{c_helper_includes|format_list(include_format)|join(new_line)}}
      {{include}}
      #include <stdbool.h>

      #if __cplusplus
      extern "C" {
      #endif
          {{body | string | indent}}
      #if __cplusplus
      }
      #endif
      #endif /* ifndef _{{file_rel_path_id}}_ */{{new_line}}

package:

enum:
  swift:
    body: |
      {%- if vars.header_code_fragment -%}
      {{vars.header_code_fragment}}{{new_line}}
      {% endif -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
      {% endif -%}
      public enum {{vars.name}}: CInt{{', ' if vars.bases_list}}{{vars.bases_list|join(', ')}} {
      {%- for case in cxx.enum_cases -%}
      {%-   if case.name not in vars.enum_excluded_cases -%}
      {%-     if case.comment %}
        {{case.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)|indent(2)}}
      {%-     endif %}
        case {{vars.enum_case_names.get(case.name, vars.enum_case_name_prefix + case.name)}} = {{case.value}}
      {%-   endif %}
      {%- endfor %}
      {%- if vars.code_fragment %}

        {{vars.code_fragment|indent(2)}}
      {%- endif %}
      }
      {%- if vars.footer_code_fragment -%}
      {{new_line}}{{vars.footer_code_fragment}}
      {%- endif %}{{new_line}}

var_class_cxx_include: &var_class_cxx_include
    unique_content:
      !concat
      - !include cxx_macros.yaml&includes
      - !include common_macros.yaml&includes.cxx
      - |
        {%- set includes = [] -%}
        {%- set converter = get_type_converter(cxx.type) -%}
        {%- do collect_includes(converter, includes) -%}
        {%- do collect_desc_includes(converter, includes) -%}
        {%- if includes -%}
        {{includes|join(marker)}}
        {%- endif -%}
        {%- set includes = gen_user_defined_cxx_includes(vars) -%}
        {%- if includes -%}{{includes}}{%- endif -%}

var_class_cxx_glob_decl: &var_class_cxx_glob_decl
    unique_content:
      !concat
      - !include common_macros.yaml&global_declarations.class
      - |
        {{gen_glob_decl()}}

var_class_swift_include: &var_class_swift_include
  unique_content:
    !concat
    - !include common_macros.yaml&includes.target_language
    - |
      {{marker if vars.include}}{{vars.include|format_list("import {}")|join_unique}}
      {%- set import_converters = [] -%}
      {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
      {%- for base in base_types_converters -%}
      {%-   do collect_import_converters(base, import_converters) -%}
      {%- endfor -%}
      {%- set desc_import_converters = [] -%}
      {%- set converter = get_type_converter(cxx.type) -%}
      {%- do collect_desc_import_converters(converter, desc_import_converters) -%}
      {%- for import_converter, _ in import_converters -%}
      {%-   if import_converter.swift_include is defined -%}
      {{marker}}{{import_converter.swift_include.snippet(full_package=vars.full_package)}}
      {%-   endif -%}
      {%- endfor -%}
      {%- for desc_import_converter, gen_for_impl in desc_import_converters -%}
      {#- we need to import implementation classes for object construction (`gen_for_impl` is for tracking nested types) -#}
      {%-   if desc_import_converter.swift_include is defined -%}
      {{marker}}{{desc_import_converter.swift_include.snippet(interface_class=(gen_for_impl and desc_import_converter.vars.action=='gen_interface'))}}
      {%-   endif -%}
      {%- endfor -%}

class:
  swift:
    include: *var_class_swift_include
    body:
      scopes:
        - head
        - properties
        - body
        - private_external
      content:
        !concat
        - !include swift_macros.yaml&exception_handling
        - !include swift_macros.yaml&special_functions.declarations
        - |
          {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
          {%-   do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
          {%- endif -%}
          {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
          {%- if vars.header_code_fragment -%}
                {{vars.header_code_fragment}}{{new_line}}
          {% endif -%}
          {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
          {%- set ancestor_infos = cxx.ancestors|type_info(error=False)|reject('none')|selectattr('has_api')|list %}
          {%- set base_interfaces = base_types_converters|selectattr('type_info.vars.action', 'equalto', 'gen_interface')|map(attribute='swift.target_type_name')|list -%}
          {%- set base_classes = base_types_converters|rejectattr('type_info.vars.action', 'equalto', 'gen_interface')|map(attribute='swift.target_type_name')|list -%}
          {%- set bases_specifiers =  base_classes + base_interfaces + vars.bases_list -%}
          {%- if base_classes|length > 1 %}
          {%-   do Error.critical(cxx.type_name + ' has more than 1 non abstract base type.') %}
          {%- endif %}
          {%- if ancestor_infos|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
          {%-   do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
          {%- endif %}
          {%- if vars.comment -%}
          {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
          {% endif -%}
          {%- set hash_fns = (body|string).split(new_line)|select('contains', hash_decl)|list -%}
          {%- set is_hashable = hash_fns|length == 1 and hash_fns|select('contains', 'override')|list|length == 0 -%}
          {%- set string_fns = (body|string).split(new_line)|select('contains', tostring_decl)|list -%}
          {%- set is_string_convertible = string_fns|length == 1 and string_fns|select('contains', 'override')|list|length == 0 -%}
          {%- set converter = get_type_converter(cxx.type) -%}
          {%- set class_name = converter.swift.get_target_type_name(definition=True) -%}
          {#- NOTE: in case of equatable currently we cannot identify whether the base class has defined it or not so incorrect comformance will be generated for overriden equals#}
          {%- set is_equatable = equals_decl|replace('Self', class_name) in body|string -%}
          {%- if is_hashable -%}
          {%-   do bases_specifiers.append('Hashable') -%}
          {%- endif -%}
          {%- if is_equatable and not is_hashable-%}
          {%-   do bases_specifiers.append('Equatable') -%}
          {%- endif -%}
          {%- if is_string_convertible %}
          {%-   do bases_specifiers.append('CustomStringConvertible') -%}
          {%- endif -%}
          {%- if vars.is_exception and not ancestor_infos|selectattr('vars.is_exception', 'equalto', True)|list -%}
          {%-   do bases_specifiers.append('Error') -%}
          {%- endif -%}
          public class {{class_name}}{{': ' + bases_specifiers|join(', ') if bases_specifiers}} {
          {%- if not base_classes %}

            /// An internal property to keep a reference to the original C++ object.
            /// It is intended to be used by the generated code.
            public let cself: {{converter.sc.target_type_name}}

            /// An internal property to keep track whether Swift is responsible for deallocating the underlying C++ object or not.
            /// It is intended to be used by the generated code.
            public let owner: Bool
            private var refs: [Any]

            /// internal main initializer
            internal required init(_ _cself: {{converter.sc.target_type_name}}, _ _owner: Bool = false) {
              self.cself = _cself
              self.owner = _owner
              self.refs = []
            }

            deinit {
              release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.target_type_name|replace('.',  '_')}}(cself, owner)
            }

            /// An internal method to bind the lifetimes of the current and another object.
            /// It is intended to be used by the generated code.
            public func keepCppBindReference(_ object: Any) {
              self.refs.append(object)
            }{{new_line}}
          {%- else %}
            /// internal main initializer
            internal required init(_ _cself: CppBindCObject, _ _owner: Bool = false) {
              super.init(_cself, _owner)
            }{{new_line}}
          {%- endif %}
          {%- if descendants %}
            /// internal dummy initializer to prevent automatic initializer inheritance
            internal init(_cself: {{converter.sc.target_type_name}}, _self: {{converter.swift.target_type_name}}) {
              fatalError("A dummy internal initializer should not be called.")
            }{{new_line}}
          {%- endif %}
          {%- if head %}
            {{head|string|indent(2)}}
          {%- endif %}
          {%- if properties %}
            {{properties|string|indent(2)}}
          {%- endif %}
          {%- if body %}
            {{body|string|indent(2)}}
          {%- endif %}
            /// An internal property to keep an information about the underlying C++ object type.
            /// It is intended to be used by the generated code.
            {{'override ' if base_classes}}class var cppbindCxxTypeName : String { return "{{cxx.type_name}}" }
          {%- if (vars.descendants if vars.descendants is not none else descendants) and cxx.is_polymorphic %}
          {%-   set polymorphic_base_converter = base_types_converters|selectattr('type_info.vars.action', 'equalto', 'gen_class')|selectattr('type_info.cxx.is_polymorphic', 'equalto', true)|first|default(none) %}

            /// An internal method to create a Swift object from a C++ object.
            /// It is intended to be used by the generated code.
            {{'override ' if polymorphic_base_converter and (polymorphic_base_converter.type_info.vars.descendants if polymorphic_base_converter.type_info.vars.descendants is not none else polymorphic_base_converter.type_info.descendants)}}class func cppbindConstructObject(_ cppbindObj: CppBindCObject, _ owner: Bool = false) -> {{converter.swift.target_type_name}} {
              {{converter.swift_obj_construction.snippet(name="cppbindObj")|indent(4)}}
            }
          {%- endif %}
          }
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {%- endif %}{{new_line}}
  cc:
    include: *var_class_cxx_include
    glob_decl: *var_class_cxx_glob_decl
    glob_def:
      unique_content: |
        {%- set converter = get_type_converter(cxx.type) -%}
        const char* {{converter.cxx_type_name_global.snippet()}} = "{{cxx.type_name}}";
    body:
      content: |
        {%- set converter = get_type_converter(cxx.type) -%}
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
        {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
        {%- set is_root_class = base_types_converters|rejectattr('type_info.vars.action', 'equalto', 'gen_interface')|list|length == 0 %}
        {%- if is_root_class -%}
        void release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.target_type_name|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner) {
        {%- if cxx.namespace %}
            using namespace {{cxx.namespace}};
        {%- endif %}
        {%- if not vars.shared_ref and cxx.is_polymorphic and (vars.descendants if vars.descendants is not none else descendants) %}
            static_assert(std::has_virtual_destructor<{{cxx.type_name}}>::value, {{'"{} type must have virtual destructor"'.format(cxx.type_name)}});
        {%- endif %}
            if (owner) {
        {#- here is used almost the same logic as for c_to_cxx section of Object/std::shared_ptr type converter (instead of constructing target value we delete it here) -#}
        {%- set descendants = vars.descendants if vars.descendants is not none else descendants %}
        {%- if descendants %}
                if (strcmp(cself.type, {{converter.cxx_type_name_global.snippet()}}) == 0)
        {%-   if vars.shared_ref %}
                    delete static_cast<std::shared_ptr<{{cxx.type_name}}>*>(cself.ptr);
        {%-   else %}
                    delete static_cast<{{cxx.type_name}}*>(cself.ptr);
        {%-   endif %}
        {%-   for descendant in descendants %}
                else if (strcmp(cself.type, {{get_type_converter(descendant).cxx_type_name_global.snippet()}}) == 0)
        {%-     if vars.shared_ref %}
                    delete static_cast<std::shared_ptr<{{descendant}}>*>(cself.ptr);
        {%-     else %}
                    delete static_cast<{{descendant}}*>(cself.ptr);
        {%-     endif %}
        {%-   endfor %}
                else {
                    std::cerr << "Unexpected object type: " << cself.type << std::endl;
                    exit(1);
                }
        {%- else -%}
        {%-   if vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{cxx.type_name}}>*>(cself.ptr);
        {%-   else %}
                delete static_cast<{{cxx.type_name}}*>(cself.ptr);
        {%-   endif %}
        {%- endif %}
            }
            free(cself.type);
        }
        {% endif -%}
        {#- object recover function is generated for all classes (not only for bases with reusing them for derived types) since the performance would be lowered in case of superbases with deep hierarchy -#}
        {%- if descendants -%}
        {%- set this_converter = get_type_converter('std::shared_ptr<' + cxx.type_name + '>') if vars.shared_ref else converter -%}
        {{new_line if is_root_class}}{{this_converter.cxx_obj_recover_func_decl.snippet(name="cppbindObj")}} {
            {{this_converter.cxx_obj_recover.snippet(name="cppbindObj")|indent(4)}}
        }
        {% endif -%}
  ch:
    body:
      content: |
        {%- set converter = get_type_converter(cxx.type) -%}
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
        {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
        {%- set is_root_class = base_types_converters|rejectattr('type_info.vars.action', 'equalto', 'gen_interface')|list|length == 0 %}
        {%- if is_root_class -%}
        void release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.target_type_name|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner);
        {%- endif -%}


interface:
  swift:
    include: *var_class_swift_include
    body:
      scopes:
        - interface_head
        - interface_properties
        - interface_body
        - head
        - properties
        - body
      content: |
        {%- if not cxx.is_polymorphic and cxx.has_multiple_base_branches -%}
        {%- do Error.critical(cxx.type_name + ' is not polymorphic but has multiple branches in its base hierarchy') -%}
        {%- endif -%}
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join -%}
        {%- if vars.header_code_fragment -%}
        {{vars.header_code_fragment}}{{new_line}}
        {% endif -%}
        {%- set base_types_converters = cxx.base_types|type_converter(error=False)|reject('none')|list %}
        {%- set ancestor_infos = cxx.ancestors|type_info(error=False)|reject('none')|selectattr('has_api')|list %}
        {%- set bases_specifiers = base_types_converters|map(attribute='swift.target_type_name')|list + vars.bases_list -%}
        {%- if base_types_converters|rejectattr('type_info.vars.action', 'equalto', 'gen_interface')|list|length > 1 %}
        {%-   do Error.critical(cxx.type_name + ' has more than 1 non abstract base type.') %}
        {%- endif %}
        {%- if ancestor_infos|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
        {%-   do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
        {%- endif %}
        {%- if vars.comment -%}
        {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
        {% endif -%}
        {%- set converter = get_type_converter(cxx.type) -%}
        public protocol {{converter.swift.get_target_type_name(definition=True)}}{{': ' + bases_specifiers|join(', ') if bases_specifiers}} {

        {%- if not base_types_converters %}
          /// An internal property to keep a reference to the original C++ object.
          /// It is intended to be used by the generated code.
          var cself: {{converter.sc.target_type_name}} { get }{{new_line}}
          /// An internal method to bind the lifetimes of the current and another object.
          /// It is intended to be used by the generated code.
          func keepCppBindReference(_ object: Any)
        {%- endif %}
        {%- if interface_head %}
          {{interface_head|string|indent(2)}}
        {%- endif %}
        {%- if interface_properties %}
          {{interface_properties|string|indent(2)}}
        {%- endif %}
        {%- if interface_body %}
          {{interface_body|string|indent(2)}}
        {%- endif %}
        }

        extension {{converter.swift.get_target_type_name(definition=True)}} {
        {%- if properties %}
          {{properties|string|indent(2)}}
        {%- endif %}
        {%- if body %}
          {{body|string|indent(2)}}
        {%- endif %}
        }

        public class {{converter.swift.get_target_type_name(interface_class=True, definition=True)}}: {{converter.swift.target_type_name}} {
          public let cself: {{converter.sc.target_type_name}}
          public let owner: Bool
          private var refs: [Any]

          /// internal main initializer
          internal required init(_ _cself: {{converter.sc.target_type_name}}, _ _owner: Bool = false) {
            self.cself = _cself
            self.owner = _owner
            self.refs = []
          }

          deinit {
            release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.get_target_type_name(interface_class=True)|replace('.',  '_')}}(cself, owner)
          }

          public func keepCppBindReference(_ object: Any) {
            self.refs.append(object)
          }{{new_line}}
        {%- if head %}
          {{head|string|indent(2)}}
        {%- endif %}
          /// An internal property to keep an information about the underlying C++ object type.
          /// It is intended to be used by the generated code.
          {{'override ' if base_types_converters|rejectattr('type_info.vars.action', 'equalto', 'gen_interface')|list}}class var cppbindCxxTypeName : String { return "{{cxx.type_name}}" }
        {#- object construction function is generated for all classes (not only for bases with reusing them for derived types) since the performance would be lowered in case of superbases with deep hierarchy -#}
        {%- if (vars.descendants if vars.descendants is not none else descendants) and cxx.is_polymorphic %}

          /// An internal method to create a Swift object from a C++ object.
          /// It is intended to be used by the generated code.
          class func cppbindConstructObject(_ cppbindObj: CppBindCObject, _ owner: Bool = false) -> {{converter.swift.target_type_name}} {
            {{converter.swift_obj_construction.snippet(name="cppbindObj")|indent(4)}}
          }
        {%- endif %}
        }
        {%- if vars.footer_code_fragment %}
        {{new_line}}{{vars.footer_code_fragment}}
        {%- endif %}{{new_line}}
  cc:
    include: *var_class_cxx_include
    glob_decl: *var_class_cxx_glob_decl
    glob_def:
      unique_content: |
        {%- set converter = get_type_converter(cxx.type) -%}
        const char* {{converter.cxx_type_name_global.snippet()}} = "{{cxx.type_name}}";
    body:
      content: |
        {%- set converter = get_type_converter(cxx.type) -%}
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join -%}
        void release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.get_target_type_name(interface_class=True)|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner) {
        {%- if cxx.namespace %}
            using namespace {{cxx.namespace}};
        {%- endif %}
        {%- if not vars.shared_ref and cxx.is_polymorphic and (vars.descendants if vars.descendants is not none else descendants) %}
            static_assert(std::has_virtual_destructor<{{cxx.type_name}}>::value, {{'"{} type must have virtual destructor"'.format(cxx.type_name)}});
        {%- endif %}
            if (owner) {
        {#- here is used almost the same logic as for jni_to_cxx section of Object/std::shared_ptr type converter (instead of constructing target value we delete it here) -#}
        {%- set descendants = vars.descendants if vars.descendants is not none else descendants %}
        {%- if descendants %}
                if (strcmp(cself.type, {{converter.cxx_type_name_global.snippet()}}) == 0)
        {%-   if vars.shared_ref %}
                    delete static_cast<std::shared_ptr<{{cxx.type_name}}>*>(cself.ptr);
        {%-   else %}
                    delete static_cast<{{cxx.type_name}}*>(cself.ptr);
        {%-   endif %}
        {%-   for descendant in descendants %}
                else if (strcmp(cself.type, {{get_type_converter(descendant).cxx_type_name_global.snippet()}}) == 0)
        {%-     if vars.shared_ref %}
                    delete static_cast<std::shared_ptr<{{descendant}}>*>(cself.ptr);
        {%-     else %}
                    delete static_cast<{{descendant}}*>(cself.ptr);
        {%-     endif %}
        {%-   endfor %}
                else {
                    std::cerr << "Unexpected object type: " << cself.type << std::endl;
                    exit(1);
                }
        {%- else -%}
        {%- if vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{cxx.type_name}}>*>(cself.ptr);
        {%-   else %}
                delete static_cast<{{cxx.type_name}}*>(cself.ptr);
        {%-   endif %}
        {%- endif %}
            }
            free(cself.type);
        }
        {% if descendants %}
        {%- set this_converter = get_type_converter('std::shared_ptr<' + cxx.type_name + '>') if vars.shared_ref else converter %}
        {{this_converter.cxx_obj_recover_func_decl.snippet(name="cppbindObj")}} {
            {{this_converter.cxx_obj_recover.snippet(name="cppbindObj")|indent(4)}}
        }{{new_line}}
        {%- endif -%}
  ch:
    body:
      content: |
        {%- set converter = get_type_converter(cxx.type) -%}
        {%- set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join -%}
        void release_{{cxx_namespace + "_" if cxx_namespace}}{{converter.swift.get_target_type_name(interface_class=True)|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner);

var_method_swift_include: &var_method_swift_include
  unique_content:
    !concat
    - !include swift_macros.yaml&includes.swift
    - |
      {%- for arg_converter in cxx.args|type_converter(attribute='type') -%}
      {{gen_import(arg_converter)}}
      {%- endfor -%}
      {%- if cxx.result_type -%}
      {{gen_import(get_type_converter(cxx.result_type))}}
      {%- endif -%}

var_method_cxx_include: &var_method_cxx_include
  unique_content:
    !concat
    - !include cxx_macros.yaml&includes
    - !include common_macros.yaml&includes.cxx
    - |
      {%- if vars.is_proj_type -%}
      {{marker}}#include "{{vars.prj_rel_file_name}}"
      {%- endif -%}
      {%- for arg in cxx.args -%}
      {{gen_include(get_type_converter(arg.type))}}
      {%- endfor -%}
      {%- if cxx.result_type -%}
      {{gen_include(get_type_converter(cxx.result_type))}}
      {%- endif -%}
      {%- set includes = gen_user_defined_cxx_includes(vars) -%}
      {%- if includes -%}{{includes}}{%- endif -%}

var_method_c_include: &var_method_c_include
  unique_content: |
    {%- macro gen_include(converter) -%}
    {%-   if converter.c_include is defined -%}
    {{marker}}{{converter.c_include.snippet()}}
    {%-   endif -%}
    {%- endmacro -%}
    {%- for arg in cxx.args|default([]) -%}
    {{gen_include(get_type_converter(arg.type))}}
    {%- endfor -%}
    {%- if cxx.result_type -%}
    {{gen_include(get_type_converter(cxx.result_type))}}
    {%- endif -%}

var_method_cxx_forward_decl: &var_method_cxx_forward_decl
  unique_content:
    !concat
    - !include common_macros.yaml&forward_declarations.method
    - |
      {{gen_fwd_decl()}}

var_method_cxx_glob_decl: &var_method_cxx_glob_decl
  unique_content:
    !concat
    - !include common_macros.yaml&global_declarations.method
    - |
      {{gen_glob_decl()}}

constructor:
  swift:
    include: *var_method_swift_include
    head:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - !include swift_macros.yaml&constructor
      - |
        {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', cxx.args|map(attribute='name'))|list -%}
        {%- if incorrect_nullable_args -%}
        {%-   do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), cxx.parent.displayname, cxx.displayname)) -%}
        {%- endif -%}
        {#- this should go to shared macro -#}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   if vars.comment -%}
        {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
        {%    endif -%}
        {%-   set comma = joiner(', ') -%}
        public convenience init(
        {%-   for arg in args -%}
        {%-     set arg_converter = get_type_converter(arg.type) -%}
        {%-     set arg_type_info = get_type_info(arg.type) -%}
        {{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{arg_converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
        {%-     if arg.default -%}
        {%-       if arg.type.is_enum %}
        {%-         set enum_case_name = arg.default.split('::')|last %}
        {%-         if enum_case_name in arg_type_info.vars.enum_excluded_cases -%}
        {%-           do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} constructor argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.parent.displayname, cxx.displayname)) -%}
        {%-         else %} = {{arg_converter.swift.target_type_name}}.{{arg_type_info.vars.enum_case_names.get(enum_case_name, arg_type_info.vars.enum_case_name_prefix + enum_case_name)}}
        {%-         endif -%}
        {%-       else -%}
        {%-         if arg.default_is_literal %} = {{"\"{}\"".format(arg.default[1]) if arg.type.is_char else arg.default}}
        {%-         elif arg.default_is_nullptr %} = nil
        {%-         endif %}
        {%-       endif %}
        {%-     endif -%}
        {%-   endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}{
        {%-   set call_args = [] %}
        {%-   for arg in args %}
        {%-     set converter = get_type_converter(arg.type).swift_to_sc %}
        {%-     set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%-     set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-     if conversion %}
          {{conversion|indent(2)}}
        {%-     endif %}
        {%-     do call_args.append(converter.converted_name(arg_name)) %}
        {%-   endfor %}
          var cppbindErr = CppBindCObject()
          self.init({{gen_constructor_c_name(target_overloading_index)}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr), true)
        {#- This should go to shared macro -#}
        {%-   if vars.keep_alive %}
        {%-     set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
        {%-     if invalid_args  %}
        {%-       do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
        {%-     endif %}
        {%-     for arg_idx in vars.keep_alive %}
        {%-       set converter = get_type_converter(args[arg_idx - 1].type) %}
        {%-       if converter.swift_keep_alive %}
          {{converter.swift_keep_alive.snippet('self', reference=args[arg_idx - 1].name|to_camel_case)|indent(2)}}
        {%-       endif %}
        {%-     endfor %}
        {%-   endif %}
        {%-   for arg in args %}
        {%-     set arg_converter = get_type_converter(arg.type) %}
        {%-     if arg_converter.sc_cleanup is defined %}
        {%-       set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%-       set cleanup_code_fragment = arg_converter.sc_cleanup.snippet(arg_converter.swift_to_sc.converted_name(arg_name)) %}
        {%-       if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(2)}}
        {%-       endif %}
        {%-     endif %}
        {%-   endfor %}
          if cppbindErr.type != nil {
            let errorType = String(cString: cppbindErr.type!)
            switch errorType {
        {%-   if 'no_throw' not in vars.throws %}
        {%-     for exc_type in vars.throws %}
            case ("{{exc_type}}"):
        {%-       set exc_info = get_type_info(exc_type) %}
              throw {{exc_info.vars.name}}(cppbindErr, true)
        {%-     endfor %}
        {%-   endif %}
        {%-   if not 'std::exception' in vars.throws %}
            case ("std::exception"):
        {%-   set exc_info = get_type_info("std::exception") %}
              let excObj = {{exc_info.vars.name}}(cppbindErr, true)
              ExceptionHandler.handleUncaughtException(excObj.what())
        {%-   endif %}
            default:
              cppbindErr.type.deallocate()
              ExceptionHandler.handleUncaughtException("Uncaught Exception")
            }
          }
        }
        {%- endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(cxx.args)}}{{new_line}}
  cc:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - !include swift_macros.yaml&constructor
      - |
        {#- this should go to shared macro -#}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   set comma = joiner(', ') -%}
        {%-   set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {%-   set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join -%}
        {{parent_class_converter.c.target_type_name}} {{gen_constructor_c_name(target_overloading_index)}}(
        {%-   for arg in args -%}
        {%-     set arg_converter = get_type_converter(arg.type) -%}
        {{comma()}}{{arg_converter.c.target_type_name}}
        {%-     if arg_converter.custom.is_c_pointer_type %} {{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err) {
        {%- if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%- endif %}
        {%-   set call_args = [] -%}
        {%-   for arg in args -%}
        {%-     set arg_converter = get_type_converter(arg.type) -%}
        {%-     set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%-     set converter = arg_converter.c_to_cxx %}
        {%-     set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-     if conversion %}
            {{conversion|indent(4)}}
        {%-     endif %}
        {%-     do call_args.append(converter.converted_name(arg_name)) -%}
        {%    endfor %}
            try {
        {%- if cxx.kind_name in ('constructor',  'constructor_template') %}
                auto this_object = new {{cxx.parent.type_name}}({{call_args|join(', ')}});
        {%- else %}
                auto this_object = {{cxx.parent.type_name}}::{{cxx.name}}({{call_args|join(', ')}});
        {%- endif %}
        {%- if parent_class_converter.type_info.vars.shared_ref %}
                return {strdup({{parent_class_converter.cxx_type_name_global.snippet()}}), new std::shared_ptr<{{cxx.parent.type_name}}>(this_object)};
        {%- else %}
                return {strdup({{parent_class_converter.cxx_type_name_global.snippet()}}), this_object};
        {%- endif %}
            }
        {%-   if 'no_throw' not in vars.throws -%}
        {%-     for exc_type in vars.throws %} catch (const {{exc_type}}& e) {
        {%-       set exc_conv = get_type_converter(exc_type) %}
                cppbind_err->type = strdup({{exc_conv.cxx_type_name_global.snippet()}});
                cppbind_err->ptr = new {{exc_type}}(e);
            }
        {%-     endfor %}
        {%-   endif %}
        {%-   if not 'std::exception' in vars.throws %} catch (const std::exception& e) {
        {%-     set std_exc_conv = get_type_converter('std::exception') %}
                cppbind_err->type = strdup({{std_exc_conv.cxx_type_name_global.snippet()}});
                cppbind_err->ptr = new std::exception(e);
            }
        {%-   endif %} catch (...) {
                cppbind_err->type = strdup("Uncaught Exception");
            }
            {{parent_class_converter.c.target_type_name}} result {};
            return result;
        }
        {% endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}
        {% endfor -%}{{gen_func(cxx.args)}}
  ch:
    include: *var_method_c_include
    body:
      content:
        !concat
        - !include common_macros.yaml&templates
        - !include common_macros.yaml&utils
        - !include swift_macros.yaml&constructor
        - |
          {#- this should go to shared macro -#}
          {%- macro gen_func(args, target_overloading_index=none) -%}
          {%-   set parent_class_converter = get_type_converter(cxx.parent.type) -%}
          {%-   set comma = joiner(', ') %}
          {%-   set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join %}
          {{parent_class_converter.c.target_type_name}} {{gen_constructor_c_name(target_overloading_index)}}(
          {%-   for arg in args -%}
          {%-     set arg_converter = get_type_converter(arg.type) -%}
          {{comma()}}{{arg_converter.c.target_type_name}}
          {%-     if arg_converter.custom.is_c_pointer_type %} {{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
          {%-   endfor -%}
          {{', ' if args}}CppBindCObject* _Nonnull cppbind_err);
          {%- endmacro %}
          {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
          {%- for arg_with_default in non_primitive_default_args -%}
          {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}
          {% endfor -%}{{gen_func(cxx.args)}}

method:
  swift:
    include: *var_method_swift_include
    body:
      !concat
      - !include common_macros.yaml&utils
      - !include swift_macros.yaml&validations
      - !include swift_macros.yaml&exception_handling
      - !include swift_macros.yaml&special_functions.method
      - !include common_macros.yaml&templates
      - |
        {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- do run_method_validations() -%}
        {%- if cxx.name == vars.hash_method -%}
        {{gen_hash_function()}}
        {%  elif cxx.name == vars.equals_method -%}
        {{gen_equals_function()}}
        {%  elif cxx.name == vars.tostring_method -%}
        {{gen_str_function()}}
        {%  else -%}
        {%-   set cxx_namespace = (cxx.parent.namespace.split('::')|map('capitalize')|join + '_') if cxx.parent.namespace else '' %}
        {%-   if vars.is_operator and vars.name == '[]' -%}
        {%-     set comma = joiner(', ') %}
        {# subscript operator #}
        {%-     if vars.comment -%}
        {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
        {%      endif -%}
        {%-     set comma = joiner(', ') -%}
        {%-     macro get_property() %}
        {%-       set call_args = ['cself'] -%}
        {%-       for arg in cxx.args -%}
        {%-         set arg_converter = get_type_converter(arg.type) -%}
        {%-         set converter = arg_converter.swift_to_sc %}
        {%-         set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%-         set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-         if conversion -%}
        {{conversion|indent(4)}}
        {%          endif %}
        {%-         do call_args.append(converter.converted_name(arg_name)) %}
        {%-       endfor -%}
        let result = {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name|replace('[]', '_getitem_'), get_overloading_postfix(vars) + get_template_postfix(cxx))}}({{call_args|join(', ')}})
        {%-       set conversion = rconverter.sc_to_swift.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
        {%-       if conversion %}
        {{conversion|indent(2)}}
        {%-       endif %}
        {%-       for arg in cxx.args %}
        {%-         set arg_converter = get_type_converter(arg.type) -%}
        {%-         if arg_converter.sc_cleanup is defined %}
        {%-           set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%-           set cleanup_code_fragment = arg_converter.sc_cleanup.snippet(arg_converter.swift_to_sc.converted_name(arg_name)) %}
        {%-           if cleanup_code_fragment %}
        {{cleanup_code_fragment|indent(4)}}
        {%-           endif %}
        {%-         endif %}
        {%-       endfor %}
        {%-       set result_is_shared = rconverter.type_info.vars.shared_ref|default(False) %}
        {%-       if not result_is_shared and vars.return_value_policy == 'reference_internal' and rconverter.swift_ref_internal is defined and (cxx.result_type.is_lval_reference or cxx.result_type.is_pointer) %}
        {%-         set conversion = rconverter.swift_ref_internal.snippet(rconverter.sc_to_swift.converted_name('result'), reference='self', nullable=vars.nullable_return) %}
        {%-         if conversion %}
        {{conversion|indent(4)}}{% endif %}
        {%-       endif %}
        return {{rconverter.sc_to_swift.converted_name('result')}}
        {%- endmacro %}
        {%- if vars.is_operator and vars.name == '[]' and not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference -%}
        {# subscript operator #}
        public subscript({%- for arg in cxx.args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{get_type_converter(arg.type).swift.target_type_name}}
                         {%- endfor-%}) -> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
          get {
            {{get_property()|indent(4)}}
          }

          {%- set res_converter = rconverter.swift_to_sc %}

          set(value) {
            {%- set call_args = ['cself'] %}
            {%- for arg in cxx.args %}
            {%-   set converter = get_type_converter(arg.type).swift_to_sc %}
            {%-   set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
            {%-   set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
            {%-   if conversion %}
            {{conversion|indent(4)}}
        {%-   endif %}
        {%-   do call_args.append(converter.converted_name(arg_name)) %}
        {%- endfor %}
        {%- set conversion = res_converter.snippet('value', nullable=vars.nullable_return) %}
        {%- if conversion %}
            {{conversion|indent(4)}}
            {%- endif %}
            {%- do call_args.append(res_converter.converted_name('value')) %}
            {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name|replace('[]', '_setitem_'), get_overloading_postfix(vars) + get_template_postfix(cxx))}}({{call_args|join(', ')}})
            {#- This should go to shared macro -#}
            {%- if vars.keep_alive %}
            {%-   set args = cxx.args + [namespace(name='value', converter=rconverter)] -%}
            {%-   set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
            {%-   if invalid_args %}
            {%-     do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
            {%-   endif %}
            {%-   for arg_idx in vars.keep_alive %}
            {%-     set converter = get_type_converter(cxx.args[arg_idx - 1].type) %}
            {%-     if converter.swift_keep_alive %}
            {{converter.swift_keep_alive.snippet('self', reference=cxx.args[arg_idx - 1].name|to_camel_case)|indent(4)}}
            {%-     endif %}
            {%-   endfor %}
            {%- endif %}
            {%- for arg in cxx.args %}
            {%-   set arg_converter = get_type_converter(arg.type) %}
            {%-   if arg_converter.sc_cleanup is defined %}
            {%-     set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
            {%-     set cleanup_code_fragment = arg_converter.sc_cleanup.snippet(arg_converter.swift_to_sc.converted_name(arg_name)) %}
            {%-     if cleanup_code_fragment %}
            {{cleanup_code_fragment|indent(4)}}
        {%-     endif %}
        {%-   endif %}
        {%- endfor %}
        {%- if rconverter.sc_cleanup is defined %}
        {%-   set cleanup_code_fragment = rconverter.sc_cleanup.snippet(res_converter.converted_name('value')) %}
        {%-   if cleanup_code_fragment %}
            {{cleanup_code_fragment|indent(4)}}
        {%-   endif %}
        {%- endif %}
          }
        }
        {%- elif vars.is_operator and vars.name == '[]' %}
        public subscript({%- for arg in cxx.args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{get_type_converter(arg.type).swift.target_type_name}}
                         {%- endfor-%}) -> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
          {{get_property()|indent(2)}}
        }
        {%- endif %}
        {%- else -%}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   set comma = joiner(', ') -%}
        {%-   if vars.comment -%}
        {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
        {%    endif -%}
        {%-   if vars.is_operator -%}
        public static func {{vars.name}}(cself: {{parent_class_converter.swift.target_type_name}}{{', ' if args}}{%- for arg in args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{get_type_converter(arg.type).swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
        {%-     set call_args = ['cself.cself'] -%}
        {%-   else -%}
        public {{"static " if cxx.is_static}}{{gen_override_keyword(cxx, vars, exclude_interface=true)}}func {{vars.name}}(
        {%-   for arg in args -%}{{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{get_type_converter(arg.type).swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
        {%-     set arg_converter = get_type_converter(arg.type) -%}
        {%-     set arg_type_info = get_type_info(arg.type) -%}
        {%-     if arg.default -%}
        {%-       if arg.type.is_enum %}
        {%-         set enum_case_name = arg.default.split('::')|last %}
        {%-         if enum_case_name in arg_type_info.vars.enum_excluded_cases -%}
        {%-           do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.parent.displayname, cxx.displayname)) -%}
        {%-         else %} = {{arg_converter.swift.target_type_name}}.{{arg_type_info.vars.enum_case_names.get(enum_case_name, arg_type_info.vars.enum_case_name_prefix + enum_case_name)}}
        {%-         endif -%}
        {%-       else -%}
        {%-         if arg.default_is_literal %} = {{"\"{}\"".format(arg.default[1]) if arg.type.is_char else arg.default}}
        {%-         elif arg.default_is_nullptr %} = nil
        {%-         endif %}
        {%-       endif %}
        {%-     endif -%}
        {%-   endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
        {%-   set call_args = ['cself'] if not cxx.is_static else [] %}
        {%  endif%}
        {%-   for arg in args %}
        {%-     set converter = get_type_converter(arg.type).swift_to_sc %}
        {%-     set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%-     set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-     if conversion %}
          {{conversion|indent(2)}}
        {%-     endif %}
        {%-     do call_args.append(converter.converted_name(arg_name))%}
        {%-   endfor %}
          var cppbindErr = CppBindCObject()
        {%-   set target_overloading_index = '_' + target_overloading_index|string if target_overloading_index else '' %}
        {%-   if rconverter.c.target_type_name != 'void' %}
          let result = {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name, get_overloading_postfix(vars) + get_template_postfix(cxx) + target_overloading_index)}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr)
        {%-   else %}
          {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name, get_overloading_postfix(vars) + get_template_postfix(cxx) + target_overloading_index)}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr)
        {%-   endif %}
        {#- This should go to shared macro -#}
        {%-   if vars.keep_alive %}
        {%-     if cxx.is_static %}
        {%-       do Error.critical('Cannot apply keep alive policy for a static member function: {}.{}'.format(cxx.name, cxx.parent.type_name)) -%}
        {%-     endif %}
        {%-     set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
        {%-     if invalid_args  %}
        {%-       do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
        {%-     endif %}
        {%-     for arg_idx in vars.keep_alive %}
        {%-       set converter = get_type_converter(args[arg_idx - 1].type) %}
        {%-       if converter.swift_keep_alive %}
          {{converter.swift_keep_alive.snippet('self', reference=args[arg_idx - 1].name|to_camel_case)|indent(2)}}
        {%-       endif %}
        {%-     endfor %}
        {%-   endif %}
        {%-   for arg in args %}
        {%-     set arg_converter = get_type_converter(arg.type) -%}
        {%-     if arg_converter.sc_cleanup is defined %}
        {%-       set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%-       set cleanup_code_fragment = arg_converter.sc_cleanup.snippet(arg_converter.swift_to_sc.converted_name(arg_name)) %}
        {%-       if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(2)}}
        {%-       endif %}
        {%-     endif %}
        {%-   endfor %}
          {{gen_exception_handling_code()|indent(2)}}
        {%-   if rconverter.c.target_type_name != 'void' %}
        {%-     set conversion = rconverter.sc_to_swift.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
        {%-     if conversion %}
          {{conversion|indent(2)}}
        {%-     endif %}
        {%-     set result_is_shared = rconverter.type_info.vars.shared_ref|default(False) %}
        {%-     if not result_is_shared and vars.return_value_policy == 'reference_internal' and rconverter.swift_ref_internal is defined and (cxx.result_type.is_lval_reference or cxx.result_type.is_pointer) %}
        {%-       set conversion = rconverter.swift_ref_internal.snippet(rconverter.sc_to_swift.converted_name('result'), reference='self', nullable=vars.nullable_return) %}
        {%-       if conversion %}
          {{conversion|indent(2)}}{% endif %}
        {%-     endif %}
          return {{rconverter.sc_to_swift.converted_name('result')}}
        {%-   endif %}
        }
        {%- endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(cxx.args)}}
        {%- endif %}{{new_line}}
        {%- endif %}
    interface_body: |
      {#- this should go to shared macro -#}
      {%- macro gen_func(args, target_overloading_index=none) -%}
      {%-   if vars.comment -%}
      {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
      {%    endif %}
      {%-   set comma = joiner(', ') -%}
      {%-   set rconverter = get_type_converter(cxx.result_type) -%}
      {%-   if vars.is_operator and vars.name == '[]' -%}
      subscript({%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{get_type_converter(arg.type).swift.target_type_name}}{% endfor %}) -> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} { get {{'set ' if not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference}}}
      {%-   else -%}
      func {{vars.name}}({%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{get_type_converter(arg.type).swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}{%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}}
      {%-   endif %}
      {%- endmacro -%}
      {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
      {%- for arg_with_default in non_primitive_default_args -%}
      {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
      {% endfor -%}{{gen_func(cxx.args)}}
  cc:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- set parent_class_converter = get_type_converter(cxx.parent.type) %}
        {%- set parent_class_info = parent_class_converter.type_info %}
        {%- set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join + '_' if cxx.parent.namespace else '' %}
        {%- set rconverter = get_type_converter(cxx.result_type) %}
        {%- set is_subscript_operator = vars.is_operator and vars.name == '[]' -%}
        {%- if not is_subscript_operator -%}
        {%-   macro gen_func(args, target_overloading_index=none) -%}
        {%-     set comma = joiner(', ') -%}
        {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name, get_overloading_postfix(vars) + get_template_postfix(cxx))}}{{'_' + target_overloading_index|string if target_overloading_index}}(
        {%-     if not cxx.is_static -%}
        {{parent_class_converter.c.target_type_name}} cself, {% endif -%}
        {%-     for arg in args -%}
        {%-       set arg_converter = get_type_converter(arg.type) -%}
        {{comma()}}{{arg_converter.c.target_type_name}}{% if arg_converter.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err) {
        {%- if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%- endif %}
        {%-     set call_args = [] %}
        {%-     for arg in args %}
        {%-       set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%-       set converter = get_type_converter(arg.type).c_to_cxx %}
        {%-       set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-       if conversion %}
            {{conversion|indent(4)}}
        {%-       endif %}
        {%-       do call_args.append(converter.converted_name(arg_name)) %}
        {%      endfor %}
        {%-     set this_converter = get_type_converter('std::shared_ptr<' + cxx.parent.type_name + '>').c_to_cxx if parent_class_info.vars.shared_ref else parent_class_converter.c_to_cxx -%}
        {%-     if not cxx.is_static -%}
            {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
        {%-     endif %}
        {%-     if rconverter.c.target_type_name != 'void' %}
            try {
                decltype(auto) result = {%if not cxx.is_static %}{{this_converter.converted_name('cself')}}->
                                     {%- else%}{{cxx.parent.type_name}}::{% endif -%}
                                     {{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}({{call_args|join(', ')}});
                {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
                return {{rconverter.cxx_to_c.converted_name('result')}};
            }
        {%-     else %}
            try {
                {%if not cxx.is_static %}{{this_converter.converted_name('cself')}}->{%else%}{{cxx.parent.type_name}}::{% endif %}{{cxx.name}}({{call_args|join(', ')}});
            }
        {%-     endif %}
        {%-     if 'no_throw' not in vars.throws -%}
        {%-       for exc_type in vars.throws %} catch (const {{exc_type}}& e) {
        {%-         set exc_conv = get_type_converter(exc_type) %}
                cppbind_err->type = strdup({{exc_conv.cxx_type_name_global.snippet()}});
                cppbind_err->ptr = new {{exc_type}}(e);
            }
        {%-       endfor %}
        {%-     endif %}
        {%-     if not 'std::exception' in vars.throws %} catch (const std::exception& e) {
        {%-       set std_exc_conv = get_type_converter('std::exception') %}
                cppbind_err->type = strdup({{std_exc_conv.cxx_type_name_global.snippet()}});
                cppbind_err->ptr = new std::exception(e);
            }
        {%-     endif %} catch (...) {
                cppbind_err->type = strdup("Uncaught Exception");
            }
  
        {%-     if rconverter.c.target_type_name != 'void' %}
            {{rconverter.c.target_type_name}} result {};
            return result;
        {%-     endif %}
        }
        {% endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}
        {% endfor -%}{{gen_func(cxx.args)}}
        {%- else -%}
        {%- set comma = joiner(', ') -%}
        {# subscript operator getter #}
        {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name|replace('[]', '_getitem_'), get_overloading_postfix(vars) + get_template_postfix(cxx))}}({{parent_class_converter.c.target_type_name}} cself,
        {%- for arg in cxx.args -%}
        {%- set arg_converter = get_type_converter(arg.type) -%}
        {{comma()}}{{arg_converter.c.target_type_name}}{% if arg_converter.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}) {
        {%- if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%- endif %}
        {%- set call_args = [] %}
        {%- for arg in cxx.args -%}
        {%-   set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%-   set converter = get_type_converter(arg.type).c_to_cxx %}
        {%-   set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-   if conversion %}
            {{conversion|indent(4)}}
        {%-   endif %}
        {%-   do call_args.append(converter.converted_name(arg_name)) -%}
        {% endfor %}
        {%- set this_converter = get_type_converter('std::shared_ptr<' + cxx.parent.type_name + '>').c_to_cxx if parent_class_info.vars.shared_ref else parent_class_converter.c_to_cxx -%}
            {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
        {%- if rconverter.c.target_type_name != 'void' %}
            decltype(auto) result = {{this_converter.converted_name('cself')}}->{{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}({{call_args|join(', ')}});
            {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
            return {{rconverter.cxx_to_c.converted_name('result')}};
        {%- else %}
            {{this_converter.converted_name('cself')}}->{{cxx.name}}({{call_args|join(', ')}});
        {%- endif %}
        }
        {%- if not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference %}
        {# subscript operator setter #}
        {%    set comma = joiner(', ') -%}
        void {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name|replace('[]', '_setitem_'), get_overloading_postfix(vars) + get_template_postfix(cxx))}}({{parent_class_converter.c.target_type_name}} cself, {% for arg in cxx.args -%}
        {%-   set arg_converter = get_type_converter(arg.type) -%}
            {{comma()}}{{arg_converter.c.target_type_name}}{% if arg_converter.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if cxx.args}}{{rconverter.c.target_type_name}}
        {%-   if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} value) {
        {%- if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%- endif %}
        {%-     set call_args = [] %}
        {%-     for arg in cxx.args -%}
        {%-       set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%-       set converter = get_type_converter(arg.type).c_to_cxx %}
        {%-       set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-       if conversion %}
            {{conversion|indent(4)}}
        {%-       endif %}
        {%-       do call_args.append(converter.converted_name(arg_name)) -%}
        {%      endfor %}
        {%-     set conversion = rconverter.c_to_cxx.snippet('value', nullable=vars.nullable_return) %}
        {%-     if conversion %}
            {{conversion|indent(4)}}
        {%      endif %}
        {%-     set this_converter = get_type_converter('std::shared_ptr<' + cxx.parent.type_name + '>').c_to_cxx if parent_class_info.vars.shared_ref else parent_class_converter.c_to_cxx -%}
        {%-     if not cxx.is_static %}
            {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
        {%-     endif %}
            {{this_converter.converted_name('cself')}}->{{cxx.name}}({{call_args|join(', ')}}) = value;
        }
        {%-   endif %}
        {%- endif %}
  ch:
    include: *var_method_c_include
    body:
      content:
        !concat
        - !include common_macros.yaml&templates
        - !include common_macros.yaml&utils
        - |
          {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
          {%- set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join + '_' if cxx.parent.namespace else '' -%}
          {%- set rconverter = get_type_converter(cxx.result_type) -%}
          {%- set is_subscript_operator = vars.is_operator and vars.name == '[]' -%}
          {%- if not is_subscript_operator -%}
          {%-   macro gen_func(args, target_overloading_index=none) -%}
          {%-     set comma = joiner(', ') -%}
          {%-     set target_overloading_index = '_' + target_overloading_index|string if target_overloading_index else '' -%}
          {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name|replace('[]', '_getitem_') if is_subscript_operator else vars.name, get_overloading_postfix(vars) + get_template_postfix(cxx) + target_overloading_index)}}(
          {%-     if not cxx.is_static -%}{{parent_class_converter.c.target_type_name}} cself, {% endif -%}
          {%-     for arg in args -%}
          {%-       set arg_converter = get_type_converter(arg.type) -%}
          {{comma()}}{{arg_converter.c.target_type_name}} {% if arg_converter.custom.is_c_pointer_type %}{{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
          {%-     endfor -%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err);
          {%-   endmacro -%}
          {%-   set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
          {%-   for arg_with_default in non_primitive_default_args -%}
          {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}
          {%    endfor -%}{{gen_func(cxx.args)}}
          {%- else %}
          {# subscript operator #}
          {%-   set comma = joiner(', ') %}
          {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}
          {%- endif %} {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name|replace('[]', '_getitem_') if is_subscript_operator else vars.name, get_overloading_postfix(vars) + get_template_postfix(cxx))}}({{parent_class_converter.c.target_type_name}} cself, {% for arg in cxx.args -%}
          {%- set arg_converter = get_type_converter(arg.type) -%}
          {{comma()}}{{arg_converter.c.target_type_name}} {% if arg_converter.custom.is_c_pointer_type %}{{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%});
          {# subscript operator setter #}
          {%- if not cxx.result_type.is_const_qualified and cxx.result_type.is_lval_reference %}
          {%    set comma = joiner(', ') %}
          void {{cppbind_helper.get_c_func_name(cxx_namespace + parent_class_converter.swift.target_type_name, vars.name|replace('[]', '_setitem_'), get_overloading_postfix(vars) + get_template_postfix(cxx))}}({{parent_class_converter.c.target_type_name}} cself, {% for arg in cxx.args -%}
          {%-   set arg_converter = get_type_converter(arg.type) -%}
          {{comma()}}{{arg_converter.c.target_type_name}}{% if arg_converter.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if cxx.args}}{{rconverter.c.target_type_name}}
          {%-   if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} value);
          {%-   endif %}
          {%- endif -%}


function:
  swift:
    include: *var_method_swift_include
    body:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- if vars.return_value_policy == 'reference_internal' -%}
        {%    do Error.critical("Cannot apply reference internal policy on a non member function's return value: {} in {}".format(cxx.name, cxx.source_file_name)) -%}
        {%- endif -%}
        {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', cxx.args|map(attribute='name'))|list -%}
        {%- if incorrect_nullable_args -%}
        {%-   do Error.critical("{} arguments are marked as nullable but {} does not have such arguments.".format(', '.join(incorrect_nullable_args), cxx.displayname)) -%}
        {%- endif -%}
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {#- this should go to shared macro -#}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   set comma = joiner(', ') -%}
        {%-   if vars.comment -%}
        {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
        {%    endif -%}
        public func {{vars.name}}({%- for arg in args -%}
        {%-   set arg_converter = get_type_converter(arg.type) -%}
        {%-   set arg_type_info = get_type_info(arg.type) -%}
        {{comma()}}{{vars.argument_label.get(arg.name, '')}}{{' ' if arg.name in vars.argument_label}}{{vars.argument_name.get(arg.name, arg.name)|to_camel_case}}: {{arg_converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.default_is_nullptr}}
        {%-     if arg.default -%}
        {%-       if arg.type.is_enum %}
        {%-         set enum_case_name = arg.default.split('::')|last %}
        {%-         if enum_case_name in arg_type_info.vars.enum_excluded_cases -%}
        {%-           do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {} function argument. CppBind is skipping default value addition in target language wrappers.".format(enum_case_name, arg.default.split('::')[-2], cxx.displayname)) -%}
        {%-         else %} = {{arg_converter.swift.target_type_name}}.{{arg_type_info.vars.enum_case_names.get(enum_case_name, arg_type_info.vars.enum_case_name_prefix + enum_case_name)}}
        {%-         endif -%}
        {%-       else -%}
        {%-         if arg.default_is_literal %} = {{"\"{}\"".format(arg.default[1]) if arg.type.is_char else arg.default}}
        {%-         elif arg.default_is_nullptr %} = nil
        {%-         endif %}
        {%-       endif %}
        {%-     endif %}
        {%-   endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
        {%-   set call_args = [] %}
        {%-   for arg in args %}
        {%-     set converter = get_type_converter(arg.type).swift_to_sc %}
        {%-     set arg_name = vars.argument_name.get(arg.name, arg.name)|to_camel_case -%}
        {%-     set conversion = converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr) %}
        {%-     if conversion %}
          {{conversion|indent(2)}}
        {%-     endif %}
        {%-     do call_args.append(converter.converted_name(arg_name))%}
        {%-   endfor %}
          var cppbindErr = CppBindCObject()
        {%-   set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
        {%-   set target_overloading_index = '_' + target_overloading_index|string if target_overloading_index else '' %}
        {%-   set c_func_name = cppbind_helper.get_c_func_name(cxx_namespace, vars.name, get_overloading_postfix(vars) + get_template_postfix(cxx) + target_overloading_index) %}
        {%-   if rconverter.c.target_type_name != 'void' %}
          let result = {{c_func_name}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr)
        {%-   else %}
          {{c_func_name}}({{call_args|join(', ')}}{{', ' if call_args}}&cppbindErr)
        {%-   endif %}
        {%-   for arg in args %}
        {%-     set arg_converter = get_type_converter(arg.type) %}
        {%-     if arg_converter.sc_cleanup is defined %}
        {%-       set cleanup_code_fragment = arg_converter.sc_cleanup.snippet(arg_converter.swift_to_sc.converted_name(arg.name|to_camel_case)) %}
        {%-       if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(2)}}
        {%-       endif %}
        {%-     endif %}
        {%-   endfor %}
          if cppbindErr.type != nil {
            let errorType = String(cString: cppbindErr.type!)
            switch errorType {
        {%-   if 'no_throw' not in vars.throws %}
        {%-     for exc_type in vars.throws %}
            case ("{{exc_type}}"):
        {%-       set exc_info = get_type_info(exc_type) %}
              throw {{exc_info.vars.name}}(cppbindErr, true)
        {%-     endfor %}
        {%-   endif %}
        {%-   if not 'std::exception' in vars.throws %}
            case ("std::exception"):
        {%-     set exc_info = get_type_info("std::exception") %}
              let excObj = {{exc_info.vars.name}}(cppbindErr, true)
              ExceptionHandler.handleUncaughtException(excObj.what())
        {%-   endif %}
            default:
              cppbindErr.type.deallocate()
              ExceptionHandler.handleUncaughtException("Uncaught Exception")
            }
          }
        {%-   if rconverter.c.target_type_name != 'void' %}
        {%-     set conversion = rconverter.sc_to_swift.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
        {%-     if conversion %}
          {{conversion|indent(2)}}
        {%-     endif %}
          return {{rconverter.sc_to_swift.converted_name('result')}}
        {%-   endif %}
        }
        {%- endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}{{new_line}}
        {% endfor -%}{{gen_func(cxx.args)}}{{new_line}}
  cc:
    include: *var_method_cxx_include
    forward_decl: *var_method_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {#- this should got to shared macro -#}
        {%- macro gen_func(args, target_overloading_index=none) -%}
        {%-   set comma = joiner(', ') %}
        {%-   set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join -%}
        {%-   set rconverter = get_type_converter(cxx.result_type) -%}
        {%-   set target_overloading_index = '_' + target_overloading_index|string if target_overloading_index else '' -%}
        {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{cppbind_helper.get_c_func_name(cxx_namespace, vars.name, get_overloading_postfix(vars) + get_template_postfix(cxx) + target_overloading_index)}}(
        {%-   set comma = joiner(', ') %}
        {%-   for arg in args -%}
        {%-     set arg_converter = get_type_converter(arg.type) -%}
        {{comma()}}{{arg_converter.c.target_type_name}}{% if arg_converter.custom.is_c_pointer_type -%}
        {{' _Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else ' _Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}{%- endfor-%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err) {
        {%- if cxx.namespace %}
            using namespace {{cxx.namespace}};
        {%- endif %}
        {%-     set call_args = [] %}
        {%-     for arg in args -%}
        {%-       set arg_name = vars.argument_name.get(arg.name, arg.name)|to_snake_case -%}
        {%-       set converter = get_type_converter(arg.type).c_to_cxx %}
            {{converter.snippet(arg_name, nullable=arg.name in vars.nullable_arg or arg.default_is_nullptr)|indent(4)}}
        {%-       do call_args.append(converter.converted_name(arg_name)) %}
        {%-     endfor %}
        {%-     if rconverter.c.target_type_name != 'void' %}
            try {
                decltype(auto) result = {{cxx.namespace}}::{{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}({{call_args|join(', ')}});
                {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
                return {{rconverter.cxx_to_c.converted_name('result')}};
            }
        {%-   else %}
            try {
                {{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}({{call_args|join(', ')}});
            }
        {%-   endif -%}
        {%-   if 'no_throw' not in vars.throws %}
        {%-     for exc_type in vars.throws %} catch (const {{exc_type}}& e) {
        {%-       set exc_conv = get_type_converter(exc_type) %}
                cppbind_err->type = strdup({{exc_conv.cxx_type_name_global.snippet()}});
                cppbind_err->ptr = new {{exc_type}}(e);
            }
        {%-     endfor %}
        {%-   endif %}
        {%-   if not 'std::exception' in vars.throws %} catch (const std::exception& e) {
        {%-     set std_exc_conv = get_type_converter('std::exception') %}
                cppbind_err->type = strdup({{std_exc_conv.cxx_type_name_global.snippet()}});
                cppbind_err->ptr = new std::exception(e);
            }
        {%-   endif %} catch (...) {
                cppbind_err->type = strdup("Uncaught Exception");
            }
  
        {%-   if rconverter.c.target_type_name != 'void' %}
            {{rconverter.c.target_type_name}} result {};
            return result;
            {%-   endif %}
        }
        {% endmacro -%}
        {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
        {%- for arg_with_default in non_primitive_default_args -%}
        {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}
        {% endfor -%}{{gen_func(cxx.args)}}
  ch:
    include: *var_method_c_include
    body:
      content:
        !concat
        - !include common_macros.yaml&templates
        - !include common_macros.yaml&utils
        - |
          {#- this should got to shared macro #}
          {%- macro gen_func(args, target_overloading_index=none) -%}
          {%-   set comma = joiner(', ') %}
          {%-   set cxx_namespace = cxx.namespace.split('::')|map('capitalize')|join %}
          {%-   set rconverter = get_type_converter(cxx.result_type) %}
          {%-   set target_overloading_index = '_' + target_overloading_index|string if target_overloading_index else '' %}
          {%-   set c_func_name = cppbind_helper.get_c_func_name(cxx_namespace, vars.name, get_overloading_postfix(vars) + get_template_postfix(cxx) + target_overloading_index) %}
          {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{c_func_name}}(
          {%-   for arg in args -%}
          {%-     set arg_converter = get_type_converter(arg.type) -%}
          {{comma()}}{{arg_converter.c.target_type_name}} {% if arg_converter.custom.is_c_pointer_type %}{{'_Nullable' if arg.name in vars.nullable_arg or arg.default_is_nullptr else '_Nonnull'}}{% endif %} {{vars.argument_name.get(arg.name, arg.name)|to_snake_case}}
          {%-   endfor -%}{{', ' if args}}CppBindCObject* _Nonnull cppbind_err);
          {%- endmacro -%}
          {%- set non_primitive_default_args = cxx.args|rejectattr('default', 'none')|rejectattr('type.is_enum')|rejectattr('default_is_nullptr')|rejectattr('default_is_literal')|list -%}
          {%- for arg_with_default in non_primitive_default_args -%}
          {{gen_func(cxx.args[:cxx.args.index(arg_with_default)], loop.index)}}
          {% endfor -%}{{gen_func(cxx.args)}}

var_getter_swift_include: &var_getter_swift_include
  unique_content:
    !concat
    - !include swift_macros.yaml&includes.swift
    - |
      {{gen_import(get_type_converter(cxx.result_type))}}

var_getter_cxx_include: &var_getter_cxx_include
  unique_content:
    !concat
    - !include common_macros.yaml&includes.cxx
    - |
      {{gen_include(get_type_converter(cxx.result_type))}}

var_getter_cxx_forward_decl: &var_getter_cxx_forward_decl
  unique_content:
    !concat
    - !include common_macros.yaml&forward_declarations.getter
    - |
      {{gen_fwd_decl()}}

var_property_getter_setter: &var_property_getter_setter
  swift:
    include: *var_getter_swift_include
    properties: |
      {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
      {%- set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join -%}
      {%- set rconverter = get_type_converter(cxx.result_type) -%}
      {%- if not cxx.is_public -%}
      {%-   do Error.critical("{}.{} is not a public field. Make it public or remove cppbind API.".format(cxx.parent.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- set result_converter = rconverter.sc_to_swift -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
      {% endif -%}
      {%- macro get_property() -%}
      let result = _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}(cself)
      {%-   set conversion = result_converter.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) -%}
      {%-   if conversion %}
      {{conversion}}
      {%-   endif %}
      {%-   set result_is_shared = rconverter.type_info.vars.shared_ref|default(False) %}
      {%-   if not result_is_shared and vars.return_value_policy == 'reference_internal' and rconverter.swift_ref_internal is defined and (cxx.result_type.is_lval_reference or cxx.result_type.is_pointer) %}
      {%-     set conversion = rconverter.swift_ref_internal.snippet(rconverter.sc_to_swift.converted_name('result'), reference='self', nullable=vars.nullable_return) -%}
      {%-     if conversion %}
      {{conversion}}{% endif %}
      {%-   endif %}
      return {{result_converter.converted_name('result')}}
      {%- endmacro -%}
      public var {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} {
      {%- if vars.action == 'gen_property_setter' %}
      {%-   set converter = rconverter.swift_to_sc %}
        get {
          {{get_property()|indent(4)}}
        }

        set(value) {
      {%-   set conversion = converter.snippet('value', nullable=vars.nullable_return) %}
      {%-   if conversion %}
          {{conversion|indent(4)}}
      {%-   endif %}
          _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.', '_')}}_{{vars.name}}(cself, {{converter.converted_name('value')}})
      {#-   This should go to shared macro -#}
      {%-   if vars.keep_alive %}
      {%-     set args = [namespace(name='value', converter=rconverter)] %}
      {%-     set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%-     if invalid_args  %}
      {%-       do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
      {%-     endif %}
      {%-     for arg_idx in vars.keep_alive %}
      {%-       set converter = args[arg_idx - 1].converter %}
      {%-       if converter.swift_keep_alive %}
          {{converter.swift_keep_alive.snippet('self', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
      {%-       endif %}
      {%-     endfor %}
      {%-   endif %}
      {%- if rconverter.sc_cleanup is defined %}
      {%-   set cleanup_code_fragment = rconverter.sc_cleanup.snippet(converter.converted_name('value')) %}
      {%-   if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(4)}}
      {%-   endif %}
      {%- endif %}
        }
      {%- else %}
        {{get_property()|indent(2)}}
      {%- endif %}
      }{{new_line}}
    interface_properties: |
      {%- set result_converter = get_type_converter(cxx.result_type).sc_to_swift -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
      {%  endif -%}
      var {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} { get {% if vars.action == 'gen_property_setter' %}set{% endif %} }
  cc:
    include: *var_getter_cxx_include
    forward_decl: *var_getter_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body: |
      {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
      {%- set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join -%}
      {%- set rconverter = get_type_converter(cxx.result_type) -%}
      {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}({{parent_class_converter.c.target_type_name}} cself) {
      {%- if cxx.parent.namespace %}
          using namespace {{cxx.parent.namespace}};
      {%- endif %}
      {%- set this_converter = get_type_converter('std::shared_ptr<' + cxx.parent.type_name + '>').c_to_cxx if parent_class_converter.type_info.vars.shared_ref else parent_class_converter.c_to_cxx -%}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          decltype(auto) result = {{this_converter.converted_name('cself')}}->{{cxx.name}};
          {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(4)}}
          return {{rconverter.cxx_to_c.converted_name('result')}};
      }
      {% if vars.action == 'gen_property_setter' %}
      void _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.', '_')}}_{{vars.name}}({{parent_class_converter.c.target_type_name}} cself, {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{vars.name}}) {
      {%- if cxx.parent.namespace %}
          using namespace {{cxx.parent.namespace}};
      {%- endif %}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          {{rconverter.c_to_cxx.snippet(vars.name, nullable=vars.nullable_return)|indent(4)}}
          {{this_converter.converted_name('cself')}}->{{cxx.name}} = {{rconverter.c_to_cxx.converted_name(vars.name)}};
      }
      {% endif %}
  ch:
    include: *var_method_c_include
    body:
      content: |
        {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {%- set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join -%}
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}({{parent_class_converter.c.target_type_name}} cself);
        {%- if vars.action == 'gen_property_setter' %}
        void _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.', '_')}}_{{vars.name}}({{parent_class_converter.c.target_type_name}} cself, {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{vars.name}});
        {% endif %}

property_getter: *var_property_getter_setter

property_setter: *var_property_getter_setter

getter:
  swift:
    include: *var_getter_swift_include
    properties:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {%- set rconverter = get_type_converter(cxx.result_type) -%}
        {%- set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join %}
        {%- if 'no_throw' not in vars.throws -%}
        {%-   do Error.error("{}.{}: swift property getter cannot throw, invalid value of 'throws' variable".format(cxx.parent.displayname, cxx.displayname)) -%}
        {%- endif -%}
        {%- do cppbind_helper.validate_getter(cxx, vars, setter|default(none)) -%}
        {%- do cppbind_helper.validate_template_getter_setter(cxx, vars, setter|default(none)) -%}
        {%- set result_converter = rconverter.sc_to_swift -%}
        {%- macro gen_exc_switch_block() -%}
        if cppbindErr.type != nil {
          let errorType = String(cString: cppbindErr.type!)
          switch errorType {
          case ("std::exception"):
            {%- set exc_info = get_type_info("std::exception") %}
            let excObj = {{exc_info.vars.name}}(cppbindErr, true)
            ExceptionHandler.handleUncaughtException(excObj.what())
          default:
            cppbindErr.type.deallocate()
            ExceptionHandler.handleUncaughtException("Uncaught Exception")
          }
        }
        {%- endmacro -%}
        {% if vars.comment -%}
        {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
        {% endif -%}
        {%- macro get_property() -%}
        var cppbindErr = CppBindCObject()
        let result = _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}(cself, &cppbindErr)
        {{gen_exc_switch_block()}}
        {%-   set conversion = result_converter.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
        {%-   if conversion %}
        {{conversion}}
        {%-   endif %}
        {%-   set result_is_shared = rconverter.type_info.vars.shared_ref|default(False) %}
        {%-   if not result_is_shared and vars.return_value_policy == 'reference_internal' and rconverter.swift_ref_internal is defined and (cxx.result_type.is_lval_reference or cxx.result_type.is_pointer) %}
        {%-     set conversion = rconverter.swift_ref_internal.snippet(rconverter.sc_to_swift.converted_name('result'), reference='self', nullable=vars.nullable_return) %}
        {%-     if conversion %}
        {{conversion}}{% endif %}
        {%-   endif %}
        return {{result_converter.converted_name('result')}}
        {%- endmacro -%}
        public {{gen_override_keyword(cxx, vars, exclude_interface=true)}}var {% if cxx.is_template -%}
                                             {{get_template_getter_name(cxx, template_args_postfixes)}}
                                             {%- else %}{{vars.name}}
                                             {%- endif -%}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} {
        {%- if setter is defined %}
        {%-   if 'no_throw' not in vars.throws -%}
        {%-     do Error.error("{}.{}: swift property setter cannot throw, invalid value of 'throws' variable".format(setter.cxx.parent.displayname, setter.cxx.displayname)) -%}
        {%-   endif -%}
        {%-   set incorrect_nullable_args = setter.vars.nullable_arg|reject('in', setter.cxx.args|map(attribute='name'))|list %}
        {%-   if incorrect_nullable_args  %}
        {%-     do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), setter.cxx.parent.displayname, setter.cxx.displayname)) %}
        {%-   endif %}
        {%-   set converter = get_type_converter(setter.cxx.args[0].type).swift_to_sc %}
          get {
            {{get_property()|indent(4)}}
          }
  
          set(value) {
        {%- set conversion = converter.snippet('value', nullable=vars.nullable_return) %}
        {%- if conversion %}
            {{conversion|indent(4)}}
        {%- endif %}
            var cppbindErr = CppBindCObject()
            _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{get_overloading_postfix(setter.vars)}}{{get_template_postfix(cxx)}}(cself, {{converter.converted_name('value')}}, &cppbindErr)
        {%- if rconverter.sc_cleanup is defined %}
        {%-   set cleanup_code_fragment = rconverter.sc_cleanup.snippet(converter.converted_name('value')) %}
        {%-   if cleanup_code_fragment %}
            {{cleanup_code_fragment|indent(4)}}
        {%-   endif %}
        {%- endif %}
            {{gen_exc_switch_block()|indent(4)}}
        {%- if setter.vars.keep_alive %}
        {%-   set args = [namespace(name='value', converter=rconverter)] %}
        {%-   set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
        {%-   if invalid_args  %}
        {%-     do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, cxx.parent.type_name, invalid_args)) -%}
        {%-   endif %}
        {%-   for arg_idx in vars.keep_alive %}
        {%-     set converter = args[arg_idx - 1].converter %}
        {%-     if converter.swift_keep_alive %}
            {{converter.swift_keep_alive.snippet('self', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
        {%-     endif %}
        {%-   endfor %}
        {%- endif %}
          }
        {%- else %}
          {{get_property()|indent(2)}}
        {%- endif %}
        }{{new_line}}
    interface_properties: |
      {%- set result_converter = get_type_converter(cxx.result_type).sc_to_swift -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment(style=DoxygenCommentStyle.CPP)}}
      {% endif -%}
      var {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} { get{% if setter is defined %} set{% endif %} }
  cc:
    include: *var_getter_cxx_include
    forward_decl: *var_getter_cxx_forward_decl
    glob_decl: *var_method_cxx_glob_decl
    body:
      !concat
      - !include common_macros.yaml&templates
      - !include common_macros.yaml&utils
      - |
        {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
        {%- set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join %}
        {%- set rconverter = get_type_converter(cxx.result_type) %}
        {%- macro gen_exc_catch_block(vars) -%}
        catch (const std::exception& e) {
        {%- set std_exc_conv = get_type_converter('std::exception') %}
            cppbind_err->type = strdup({{std_exc_conv.cxx_type_name_global.snippet()}});
            cppbind_err->ptr = new std::exception(e);
        } catch (...) {
            cppbind_err->type = strdup("Uncaught Exception");
        }
        {%- endmacro -%}
        {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}({{parent_class_converter.c.target_type_name}} cself, CppBindCObject* _Nonnull cppbind_err) {
        {%- if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%- endif %}
        {%- set this_converter = get_type_converter('std::shared_ptr<' + cxx.parent.type_name + '>').c_to_cxx if parent_class_converter.type_info.vars.shared_ref else parent_class_converter.c_to_cxx -%}
            {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
            try {
                decltype(auto) result = {{this_converter.converted_name('cself')}}->{{cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}();
                {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
                return {{rconverter.cxx_to_c.converted_name('result')}};
            } {{gen_exc_catch_block(vars)|indent(4)}}
            {{rconverter.c.target_type_name}} result {};
            return result;
        }
        {%- if setter is defined %}
        {%    set converter = get_type_converter(setter.cxx.args[0].type).c_to_cxx %}
        void _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{get_overloading_postfix(setter.vars)}}{{get_template_postfix(cxx)}}({{parent_class_converter.c.target_type_name}} cself, {{get_type_converter(setter.cxx.args[0].type).c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{setter.cxx.args[0].name}}, CppBindCObject* _Nonnull cppbind_err) {
        {%- if cxx.parent.namespace %}
            using namespace {{cxx.parent.namespace}};
        {%- endif %}
            {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
            {{converter.snippet(setter.cxx.args[0].name, nullable=vars.nullable_return)|indent(4)}}
            try {
                {{this_converter.converted_name('cself')}}->{{setter.cxx.name}}{{gen_template_instantiation(cxx) if cxx.is_template}}({{converter.converted_name(setter.cxx.args[0].name)}});
            } {{gen_exc_catch_block(setter.vars)|indent(4)}}
        }
        {%- endif %}{{new_line}}
  ch:
    include: *var_method_c_include
    body:
      content:
        !concat
        - !include common_macros.yaml&templates
        - !include common_macros.yaml&utils
        - |
          {%- set parent_class_converter = get_type_converter(cxx.parent.type) -%}
          {%- set cxx_namespace = cxx.parent.namespace.split('::')|map('capitalize')|join -%}
          {%- set rconverter = get_type_converter(cxx.result_type) -%}
          {{rconverter.c.target_type_name}}{% if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{get_overloading_postfix(vars)}}{{get_template_postfix(cxx)}}({{parent_class_converter.c.target_type_name}} cself, CppBindCObject* _Nonnull cppbind_err);
          {%- if setter is defined %}
          {%    set converter = get_type_converter(setter.cxx.args[0].type).c %}
          void _prop_set_{{cxx_namespace + "_" if cxx_namespace}}{{parent_class_converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{get_overloading_postfix(setter.vars)}}{{get_template_postfix(cxx)}}({{parent_class_converter.c.target_type_name}} cself, {{converter.target_type_name}}
          {%- if rconverter.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{setter.cxx.args[0].name}}, CppBindCObject* _Nonnull cppbind_err);
          {% endif %}
