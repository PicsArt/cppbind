file:
  kotlin:
    file_path: |
      {{out_dir + pat_sep + [package_prefix, package, file + file_postfix]|map('replace', '.', pat_sep)|path_join}}.kt
    scopes: 
      - body
      - include
    content: |
      {{helper.make_doxygen_comment((banner_logo + new_line + banner_comment).split(new_line))}}

      package {{package_prefix}}.{{package}}

      {{helper_includes|format_list('import {}.*')|join(new_line)}}

      {% if package_prefix != ctx.lookup_ctx_by_name("std::exception").package_prefix or package != ctx.lookup_ctx_by_name("std::exception").package -%}
      import {{ctx.lookup_ctx_by_name("std::exception").package_prefix}}.{{ctx.lookup_ctx_by_name("std::exception").package}}.*
      {%- endif -%}

      {{include}}
      {{body}}
  cxx:
    file_path: |
      {{cxx_out_dir + pat_sep + [package_prefix, package, file + file_postfix]|map('replace', '.', pat_sep)|path_join}}.cpp
    scopes:
      - namespace
      - body
      - include
    content: |
      {{helper.make_doxygen_comment((banner_logo + new_line + banner_comment).split(new_line))}}

      #include "jni.h"
      #include <iostream>
      {{cxx_helper_includes|format_list('#include "{}"')|join(new_line)}}
      {{include}}
      {{namespace}}

      {{body}}

package:

enum:
  kotlin: 
    body: |
      enum class {{name}}(val value: Int){{': ' if ctx.bases_list}}{{ctx.bases_list|join(', ')}} {
          {%- set comma = joiner(",") -%}
          {%- for case in enum_cases -%}
          {{comma()}}
          {%- if case.comment %}
          {{helper.make_enum_case_comment(case.comment)|string|indent(4)}}
          {%- endif %}
          {{case.name}}({{case.value}})
          {%- endfor %};

          companion object {
              private val values = values();
              fun getByValue(value: Int) = values.firstOrNull { it.value == value }
          }
          {%- if code_fragment %}

          {{code_fragment|join(2 * new_line)|indent(4)}}
          {%- endif %}
      }

var_class_cxx: &var_class_cxx
  include:
    unique_content: |
      {%- if ctx.is_proj_type -%}
      #include "{{prj_rel_file_name}}"
      {%- endif -%}
      {%- macro gen_import(converter, current_ctx) -%}
      {%- set type_ctx = converter.ctx -%}
      {%- if type_ctx and type_ctx.is_proj_type and (type_ctx.package != current_ctx.package or type_ctx.file != current_ctx.file) -%}
      {{marker}}#include "{{type_ctx.prj_rel_file_name}}"
      {%- endif -%}
      {%- for tmpl_arg_converter in converter.template_args -%}
      {{gen_import(tmpl_arg_converter, current_ctx)}}
      {%- endfor -%}
      {%- endmacro -%}
      {%- for base in base_types_converters -%}
      {{gen_import(base, ctx)}}
      {%- endfor -%}
      {%- if include_cxx -%}
      {{marker}}{{include_cxx|select('match_regexp', '^<.*>$', '^".*"$')|format_list('#include {}')|join_unique}}
      {{marker}}{{include_cxx|reject('match_regexp', '^<.*>$', '^".*"$')|format_list('#include "{}"')|join_unique}}
      {%- endif -%}
  namespace:
    unique_content: |
      {%- if ctx.namespace %}
      using namespace {{ctx.namespace}};
      {%- endif %}
  body:
    content: |
      {%- if not base_types_converters|rejectattr('ctx.action', 'equalto', 'gen_interface')|list %}
      {%- set set_name = helper.get_jni_func_name(ctx.package_prefix + '.' + ctx.package, name, template_suffix, 'jSet_this') %}
      extern "C" JNIEXPORT void {{set_name}}(JNIEnv* env, jobject obj, jobjectid id, jobject self){
      }
      {%- set finalize_name = helper.get_jni_func_name(ctx.package_prefix + '.' + ctx.package, name, template_suffix, 'jFinalize') %}
      extern "C" JNIEXPORT void {{finalize_name}}(JNIEnv* env, jobject obj, jobjectid id){
          {%- if root.shared_ref %}
          {%- if cxx_root_type_name != cxx_type_name %}
          auto baseptr = *reinterpret_cast<std::shared_ptr<{{cxx_root_type_name}}>*>(id);
          auto this_object = std::dynamic_pointer_cast<{{cxx_type_name}}>(baseptr);
          {%- else %}
          auto this_object = *reinterpret_cast<std::shared_ptr<{{cxx_type_name}}>*>(id);
          {%- endif %}
          delete &this_object;
          {%- else %}
          {%- if cxx_root_type_name != cxx_type_name %}
          {{cxx_root_type_name}}* baseptr = reinterpret_cast<{{cxx_root_type_name}}*>(id);
          {{cxx_type_name}}* this_object = dynamic_cast<{{cxx_type_name}}*>(baseptr);
          {%- else %}
          {{cxx_type_name}}* this_object = reinterpret_cast<{{cxx_type_name}}*>(id);
          {%- endif %}
          delete this_object;
          {%- endif %}
      }
      {%- endif %}

var_class_kotlin_include: &var_class_kotlin_include
  unique_content: |
    {{include|format_list("import {}")|join_unique}}
    {%- macro gen_import(converter, current_ctx) -%}
    {%- set type_ctx = converter.ctx -%}
    {%- if type_ctx and type_ctx.is_proj_type and type_ctx.package != current_ctx.package -%}
    {{marker}}import {{type_ctx.package_prefix}}.{{type_ctx.package}}.{{converter.kotlin.target_type_name}}
    {%- endif -%}
    {%- for tmpl_arg_converter in converter.template_args -%}
    {{gen_import(tmpl_arg_converter, current_ctx)}}
    {%- endfor -%}
    {%- endmacro -%}
    {%- for base in base_types_converters -%}
    {{gen_import(base, ctx)}}
    {%- endfor -%}

class:
  kotlin:
    include: *var_class_kotlin_include
    body:
      scopes:
        - head
        - properties
        - body
        - companion
        - private_external
      content: |
        {%- set base_interfaces = base_types_converters|selectattr('ctx.action', 'eq', 'gen_interface')|map(attribute='kotlin.target_type_name')|list -%}
        {%- set bases_specifiers = base_interfaces + base_types_converters|map(attribute='kotlin.target_type_name')|reject('in', base_interfaces)|format_list('{}(_id)') + ctx.bases_list + (['AutoCloseable'] if not base_types_converters or not base_types_converters|rejectattr('ctx.action', 'equalto', 'gen_interface')|list else []) + (['Exception()'] if ctx.is_exception and not helper.Exceptions.has_exc_base(ctx) else []) -%}
        {%- do helper.Validator.validate_single_root(cursor) -%}
        {%- do helper.Validator.validate_bases(name, base_types_converters) -%}
        {%- do helper.Validator.validate_ancestors(ancestors) -%}
        {%- if comment %}
        {{helper.make_comment(comment)}}
        {%- endif %}
        {{'open ' if is_open}}class {{name}}{{template_suffix}}
        internal constructor(_id: Long){{' : ' + bases_specifiers|join(', ') if bases_specifiers}} {
            companion object {
                {%- if not base_types_converters|rejectattr('ctx.action', 'equalto', 'gen_interface')|list %}
                init {
                    System.loadLibrary("{{c_wrapper_lib_name}}");
                }
                {%- endif %}
                {{companion|string|indent(8)}}
            }
            {% if not base_types_converters|rejectattr('ctx.action', 'equalto', 'gen_interface')|list %}
            protected var id = _id
            {%- endif %}
            {%- if base_types_converters|selectattr('ctx.action', 'equalto', 'gen_interface')|list or not base_types_converters %}
            {% if base_types_converters -%}
            {{'override '}}
            {%- else %}
            {{'open '}}
            {%- endif -%}
            fun getObjId(): Long {
                if (id == 0L) {
                    throw RuntimeException("Object is not allocated")
                }
                return id;
            }
            {%- endif -%}
            {%- if head %}
            {{head|string|indent}}
            {%- endif %}
            {%- if properties %}
            {{properties|string|indent}}
            {%- endif %}
            {%- if body %}
            {{body|string|indent}}
            {%- endif %}
            {%- if not base_types_converters|rejectattr('ctx.action', 'equalto', 'gen_interface')|list %}

            override fun close() {
                if (id != 0L) {
                    jFinalize(id)
                    id = 0L
                }
            }

            /**
             * Finalize and deletes the object
             */
            protected fun finalize() {
                close()
            }
            {%- endif %}
            {%- if private_external %}

            ///// External wrapper functions ////////////
            {{private_external|string|indent}}
            {%- endif %}
            {%- if not base_types_converters|rejectattr('ctx.action', 'equalto', 'gen_interface')|list %}
            private external fun jSet_this(id: Long, self: Any): Unit
            private external fun jFinalize(id: Long): Unit
            {%- endif %}
        }
  cxx: *var_class_cxx

interface:
  kotlin:
    include: *var_class_kotlin_include
    body:
      scopes:
        - head
        - properties
        - body
        - companion
        - interface_external
      content: |
        {%- set bases_specifiers = base_types_converters|map(attribute='kotlin.target_type_name')|list + ctx.bases_list -%}
        {%- do helper.Validator.validate_single_root(cursor) -%}
        {%- if comment %}
        {{helper.make_comment(comment)}}
        {%- endif %}
        interface I{{name}}{{template_suffix}}{{' : ' + bases_specifiers|join(', ') if bases_specifiers}} {
            {%- if not base_types_converters %}
            fun getObjId(): Long
            {%- endif %}
            {{properties|string|indent}}
            {{body|string|indent}}
        }
        {% if interface_external %}
        class {{name}}Helper{{template_suffix}} {
            companion object {
                {{interface_external|string|indent(8)}}
            }
        }
        {%-endif %}
        {% do helper.Validator.validate_ancestors(ancestors) %}
        {{'open ' if is_open}}class {{name}}{{template_suffix}}
        internal constructor(_id: Long) : I{{name}}{{template_suffix}}, AutoCloseable {
            companion object {
                init {
                    System.loadLibrary("{{c_wrapper_lib_name}}");
                }
                {{companion|string|indent(8)}}
            }

            protected var id = _id
            override fun getObjId(): Long {
                if (id == 0L) {
                    throw RuntimeException("Object is not allocated")
                }
                return id;
            }
            {%- if head %}
            {{head|string|indent}}
            {%- endif %}
            {%- if not base_types_converters|rejectattr('ctx.action', 'equalto', 'gen_interface')|list %}

            override fun close() {
                if (id != 0L) {
                    jFinalize(id)
                    id = 0L
                }
            }

            /**
            * Finalize and deletes the object
            */
            protected fun finalize() {
                close()
            }
            {% endif %}
            ///// External wrapper functions ////////////
            private external fun jSet_this(id: Long, self: Any): Unit
            private external fun jFinalize(id: Long): Unit
        }
  cxx: *var_class_cxx


var_method_kotlin_include: &var_method_kotlin_include
  unique_content: |
    {%- macro gen_import(converter, current_ctx) -%}
    {%- set type_ctx = converter.ctx -%}
    {%- if type_ctx and type_ctx.is_proj_type and type_ctx.package != current_ctx.package -%}
    {{marker}}import {{type_ctx.package_prefix}}.{{type_ctx.package}}.{{converter.kotlin.target_type_name}}
    {%- endif -%}
    {%- for tmpl_arg_converter in converter.template_args -%}
    {{gen_import(tmpl_arg_converter, current_ctx)}}
    {%- endfor -%}
    {%- endmacro -%}
    {%- for arg in args -%}
    {{gen_import(arg.converter, ctx)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_import(rconverter, ctx)}}
    {%- endif -%}

var_method_cxx_include: &var_method_cxx_include
  unique_content: |
    {%- macro gen_import(converter, current_ctx) -%}
    {%- set type_ctx = converter.ctx -%}
    {%- if type_ctx and type_ctx.is_proj_type -%}
    {{marker}}#include "{{type_ctx.prj_rel_file_name}}"
    {%- endif -%}
    {%- for tmpl_arg_converter in converter.template_args -%}
    {{gen_import(tmpl_arg_converter, current_ctx)}}
    {%- endfor -%}
    {%- endmacro -%}
    {%- for arg in args -%}
    {{gen_import(arg.converter, ctx)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_import(rconverter, ctx)}}
    {%- endif -%}

constructor:
  kotlin:
    include: *var_method_kotlin_include
    head: |
      {%- if comment %}
      {{helper.make_comment(comment)}}
      {%- endif %}
      {%- set comma = joiner(', ') %}
      constructor({%- for arg in args -%}
      {{comma()}}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.nullable}}
      {%- if arg.default -%}
      {%- set target_type = arg.converter.kotlin.target_type_name -%}
      {%- if arg.is_enum %} = {{arg.converter.kotlin.target_type_name}}.{{arg.default}}
      {%- else -%}
      {%- if arg.default in ['nullptr', 'NULL'] %} = null
      {%- else %} = {{arg.default}}{{'F' if arg.is_float}}{{'L' if arg.is_long}}
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor -%}): this(construct_helper({{args|join(', ', attribute='name')}})) {
          //jSet_this(id, this)
      }
    companion: |
      {%- if comment %}
      {{helper.make_comment(comment)}}
      {%- endif %}
      {%- set comma = joiner(', ') %}
      protected fun construct_helper({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.nullable}}{%- endfor-%}): Long {
          {%- set call_args = [] %}
          {%- for arg in args %}
          {%- set converter = arg.converter.kotlin_to_jdk -%}
          {{converter.snippet(arg.name, nullable=arg.nullable)|indent}}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {%- endfor %}
          val id = jConstructor{{overloading_prefix}}({{call_args|join(', ')}})
          return id
      }
      {% set comma = joiner(', ') %}
      @JvmStatic
      private external fun jConstructor{{overloading_prefix}}({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}): Long
  cxx:
    include: *var_method_cxx_include
    body: |
      {%- set jni_name = helper.get_jni_func_name(ctx.package_prefix + '.' + ctx.package, owner_class.name, owner_class.template_suffix, 'jConstructor' + overloading_prefix) -%}
      extern "C" JNIEXPORT jobjectid {{jni_name}}(JNIEnv* env, jobject obj{{args|format_list(", {arg.converter.jni.target_type_name} {arg.name}", 'arg')|join}}){
          {%- set call_args = [] -%}
          {%- for arg in args -%}
          {% set converter = arg.converter.jni_to_cxx %}
          {{converter.snippet(arg.name, nullable=arg.nullable)|indent(4)}}
          {%- do call_args.append(converter.converted_name(arg.name)) -%}
          {%- endfor %}
          {%- if not owner_class.root.shared_ref %}
          {{owner_class.cxx_root_type_name}}* baseptr = new {{owner_class.cxx_type_name}}({{call_args|join(', ')}});
          return reinterpret_cast<jlong>(baseptr);
          {%- else %}
          {{owner_class.cxx_type_name}}* obj_ptr = new {{owner_class.cxx_type_name}}({{call_args|join(', ')}});
          auto this_object = std::shared_ptr<{{owner_class.cxx_type_name}}>(obj_ptr);
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          std::shared_ptr<{{owner_class.cxx_root_type_name}}> baseptr = std::dynamic_pointer_cast<{{owner_class.cxx_root_type_name}}>(this_object);
          return reinterpret_cast<jlong>(new std::shared_ptr<{{owner_class.cxx_root_type_name}}>(baseptr));
          {%- else %}
          return reinterpret_cast<jlong>(new std::shared_ptr<{{owner_class.cxx_type_name}}>(this_object));
          {%- endif %}
          {%- endif %}
      }

function:
  kotlin:
    include: *var_method_kotlin_include
    body: |
      {%- set comma = joiner(', ') -%}
      {%- if not is_static %}
      {%- if comment %}
      {{helper.make_comment(comment)}}
      {%- endif %}
      {{'open ' if is_open}}{{'operator 'if is_operator}}{{'override ' if is_override or name == 'toString'}}fun {{name}}(
      {%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.nullable}}
      {%- if arg.default -%}
      {%- set target_type = arg.converter.kotlin.target_type_name -%}
      {%- if arg.is_enum %} = {{arg.converter.kotlin.target_type_name}}.{{arg.default}}
      {%- else -%}
      {%- if arg.default in ['nullptr', 'NULL'] %} = null
      {%- else %} = {{arg.default}}{{'F' if arg.is_float}}{{'L' if arg.is_long}}
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if nullable_return}} {
          {%- set call_args = ['getObjId()'] -%}
          {%- set result_converter = rconverter.jdk_to_kotlin -%}
          {%- for arg in args %}
          {%- set converter = arg.converter.kotlin_to_jdk -%}
          {%- set conversion = converter.snippet(arg.name, nullable=arg.nullable) -%}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {%- endfor %}
          {%- if ctx.parent_context.action == 'gen_interface' %}
          val result = {{owner_class.name}}Helper{{owner_class.template_suffix}}.j{{name|capitalize}}{{overloading_prefix}}({{call_args|join(', ')}})
          {%- else %}
          val result = j{{name|capitalize}}{{overloading_prefix}}({{call_args|join(', ')}})
          {%- endif %}
          {{result_converter.snippet('result', nullable=nullable_return)|indent}}
          return {{result_converter.converted_name('result')}}
      }
      {%- endif %}
    companion: |
      {%- if is_static %}
      {%- set comma = joiner(', ') -%}
      {%- if comment %}
      {{helper.make_comment(comment)}}
      {%- endif %}
      fun {{name}}({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.nullable}}{%- endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if nullable_return}} {
          {%- set call_args = [] %}
          {%- set result_converter = rconverter.jdk_to_kotlin -%}
          {%- for arg in args -%}
          {%- set converter = arg.converter.kotlin_to_jdk -%}
          {%- set conversion = converter.snippet(arg.name, nullable=arg.nullable) -%}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {%- endfor %}
          {%- if ctx.parent_context.action == 'gen_interface' %}
          val result = {{owner_class.name}}Helper{{owner_class.template_suffix}}.j{{name|capitalize}}{{overloading_prefix}}({{call_args|join(', ')}})
          {%- else %}
          val result = j{{name|capitalize}}{{overloading_prefix}}({{call_args|join(', ')}})
          {%- endif %}
          {{result_converter.snippet('result', nullable=nullable_return)|indent}}
          return {{result_converter.converted_name('result')}}
      }
      {%- set comma = joiner(', ') %}
      @JvmStatic
      private external fun j{{name|capitalize}}{{overloading_prefix}}({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}): {{rconverter.jdk.target_type_name}}
      {%- endif %}
    private_external: |
      {%- if not is_static %}
      {%- set comma = joiner(', ') -%}
      private external fun j{{name|capitalize}}{{overloading_prefix}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}): {{rconverter.jdk.target_type_name}}
      {%- endif %}
    interface_external: |
      {%- if not is_static %}
      {%- set comma = joiner(', ') -%}
      @JvmStatic
      external fun j{{name|capitalize}}{{overloading_prefix}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}): {{rconverter.jdk.target_type_name}}
      {%- endif %}
  cxx:
    include: *var_method_cxx_include
    body: |
      {% set func_name="j%s%s"|format(name|capitalize, overloading_prefix) %}
      {%- set objid_args=["jobjectid id"]if not is_static else [] -%}
      {%- set jni_args=["JNIEnv* env, jobject obj"] + objid_args
        + args|format_list("{arg.converter.jni.target_type_name} {arg.name}", 'arg') -%}
      {%- macro args_snippet(args, call_args) %}
      {%- for arg in args -%}
      {%- set converter = arg.converter.jni_to_cxx %}
      {{converter.snippet(arg.name, nullable=arg.nullable)}}
      {%- do call_args.append(converter.converted_name(arg.name))%}
      {% endfor %}
      {%- endmacro %}
      {% macro call_code(prefix, call_args) -%}
      void* err_ptr = nullptr;
      {% if rconverter.jni.target_type_name != 'void' %}
      try {
        auto result = {{prefix}}{{cxx_name}}{%- if ctx.node.is_function_template -%}
                                            <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                            {%- endif -%}({{call_args|join(', ')}});
        {{rconverter.cxx_to_jni.snippet('result', nullable=nullable_return)}}
        return {{rconverter.cxx_to_jni.converted_name('result')}};
      }
      {%- else %}
      try {
        {{prefix}}{{cxx_name}}({{call_args|join(', ')}});
        return;
      }
      {%- endif %}
      {%- if helper.Exceptions.can_throw(throws) %}
      {%- for exc_type in throws -%}
      catch (const {{exc_type}}& e) {
          err_ptr = new {{exc_type}}(e);
          jclass excCls = env->FindClass("{{[ctx.lookup_ctx_by_name(exc_type).package_prefix, ctx.lookup_ctx_by_name(exc_type).package, ctx.lookup_ctx_by_name(exc_type).name]|map('replace', '.', pat_sep)|path_join}}");
          jmethodID constructor = env->GetMethodID(excCls, "<init>", "(J)V");
          jobject excObj = env->NewObject(excCls, constructor, reinterpret_cast<jobjectid>(err_ptr));
          env->Throw(jthrowable(excObj));
      }
      {%- endfor %}
      {%- endif %}
      {%- if not 'std::exception' in throws %}
      catch (const std::exception& e) {
            err_ptr = new std::exception(e);
            jclass handlerCls = env->FindClass("exceptionUtils/ExceptionHandler");
            jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
            env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
      }
      {%- endif %}
      catch (...) {
            jclass handlerCls = env->FindClass("exceptionUtils/ExceptionHandler");
            jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
            env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Excepiton"));
      }

      {% if rconverter.jni.target_type_name != 'void' -%}
      {{rconverter.jni.target_type_name}} result;
      return result;
      {%- endif %}
      {%- endmacro %}
      {%- set class_name = owner_class.name %}
      {%- if ctx.parent_context.action == 'gen_interface' %}
      {%- set class_name = owner_class.name + 'Helper' %}
      {%- endif %}
      {%- set jni_name = helper.get_jni_func_name(ctx.package_prefix + '.' + ctx.package, class_name, owner_class.template_suffix, func_name) %}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}({{jni_args|join(', ')}}){
          {%- set call_args = [] %}
          {{args_snippet(args, call_args)|indent(4)}}
          {%- if not is_static %}
          validateID(id);
          {%- if owner_class.root.shared_ref %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          auto baseptr = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(id);
          auto this_object = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(baseptr);
          {%- else %}
          auto this_object = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_type_name}}>*>(id);
          {%- endif %}
          {%- else %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          {{owner_class.cxx_root_type_name}}* baseptr = reinterpret_cast<{{owner_class.cxx_root_type_name}}*>(id);
          {{owner_class.cxx_type_name}}* this_object = dynamic_cast<{{owner_class.cxx_type_name}}*>(baseptr);
          {%- else %}
          {{owner_class.cxx_type_name}}* this_object = reinterpret_cast<{{owner_class.cxx_type_name}}*>(id);
          {%- endif %}
          {%- endif %}
          {{call_code("this_object->", call_args)|indent(4)}}
          {%- else %}
          {{call_code(owner_class.cxx_type_name + "::", call_args)|indent(4)}}
          {%- endif %}
      }

var_getter_kotlin_include: &var_getter_kotlin_include
  unique_content: |
    {%- macro gen_import(converter, current_ctx) -%}
    {%- set type_ctx = converter.ctx -%}
    {%- if type_ctx and type_ctx.is_proj_type and type_ctx.package != current_ctx.package -%}
    {{marker}}import {{type_ctx.package_prefix}}.{{type_ctx.package}}.{{converter.kotlin.target_type_name}}
    {%- endif -%}
    {%- for tmpl_arg_converter in converter.template_args -%}
    {{gen_import(tmpl_arg_converter, current_ctx)}}
    {%- endfor -%}
    {%- endmacro -%}
    {{gen_import(rconverter, ctx)}}

var_getter_cxx_include: &var_getter_cxx_include
  unique_content: |
    {%- macro gen_import(converter, current_ctx) -%}
    {%- set type_ctx = converter.ctx -%}
    {%- if type_ctx and type_ctx.is_proj_type -%}
    {{marker}}#include "{{type_ctx.prj_rel_file_name}}"
    {%- endif -%}
    {%- for tmpl_arg_converter in converter.template_args -%}
    {{gen_import(tmpl_arg_converter, current_ctx)}}
    {%- endfor -%}
    {%- endmacro -%}
    {{gen_import(rconverter, ctx)}}

property_getter:
  kotlin:
    include: *var_getter_kotlin_include
    properties: |
      {% set result_converter = rconverter.jdk_to_kotlin %}
      {%- if comment %}
      {{helper.make_comment(comment)}}
      {%- endif %}
      {{'var' if ctx.action == 'gen_property_setter' else 'val'}} {{name}}: {{result_converter.target_type_name}}{{'?' if nullable_return}}
          get() {
              {%- if ctx.parent_context.action == 'gen_interface' %}
              val result = {{owner_class.name}}Helper{{owner_class.template_suffix}}.j{{name|capitalize}}(getObjId())
              {%- else %}
              val result = j{{name|capitalize}}(getObjId())
              {%- endif %}
              {{result_converter.snippet('result', nullable=nullable_return)|indent(8)}}
              return {{result_converter.converted_name('result')}}
          }
          {%- if ctx.action == 'gen_property_setter' %}
          {%- set converter = rconverter.kotlin_to_jdk %}
          set(value) {
              {{converter.snippet('value', nullable=nullable_return)|indent(8)}}
              {%- if ctx.parent_context.action == 'gen_interface' %}
              {{owner_class.name}}Helper{{owner_class.template_suffix}}.jSet{{name|lower}}(getObjId(), {{converter.converted_name('value')}})
              {%- else %}
              jSet{{name|lower}}(getObjId(), {{converter.converted_name('value')}})
              {%- endif %}
          }
          {% endif %}
    private_external: |
      private external fun j{{name|capitalize}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if ctx.action == 'gen_property_setter' %}
      private external fun jSet{{name|lower}}(id: Long, value: {{rconverter.jdk.target_type_name}}): Unit
      {%- endif %}
    interface_external: |

      @JvmStatic
      external fun j{{name|capitalize}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if ctx.action == 'gen_property_setter' %}

      @JvmStatic
      external fun jSet{{name|lower}}(id: Long, value: {{rconverter.jdk.target_type_name}}): Unit
      {%- endif %}
  cxx:
    include: *var_getter_cxx_include
    body: |
      {%- set func_name="j%s"|format(name|capitalize) %}
      {%- set class_name = owner_class.name %}
      {%- if ctx.parent_context.action == 'gen_interface' %}
      {%- set class_name = owner_class.name + 'Helper' %}
      {%- endif %}
      {%- set jni_name = helper.get_jni_func_name(ctx.package_prefix + '.' + ctx.package, class_name, owner_class.template_suffix, func_name) %}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}(JNIEnv* env, jobject obj, jobjectid id){
          validateID(id);
          {%- if owner_class.root.shared_ref %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          auto baseptr = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(id);
          auto this_object = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(baseptr);
          {%- else %}
          auto this_object = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_type_name}}>*>(id);
          {%- endif %}
          {%- else %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          {{owner_class.cxx_root_type_name}}* baseptr = reinterpret_cast<{{owner_class.cxx_root_type_name}}*>(id);
          {{owner_class.cxx_type_name}}* this_object = dynamic_cast<{{owner_class.cxx_type_name}}*>(baseptr);
          {%- else %}
          {{owner_class.cxx_type_name}}* this_object = reinterpret_cast<{{owner_class.cxx_type_name}}*>(id);
          {%- endif %}
          {%- endif %}
          auto result = this_object->{{cxx_name}};
          {{rconverter.cxx_to_jni.snippet('result', nullable=nullable_return)|indent(4)}}
          return {{rconverter.cxx_to_jni.converted_name('result')}};
      }
      {%- if ctx.action == 'gen_property_setter' %}
      {% set func_name="jSet%s"|format(name|lower) %}
      {%- set jni_name = helper.get_jni_func_name(ctx.package_prefix + '.' + ctx.package, class_name, owner_class.template_suffix, func_name) %}
      extern "C" JNIEXPORT void {{jni_name}}(JNIEnv* env, jobject obj, jobjectid id, {{rconverter.jni.target_type_name}} value){
          validateID(id);
          {%- if owner_class.root.shared_ref %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          auto baseptr = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(id);
          auto this_object = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(baseptr);
          {%- else %}
          auto this_object = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_type_name}}>*>(id);
          {%- endif %}
          {%- else %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          {{owner_class.cxx_root_type_name}}* baseptr = reinterpret_cast<{{owner_class.cxx_root_type_name}}*>(id);
          {{owner_class.cxx_type_name}}* this_object = dynamic_cast<{{owner_class.cxx_type_name}}*>(baseptr);
          {%- else %}
          {{owner_class.cxx_type_name}}* this_object = reinterpret_cast<{{owner_class.cxx_type_name}}*>(id);
          {%- endif %}
          {%- endif %}
          {% set converter = rconverter.jni_to_cxx %}
          {{converter.snippet('value', nullable=nullable_return)|indent(4)}}
          this_object->{{cxx_name}} = {{converter.converted_name('value')}};
      }
      {% endif %}

getter:
  kotlin:
    include: *var_getter_kotlin_include
    properties: |
      {% set result_converter = rconverter.jdk_to_kotlin %}
      {%- if ctx.node.is_function_template %}
      {%- if template_names %}
      {%- set _name = template_names|join|to_camel_case %}
      {%- else %}
      {%- set _name = overloading_prefix[0]|lower + overloading_prefix[1:]|to_camel_case %}
      {%- endif %}
      {%- else %}
      {%- set _name = name|to_camel_case %}
      {%- endif %}
      {%- if comment %}
      {{helper.make_comment(comment)}}
      {%- endif %}
      {{'open ' if is_open}}{{'override ' if is_override}}{{'var' if setter_ctx is defined else 'val'}} {{_name}}: {{result_converter.target_type_name}}{{'?' if nullable_return}}
          get() {
              {%- if ctx.parent_context.action == 'gen_interface' %}
              val result = {{owner_class.name}}Helper{{owner_class.template_suffix}}.j{{name|capitalize}}(getObjId())
              {%- else %}
              val result = j{{name|capitalize}}{{overloading_prefix}}(getObjId())
              {%- endif %}
              {{result_converter.snippet('result', nullable=nullable_return)|indent(8)}}
              return {{result_converter.converted_name('result')}}
          }
          {%- if setter_ctx is defined %}
          {%- set converter = setter_ctx.args[0].converter.kotlin_to_jdk %}
          {%- if is_override %}
          set(value) {
              super.{{name}} = value
          }
          {%- else %}
          set(value) {
              {{converter.snippet('value', nullable=nullable_return)|indent(8)}}
              {%- if ctx.parent_context.action == 'gen_interface' %}
              {{owner_class.name}}Helper{{owner_class.template_suffix}}.j{{setter_ctx.name|capitalize}}(getObjId(), {{converter.converted_name('value')}})
              {%- else %}
              j{{setter_ctx.name|capitalize}}{{overloading_prefix}}(getObjId(), {{converter.converted_name('value')}})
              {%- endif %}
          }
          {%- endif %}
          {%- endif %}
    private_external: |
      private external fun j{{name|capitalize}}{{overloading_prefix}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if setter_ctx is defined %}
      private external fun j{{setter_ctx.name|capitalize}}{{overloading_prefix}}(id: Long, value: {{setter_ctx.args[0].converter.jdk.target_type_name}}): Unit
      {%- endif %}
    interface_external: |

      @JvmStatic
      external fun j{{name|capitalize}}{{overloading_prefix}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if setter_ctx is defined %}

      @JvmStatic
      external fun j{{setter_ctx.name|capitalize}}{{overloading_prefix}}(id: Long, value: {{setter_ctx.args[0].converter.jdk.target_type_name}}): Unit
      {%- endif %}
  cxx:
    include: *var_getter_cxx_include
    body: |
      {%- macro gen_exc_try_block() -%}
          {%- if helper.Exceptions.can_throw(throws) %}
          {%- for exc_type in throws -%}
          catch (const {{exc_type}}& e) {
              err_ptr = new {{exc_type}}(e);
              jclass excCls = env->FindClass("{{[ctx.lookup_ctx_by_name(exc_type).package_prefix, ctx.lookup_ctx_by_name(exc_type).package, ctx.lookup_ctx_by_name(exc_type).name]|map('replace', '.', pat_sep)|path_join}}");
              jmethodID constructor = env->GetMethodID(excCls, "<init>", "(J)V");
              jobject excObj = env->NewObject(excCls, constructor, reinterpret_cast<jobjectid>(err_ptr));
              env->Throw(jthrowable(excObj));
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in throws %}
          catch (const std::exception& e) {
              err_ptr = new std::exception(e);
              jclass handlerCls = env->FindClass("exceptionUtils/ExceptionHandler");
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
          }
          {%- endif %}
          catch (...) {
              jclass handlerCls = env->FindClass("exceptionUtils/ExceptionHandler");
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Excepiton"));
          }
      {%- endmacro -%}
      {%- set func_name="j%s%s"|format(name|capitalize, overloading_prefix) %}
      {%- set class_name = owner_class.name %}
      {%- if ctx.parent_context.action == 'gen_interface' %}
      {%- set class_name = owner_class.name + 'Helper' %}
      {%- endif %}
      {%- if ctx.node.is_function_template -%}
      {%- set template_args = '<' + template_choice.values()|format_list("{type}", 'type')|join(', ') + '>' %}
      {%- else %}
      {%- set template_args = '' %}
      {%- endif %}
      {%- set jni_name = helper.get_jni_func_name(ctx.package_prefix + '.' + ctx.package, class_name, owner_class.template_suffix, func_name) %}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}(JNIEnv* env, jobject obj, jobjectid id){
          validateID(id);
          {%- if owner_class.root.shared_ref %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          auto baseptr = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(id);
          auto this_object = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(baseptr);
          {%- else %}
          auto this_object = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_type_name}}>*>(id);
          {%- endif %}
          {%- else %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          {{owner_class.cxx_root_type_name}}* baseptr = reinterpret_cast<{{owner_class.cxx_root_type_name}}*>(id);
          {{owner_class.cxx_type_name}}* this_object = dynamic_cast<{{owner_class.cxx_type_name}}*>(baseptr);
          {%- else %}
          {{owner_class.cxx_type_name}}* this_object = reinterpret_cast<{{owner_class.cxx_type_name}}*>(id);
          {%- endif %}
          {%- endif %}
          void* err_ptr = nullptr;
          try {
              auto result = this_object->{{cxx_name}}{{template_args}}();
              {{rconverter.cxx_to_jni.snippet('result', nullable=nullable_return)|indent(8)}}
              return {{rconverter.cxx_to_jni.converted_name('result')}};
          }
          {{gen_exc_try_block()}}

          {{rconverter.jni.target_type_name}} result;
          return result;
      }
      {%- if setter_ctx is defined %}
      {% set func_name="j%s%s"|format(setter_ctx.name|capitalize, overloading_prefix) %}
      {%- set jni_setter_name = helper.get_jni_func_name(ctx.package_prefix + '.' + ctx.package, class_name, owner_class.template_suffix, func_name) %}
      extern "C" JNIEXPORT void {{jni_setter_name}}(JNIEnv* env, jobject obj, jobjectid id, {{setter_ctx.args[0].converter.jni.target_type_name}} {{setter_ctx.args[0].name}}){
          validateID(id);
          {%- if owner_class.root.shared_ref %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          auto baseptr = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(id);
          auto this_object = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(baseptr);
          {%- else %}
          auto this_object = *reinterpret_cast<std::shared_ptr<{{owner_class.cxx_type_name}}>*>(id);
          {%- endif %}
          {%- else %}
          {%- if owner_class.cxx_root_type_name != owner_class.cxx_type_name %}
          {{owner_class.cxx_root_type_name}}* baseptr = reinterpret_cast<{{owner_class.cxx_root_type_name}}*>(id);
          {{owner_class.cxx_type_name}}* this_object = dynamic_cast<{{owner_class.cxx_type_name}}*>(baseptr);
          {%- else %}
          {{owner_class.cxx_type_name}}* this_object = reinterpret_cast<{{owner_class.cxx_type_name}}*>(id);
          {%- endif %}
          {%- endif %}
          {%- set converter = setter_ctx.args[0].converter.jni_to_cxx -%}
          {{converter.snippet(setter_ctx.args[0].name, nullable=nullable_return)|indent(4)}}
          void* err_ptr = nullptr;
          try {
              this_object->{{setter_ctx.cxx_name}}{{template_args}}({{converter.converted_name(setter_ctx.args[0].name)}});
          }
          {{gen_exc_try_block()}}
      }
      {% endif %}
