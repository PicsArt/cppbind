file:
  kotlin:
    file_path: |
      {{vars.target_file_fullname}}
    scopes:
      - body
      - include
      - glob_init
      - glob_external
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      package {{vars.package_prefix}}.{{vars.package}}
      {% set helpers = helper_includes|format_list('import {}.*')|join_unique %}
      {%- set exc_vars = get_type_info("std::exception").vars %}
      {%- set exc_include = 'import ' + exc_vars.package_prefix + '.' + exc_vars.package + '.*' %}
      {{[helpers, exc_include, include]|sort_snippets|join(new_line)}}
      {%- if glob_init %}
      {{glob_init}}
      {%- endif %}
      {%- if body %}
      {{body}}
      {%- endif %}
      {%- if glob_external %}

      {{glob_external}}
      {%- endif %}

      private external fun jGettypebyid(id: Long): String{{new_line}}
  cxx:
    file_path: |
      {{vars.c_file_fullname}}
    scopes:
      - namespace
      - body
      - include
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include "jni.h"
      #include <iostream>
      #include <cxxabi.h>
      #include <string.h>
      #include <type_traits>
      {{cxx_helper_includes|format_list('#include "{}"')|join(new_line)}}
      {{include}}
      {{namespace}}

      {{body}}

      extern "C" JNIEXPORT jstring {{helper.get_jni_func_name(vars.package_prefix + '.' + vars.package, vars.file|capitalize + 'Kt', 'jGettypebyid')}}(JNIEnv* env, jclass cls, jobjectid id) {
          validateID(id);
          return env->NewStringUTF(reinterpret_cast<IEGenCObject*>(id)->type);
      }{{new_line}}

package:

enum:
  kotlin:
    body: |
      {%- if vars.header_code_fragment %}
      {{new_line}}{{vars.header_code_fragment}}
      {%- endif %}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      enum class {{vars.name}}(val value: Int){{': ' if vars.bases_list}}{{vars.bases_list|join(', ')}} {
          {%- set comma = joiner(",") -%}
          {%- for case in enum_cases -%}
          {%- if case.name not in vars.enum_excluded_fields -%}
          {{comma()}}
          {%- if case.comment %}
          {{case.comment|make_doxygen_comment|indent(4)}}
          {%- endif %}
          {{vars.enum_field_name_prefix + case.name}}({{case.value}})
          {%- endif %}
          {%- endfor %};

          companion object {
              private val values = values()
              fun getByValue(value: Int) = values.firstOrNull { it.value == value }
          }
          {%- if vars.code_fragment %}

          {{vars.code_fragment|indent(4)}}
          {%- endif %}
      }
      {%- if vars.footer_code_fragment %}
      {{new_line}}{{vars.footer_code_fragment}}
      {%- endif %}

var_class_cxx: &var_class_cxx
  include:
    unique_content: |
      {%- if vars.is_proj_type -%}
      #include "{{vars.prj_rel_file_name}}"
      {%- endif -%}
      {%- macro gen_include(type_info) -%}
      {%- if type_info.vars and type_info.vars.is_proj_type -%}
      {{marker}}#include "{{type_info.vars.prj_rel_file_name}}"
      {%- endif -%}
      {%- for arg_type_info in type_info.arg_types_infos -%}
      {{gen_include(arg_type_info)}}
      {%- endfor -%}
      {%- endmacro -%}
      {%- for base in base_types_infos -%}
      {{gen_include(base)}}
      {%- endfor -%}
      {%- if vars.include_cxx -%}
      {{marker}}{{vars.include_cxx|select('match_regexp', '^<.*>$', '^".*"$')|format_list('#include {}')|join_unique}}
      {{marker}}{{vars.include_cxx|reject('match_regexp', '^<.*>$', '^".*"$')|format_list('#include "{}"')|join_unique}}
      {%- endif -%}
  namespace:
    unique_content: |
      {%- if cxx.namespace %}
      using namespace {{cxx.namespace}};
      {%- endif %}
  body:
    content: |
      {%- if not base_types_converters|map(attribute='kotlin')|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}
      {%- set parent_type_name = converter.kotlin.get_target_type_name(interface_class=vars.action == 'gen_interface') %}
      {%- set finalize_name = helper.get_jni_func_name(vars.package_prefix + '.' + vars.package, parent_type_name, 'jFinalize') %}
      extern "C" JNIEXPORT void {{finalize_name}}(JNIEnv* env, jobject obj, jobjectid id){
          {%- if vars.shared_ref %}
          {#- here is used almost the same logic as for jni_to_cxx section of std::shared_ptr type converter (instead of constructing target value we delete it here) -#}
          {%- if vars and not vars.shared_ref -%}
          {%- do Error.critical(cxx.unqualified_resolved_type_name + ' has an invalid value for shared_ref variable.') -%}
          {%- endif -%}
          {%- set is_nullable = nullable|default(False) %}
          {%- set descendants = vars.descendants if vars.descendants is not none else descendants %}
          {%- macro gen_cast_block() -%}
          {%- if descendants -%}
          if (strcmp(iegen_obj_id->type, "{{cxx.unqualified_canonical_type_name}}") == 0)
              delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(iegen_obj_id_ptr);
          {%- for descendant in descendants %}
          else if (strcmp(iegen_obj_id->type, "{{descendant}}") == 0)
              delete static_cast<std::shared_ptr<{{descendant}}>*>(iegen_obj_id_ptr);
          {%- endfor %}
          else {
              std::cerr << "Unexpected object type: " << iegen_obj_id->type << std::endl;
              exit(1);
          }
          {%- else -%}
          delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(iegen_obj_id_ptr);
          {%- endif -%}
          {%- endmacro %}
          auto iegen_obj_id = reinterpret_cast<IEGenCObject*>(id);
          auto iegen_obj_id_ptr = iegen_obj_id ? iegen_obj_id->ptr : nullptr;
          {%- if is_nullable %}
          if (iegen_obj_id_ptr) {
              {{gen_cast_block()}}
          }
          {%- else %}
          {{gen_cast_block()}}
          {%- endif %}
          {#- end of std::shared_ptr conversion section -#}
          {%- else %}
          {%- if (vars.descendants if vars.descendants is not none else descendants) %}
          static_assert(std::has_virtual_destructor<{{cxx.unqualified_resolved_type_name}}>::value, {{'"{} type must have virtual destructor"'.format(cxx.unqualified_resolved_type_name)}});
          {%- endif %}
          {%- set jni_to_cxx_converter = make_type_converter(cxx.unqualified_resolved_type_name).jni_to_cxx %}
          {{jni_to_cxx_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          delete {{jni_to_cxx_converter.converted_name('id')}};
          {%- endif %}
          free(iegen_obj_id->type);
          delete iegen_obj_id;
      }
      {%- endif %}

var_class_kotlin_include: &var_class_kotlin_include
  unique_content: |
    {{marker if vars.include}}{{vars.include|format_list("import {}")|join_unique}}
    {%- macro gen_import(converter) -%}
    {%- if converter.parent_type_info -%}
    {{gen_import(make_type_converter(converter.parent_type_info.cxx.type_name).kotlin)}}
    {%- else %}
    {%- if converter.vars and converter.vars.is_proj_type and converter.vars.package != vars.package -%}
    {{marker}}import {{converter.vars.package_prefix}}.{{converter.vars.package}}.{{converter.target_type_name}}
    {%- endif -%}
    {%- endif -%}
    {%- for arg_converter in converter.args -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- endmacro -%}
    {%- for base in base_types_converters|map(attribute='kotlin') -%}
    {{gen_import(base)}}
    {%- endfor -%}

class:
  kotlin:
    include: *var_class_kotlin_include
    body:
      scopes:
        - head
        - properties
        - body
        - companion
        - private_external
      content: |
        {%- if vars.header_code_fragment -%}
        {{new_line}}{{vars.header_code_fragment}}
        {% endif -%}
        {%- set base_interfaces = base_types_converters|map(attribute='kotlin')|selectattr('vars.action', 'eq', 'gen_interface')|map(attribute='target_type_name')|list -%}
        {%- set all_bases_are_interface = not base_types_infos|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}
        {%- set bases_specifiers = base_interfaces + base_types_converters|map(attribute='kotlin.target_type_name')|reject('in', base_interfaces)|format_list('{}(obj)') + vars.bases_list + (['AutoCloseable'] if not base_types_converters or all_bases_are_interface else []) + (['Exception()'] if vars.is_exception and not ancestors|selectattr('vars.is_exception', 'equalto', True)|list else []) -%}
        {%- if base_types_converters|map(attribute='kotlin')|rejectattr('vars.action', 'equalto', 'gen_interface')|list|length > 1 %}
        {%- do Error.critical(cxx.type_name + ' has more than 1 non abstract base type.') %}
        {%- endif %}
        {%- if ancestors|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
        {%- do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
        {%- endif %}
        {%- if vars.comment %}
        {{vars.comment|make_doxygen_comment}}
        {%- endif %}
        {{'open ' if cxx.is_open}}class {{converter.kotlin.get_target_type_name(definition=True)}}
        internal constructor(obj: IEGenObject){{' : ' + bases_specifiers|join(', ') if bases_specifiers}} {
            companion object {
                {%- if vars.c_wrapper_lib_name and all_bases_are_interface %}
                init {
                    System.loadLibrary("{{vars.c_wrapper_lib_name}}")
                }
                {%- endif %}
                {{companion|string|indent(8)}}
            }
            {% if all_bases_are_interface %}
            protected var iegObj = obj
            private var refs: MutableList<Any> = mutableListOf()

            {{'override ' if base_types_converters}}fun keepIEGenReference(ref: Any) {
                refs.add(ref)
            }
            {%- endif %}
            {%- if base_types_converters|map(attribute='kotlin')|selectattr('vars.action', 'equalto', 'gen_interface')|list or not base_types_converters %}
            {% if base_types_converters -%}
            {{'override '}}
            {%- else %}
            {{'open '}}
            {%- endif -%}
            val id: Long
                get() {
                    if (iegObj.id == 0L) {
                        throw RuntimeException("Object is not allocated")
                    }
                    return iegObj.id
                }
            {%- endif -%}
            {%- if head %}
            {{head|string|indent}}
            {%- endif %}
            {%- if properties %}
            {{properties|string|indent}}
            {%- endif %}
            {%- if body %}
            {{body|string|indent}}
            {%- endif %}
            {%- if all_bases_are_interface %}

            override fun close() {
                if (iegObj.owner && iegObj.id != 0L) {
                    jFinalize(iegObj.id)
                    iegObj.id = 0L
                }
            }

            /**
             * Finalize and deletes the object
             */
            protected fun finalize() {
                close()
            }
            {%- endif %}
            {%- if private_external %}

            ///// External wrapper functions ////////////
            {{private_external|string|indent}}
            {%- endif %}
            {%- if all_bases_are_interface %}
            private external fun jFinalize(id: Long): Unit
            {%- endif %}
        }
        {%- if vars.footer_code_fragment %}
        {{new_line}}{{vars.footer_code_fragment}}
        {% endif -%}
  cxx: *var_class_cxx

interface:
  kotlin:
    include: *var_class_kotlin_include
    body:
      scopes:
        - head
        - properties
        - body
        - companion
        - interface_external
      content: |
        {%- if vars.header_code_fragment -%}
        {{new_line}}{{vars.header_code_fragment}}
        {% endif -%}
        {%- set bases_specifiers = base_types_converters|map(attribute='kotlin.target_type_name')|list + vars.bases_list %}
        {%- if base_types_converters|map(attribute='kotlin')|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}
        {%- do Error.critical(cxx.type_name + ' interface cannot inherit from a class.') %}
        {%- endif %}
        {%- if ancestors|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
        {%- do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
        {%- endif %}
        {% if vars.comment %}
        {{vars.comment|make_doxygen_comment}}
        {%- endif %}
        interface {{converter.kotlin.get_target_type_name(definition=True)}}{{' : ' + bases_specifiers|join(', ') if bases_specifiers else ' : AutoCloseable'}} {
            {%- if not base_types_converters %}
            val id: Long
            fun keepIEGenReference(ref: Any)
            {%- endif %}
            {{properties|string|indent}}
            {{body|string|indent}}
        }

        {% if interface_external %}
        class {{converter.kotlin.get_target_type_name(definition=True)}}Helper {
            companion object {
                {{interface_external|string|indent(8)}}
            }
        }
        {% endif %}

        {{'open ' if cxx.is_open}}class {{converter.kotlin.get_target_type_name(interface_class=True, definition=True)}}
        internal constructor(obj : IEGenObject) : {{converter.kotlin.target_type_name}} {
            companion object {
                {%- if vars.c_wrapper_lib_name %}
                init {
                    System.loadLibrary("{{vars.c_wrapper_lib_name}}")
                }
                {%- endif %}
                {{companion|string|indent(8)}}
            }

            protected var iegObj = obj
            private var refs: MutableList<Any> = mutableListOf()

            override fun keepIEGenReference(ref: Any) {
                refs.add(ref)
            }

            override val id: Long
                get() {
                    if (iegObj.id == 0L) {
                        throw RuntimeException("Object is not allocated")
                    }
                    return iegObj.id
                }
            {%- if head %}
            {{head|string|indent}}
            {%- endif %}
            {%- if not base_types_converters|map(attribute='kotlin')|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}

            override fun close() {
                if (iegObj.owner && iegObj.id != 0L) {
                    jFinalize(iegObj.id)
                    iegObj.id = 0L
                }
            }

            /**
            * Finalize and deletes the object
            */
            protected fun finalize() {
                close()
            }
            {% endif %}
            ///// External wrapper functions ////////////
            private external fun jFinalize(id: Long): Unit
        }
        {%- if vars.footer_code_fragment %}
        {{new_line}}{{vars.footer_code_fragment}}
        {% endif -%}
  cxx: *var_class_cxx


var_method_kotlin_include: &var_method_kotlin_include
  unique_content: |
    {%- macro gen_import(converter, gen_desc_import=false, gen_for_impl=false) -%}
    {%- if converter.parent_type_info -%}
    {#- in case of nested cases we don't need `gen_for_impl` anymore, so we don't pass it deeper -#}
    {{gen_import(make_type_converter(converter.parent_type_info.cxx.type_name).kotlin, gen_desc_import=gen_desc_import)}}
    {%- else %}
    {%- if converter.vars and converter.vars.is_proj_type and converter.vars.package != vars.package -%}
    {{marker}}import {{converter.vars.package_prefix}}.{{converter.vars.package}}.{{converter.get_target_type_name(interface_class=(gen_for_impl and converter.vars.action == 'gen_interface'))}}
    {%- endif -%}
    {%- endif %}
    {%- for arg_converter in converter.args -%}
    {{gen_import(arg_converter, gen_desc_import=gen_desc_import, gen_for_impl=gen_for_impl)}}
    {%- endfor -%}
    {%- if gen_desc_import and converter.vars and converter.vars.descendants is defined and converter.descendants is defined -%}
    {%- for descendant in (converter.vars.descendants if converter.vars.descendants is not none else converter.descendants) -%}
    {%- set desc_converter = make_type_converter(descendant).kotlin -%}
    {{gen_import(desc_converter, gen_desc_import=gen_desc_import, gen_for_impl=gen_for_impl)}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {%- for arg_converter in args|map(attribute='converter.kotlin') -%}
    {{gen_import(arg_converter)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {#- we need imports for descendants only for return type and we need to import implementation classes for downcasting -#}
    {{gen_import(rconverter.kotlin, gen_desc_import=true, gen_for_impl=true)}}
    {%- endif -%}

var_method_cxx_include: &var_method_cxx_include
  unique_content: |
    {%- if vars.is_proj_type -%}
    #include "{{vars.prj_rel_file_name}}"
    {%- endif -%}
    {%- macro gen_include(type_info, gen_desc_incl=true) -%}
    {%- if type_info.vars and type_info.vars.is_proj_type -%}
    {{marker}}#include "{{type_info.vars.prj_rel_file_name}}"
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
    {{gen_include(arg_type_info, gen_desc_incl)}}
    {%- endfor -%}
    {#- `is defined` check is done for enum types (enums don't have descendants) -#}
    {%- if gen_desc_incl and type_info.vars and type_info.vars.descendants is defined and type_info.descendants is defined -%}
    {%- for descendant in (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) -%}
    {#- generate includes for descendants list of an argument -#}
    {{gen_include(get_type_info(descendant))}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {%- for arg in args -%}
    {{gen_include(arg.type_info)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_include(return_type_info, gen_desc_incl=false)}}
    {%- endif -%}
    {#- generate includes for descendants list of `this` if the node is method -#}
    {%- if owner_class -%}
    {{gen_include(owner_class)}}
    {%- endif -%}

constructor:
  kotlin:
    include: *var_method_kotlin_include
    head: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
        {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {%- set comma = joiner(', ') %}
      constructor({%- for arg in args -%}
      {{comma()}}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}
      {%- if arg.default -%}
      {%- if arg.is_enum %}
      {%- if arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields -%}
      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} constructor argument. Iegen is skipping default value addition in target language wrappers.".format(arg.default.split('::')|last, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- else %} = {{arg.converter.kotlin.target_type_name}}.{{arg.type_info.vars.enum_field_name_prefix + arg.default.split('::')|last}}
      {%- endif -%}
      {%- else -%}
      {%- if arg.is_literal %} = {{arg.default}}{{'F' if arg.is_float}}{{'L' if arg.is_long}}
      {%- elif arg.is_null_ptr %} = null
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor -%}): this(IEGenObject(construct_helper({{args|join(', ', attribute='name')}}), true)) {
          {#- This should go to shared macro -#}
          {%- if vars.keep_alive %}
          {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
          {%- if invalid_args  %}
          {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
          {%- endif %}
          {%- for arg_idx in vars.keep_alive %}
          {%- set converter = args[arg_idx - 1].converter %}
          {%- if converter.kotlin_keep_alive %}
          {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
          {%- endif %}
          {%- endfor %}
          {%- endif %}
      }
    companion: |
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {%- set comma = joiner(', ') %}
      protected fun construct_helper({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}{%- endfor-%}): Long {
          {%- set call_args = [] %}
          {%- for arg in args %}
          {%- set converter = arg.converter.kotlin_to_jdk %}
          {%- set conversion = converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) %}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {%- endfor %}
          val id = jConstructor{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}({{call_args|join(', ')}})
          return id
      }
      {% set comma = joiner(', ') %}
      @JvmStatic
      private external fun jConstructor{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}): Long
  cxx:
    include: *var_method_cxx_include
    body: |
      {%- set parent_type_name = owner_class.converter.kotlin.get_target_type_name(interface_class=owner_class.vars.action == 'gen_interface') %}
      {%- set jni_name = helper.get_jni_func_name(vars.package_prefix + '.' + vars.package, parent_type_name, 'jConstructor' + (vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix)) %}
      extern "C" JNIEXPORT jobjectid {{jni_name}}(JNIEnv* env, jobject obj{{args|format_list(", {arg.converter.jni.target_type_name} {arg.name}", 'arg')|join}}){
          {%- set call_args = [] -%}
          {%- for arg in args -%}
          {% set converter = arg.converter.jni_to_cxx %}
          {{converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr)|indent(4)}}
          {%- do call_args.append(converter.converted_name(arg.name)) -%}
          {%- endfor %}
          {%- if 'no_throw' not in vars.throws %}
          void* err_ptr = nullptr;
          {%- endif %}
          try {
              {%- if not owner_class.root.vars.shared_ref %}
              {{owner_class.cxx.unqualified_resolved_type_name}}* ptr = new {{owner_class.cxx.type_name}}({{call_args|join(', ')}});
              return reinterpret_cast<jlong>(new IEGenCObject {strdup("{{owner_class.cxx.unqualified_canonical_type_name}}"), ptr});
              {%- else %}
              {{owner_class.cxx.type_name}}* obj_ptr = new {{owner_class.cxx.type_name}}({{call_args|join(', ')}});
              auto this_object = std::shared_ptr<{{owner_class.cxx.type_name}}>(obj_ptr);
              return reinterpret_cast<jlong>(new IEGenCObject {strdup("{{owner_class.cxx.unqualified_canonical_type_name}}"), new std::shared_ptr<{{owner_class.cxx.type_name}}>(this_object)});
              {%- endif %}
          }
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws -%}
          catch (const {{exc_type}}& e) {
              err_ptr = new {{exc_type}}(e);
              {%- set exc_info = get_type_info(exc_type) %}
              jclass excCls = env->FindClass("{{[exc_info.vars.package_prefix, exc_info.vars.package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
              jclass iegObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'alias.IEGenObject']|map('replace', '.', pat_sep)|path_join}}");
              jmethodID iegConstructor = env->GetMethodID(iegObjClass, "<init>", "(JZ)V");
              jobject iegObj = env->NewObject(iegObjClass, iegConstructor, reinterpret_cast<jobjectid>(new IEGenCObject {strdup("{{exc_info.cxx.unqualified_canonical_type_name}}"), err_ptr}), true);
              jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'alias.IEGenObject']|map('replace', '.', pat_sep)|path_join}};)V");
              jobject excObj = env->NewObject(excCls, excConstructor, iegObj);
              env->Throw(jthrowable(excObj));
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          catch (const std::exception& e) {
              jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
          }
          {%- endif %}
          catch (...) {
              jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
          }
          jobjectid result {};
          return result;
      }

method:
  kotlin:
    include: *var_method_kotlin_include
    body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname) -%}
      {%- endif -%}
      {%- if not cxx.is_static %}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set comma = joiner(', ') -%}
      {%- set setter_var_name = 'value' -%}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {{'open ' if cxx.is_open}}{{'operator ' if vars.is_operator}}{{'override ' if cxx.is_override or vars.name == 'toString'}}fun {{vars.name}}(
      {%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}
      {%- if arg.default -%}
      {%- if arg.is_enum %}
      {%- if arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields -%}
      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. Iegen is skipping default value addition in target language wrappers.".format(arg.default.split('::')|last, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- else %} = {{arg.converter.kotlin.target_type_name}}.{{arg.type_info.vars.enum_field_name_prefix + arg.default.split('::')|last}}
      {%- endif -%}
      {%- else -%}
      {%- if arg.is_literal %} = {{arg.default}}{{'F' if arg.is_float}}{{'L' if arg.is_long}}
      {%- elif arg.is_null_ptr %} = null
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if vars.nullable_return}} {
          {%- set call_args = ['id'] -%}
          {%- set result_converter = rconverter.jdk_to_kotlin -%}
          {%- for arg in args %}
          {%- set converter = arg.converter.kotlin_to_jdk -%}
          {%- set conversion = converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) -%}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {%- endfor %}
          {%- if owner_class.vars.action == 'gen_interface' %}
          val result = {{owner_class.converter.kotlin.target_type_name}}Helper.j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{call_args|join(', ')}})
          {%- else %}
          val result = j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{call_args|join(', ')}})
          {%- endif %}
          {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
          {%- if vars.keep_alive and not (vars.is_operator and vars.name == 'get') %}
          {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
          {%- if invalid_args  %}
          {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
          {%- endif %}
          {%- for arg_idx in vars.keep_alive %}
          {%- set converter = args[arg_idx - 1].converter %}
          {%- if converter.kotlin_keep_alive %}
          {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
          {%- endif %}
          {%- endfor %}
          {%- endif %}
          {%- if vars.return_value_policy == 'reference_internal' and rconverter.kotlin_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
          {%- set conversion = rconverter.kotlin_ref_internal.snippet(result_converter.converted_name('result'), reference='this', nullable=vars.nullable_return) -%}
          {%- if conversion %}
          {{conversion|indent(4)}}{% endif %}
          {%- endif %}
          return {{result_converter.converted_name('result')}}
      }


      {%- if vars.is_operator and vars.name == 'get' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}


      {{'open ' if cxx.is_open}}{{'operator ' if vars.is_operator}}{{'override ' if cxx.is_override or vars.name == 'toString'}}fun set(
      {%- for arg in args -%}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}, {{setter_var_name}}: {{rconverter.kotlin.target_type_name}}
      {%- endfor-%}){
          {%- set call_args = ['id'] -%}
          {%- for arg in args %}
          {%- set converter = arg.converter.kotlin_to_jdk -%}
          {%- set conversion = converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) -%}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {%- endfor %}
          {%- if owner_class.vars.action == 'gen_interface' %}
          {{owner_class.converter.kotlin.target_type_name}}Helper.jSet{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{call_args|join(', ')}}, {{setter_var_name}})
          {%- else %}
          jSet{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{call_args|join(', ')}}, {{setter_var_name}})
          {#- This should go to shared macro -#}
          {%- if vars.keep_alive %}
          {%- set args = args + [namespace(name='value', converter=rconverter)] -%}
          {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
          {%- if invalid_args  %}
          {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
          {%- endif %}
          {%- for arg_idx in vars.keep_alive %}
          {%- set converter = args[arg_idx - 1].converter %}
          {%- if converter.kotlin_keep_alive %}
          {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(4)}}
          {%- endif %}
          {%- endfor %}
          {%- endif %}
          {%- endif %}
      }

      {%- endif %}

      {%- endif %}
    companion: |
      {%- if cxx.is_static %}
      {%- if vars.return_value_policy == 'reference_internal' -%}
      {% do Error.critical("Cannot apply reference internal policy on a static method's return value: {}::{}".format(owner_class.cxx.type_name, cxx.name)) -%}
      {%- endif -%}
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive %}
      {%- do Error.critical('Cannot apply keep alive policy for a static member function: {}.{}'.format(cxx.name, owner_class.cxx.type_name)) -%}
      {%- endif %}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- set comma = joiner(', ') -%}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      fun {{vars.name}}({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}{%- endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if vars.nullable_return}} {
          {%- set call_args = [] %}
          {%- set result_converter = rconverter.jdk_to_kotlin -%}
          {%- for arg in args -%}
          {%- set converter = arg.converter.kotlin_to_jdk -%}
          {%- set conversion = converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) -%}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {%- endfor %}
          {%- if owner_class.vars.action == 'gen_interface' %}
          val result = {{owner_class.converter.kotlin.target_type_name}}Helper.j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{call_args|join(', ')}})
          {%- else %}
          val result = j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{call_args|join(', ')}})
          {%- endif %}
          {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent}}
          return {{result_converter.converted_name('result')}}
      }
      {%- set comma = joiner(', ') %}
      @JvmStatic
      private external fun j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}): {{rconverter.jdk.target_type_name}}
      {%- endif %}
    private_external: |
      {%- if owner_class.vars.action == 'gen_class' -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- if not cxx.is_static %}
      {%- set comma = joiner(', ') -%}
      {%- set setter_var_name = 'value' -%}
      private external fun j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}): {{rconverter.jdk.target_type_name}}
      {%- if vars.is_operator and vars.name == 'get' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
      @JvmStatic
      private external fun jSet{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}(id: Long{{', ' if args}}{%- for arg in args -%}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{{comma()}} {{setter_var_name}}: {{rconverter.kotlin.target_type_name}}{%- endfor-%})
      {%- endif %}
      {%- endif %}
      {%- endif -%}
    interface_external: |
      {%- if owner_class.vars.action == 'gen_interface' -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- if not cxx.is_static %}
      {%- set comma = joiner(', ') -%}
      {%- set setter_var_name = 'value' -%}
      @JvmStatic
      external fun j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}(id: Long{{', ' if args}}{%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}): {{rconverter.jdk.target_type_name}}
      {%- if vars.is_operator and vars.name == 'get' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
      @JvmStatic
      external fun jSet{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}(id: Long{{', ' if args}}{%- for arg in args -%}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{{comma()}} {{setter_var_name}}: {{rconverter.kotlin.target_type_name}}{%- endfor-%})
      {%- endif %}
      {%- endif %}
      {%- endif %}
  cxx:
    include: *var_method_cxx_include
    body: |
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- set objid_args=["jobjectid id"]if not cxx.is_static else [] -%}
      {%- set jni_args=["JNIEnv* env, jobject obj"] + objid_args
        + args|format_list("{arg.converter.jni.target_type_name} {arg.name}", 'arg') -%}
      {%- set parent_type_name = owner_class.converter.kotlin.target_type_name + 'Helper' if owner_class.vars.action == 'gen_interface' else owner_class.converter.kotlin.target_type_name %}
      {%- set setter_var_name = 'value' -%}
      {%- macro args_snippet(args, call_args) -%}
      {%- for arg in args -%}
      {%- set converter = arg.converter.jni_to_cxx %}
      {{converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr)}}
      {%- do call_args.append(converter.converted_name(arg.name))%}
      {% endfor %}
      {%- endmacro -%}
      {%- macro call_code(prefix, call_args, is_set_op=false) -%}
      {%- if 'no_throw' not in vars.throws %}
      void* err_ptr = nullptr;
      {%- endif -%}
      {% if rconverter.jni.target_type_name != 'void' and not is_set_op %}
      try {
          const auto& result = {{prefix}}{{cxx.name}}{%- if cxx.is_template -%}
                                              <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                              {%- endif -%}({{call_args|join(', ')}});
          {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
          return {{rconverter.cxx_to_jni.converted_name('result')}};
      }
      {%- else %}
      try {
          {{prefix}}{{cxx.name}}({{call_args|join(', ')}}){{' = ' + setter_var_name if is_set_op}};
          return;
      }
      {%- endif %}
      {%- if 'no_throw' not in vars.throws %}
      {%- for exc_type in vars.throws -%}
      catch (const {{exc_type}}& e) {
          err_ptr = new {{exc_type}}(e);
          {%- set exc_info = get_type_info(exc_type) %}
          jclass excCls = env->FindClass("{{[exc_info.vars.package_prefix, exc_info.vars.package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
          jclass iegObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'alias.IEGenObject']|map('replace', '.', pat_sep)|path_join}}");
          jmethodID iegConstructor = env->GetMethodID(iegObjClass, "<init>", "(JZ)V");
          jobject iegObj = env->NewObject(iegObjClass, iegConstructor, reinterpret_cast<jobjectid>(new IEGenCObject {strdup("{{exc_info.cxx.unqualified_canonical_type_name}}"), err_ptr}), true);
          jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'alias.IEGenObject']|map('replace', '.', pat_sep)|path_join}};)V");
          jobject excObj = env->NewObject(excCls, excConstructor, iegObj);
          env->Throw(jthrowable(excObj));
      }
      {%- endfor %}
      {%- endif %}
      {%- if not 'std::exception' in vars.throws %}
      catch (const std::exception& e) {
          jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
          jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
          env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
      }
      {%- endif %}
      catch (...) {
          jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
          jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
          env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
      }

      {% if rconverter.jni.target_type_name != 'void' and not is_set_op -%}
      {{rconverter.jni.target_type_name}} result {};
      return result;
      {%- endif %}
      {%- endmacro -%}
      {%- macro gen_method(is_set_op=false) -%}
      {%- set func_name="j%s%s%s"|format('Set' if is_set_op else vars.name|capitalize, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix, template_postfix) %}
      {%- set jni_name = helper.get_jni_func_name(vars.package_prefix + '.' + vars.package, parent_type_name, func_name) %}

      extern "C" JNIEXPORT {{ 'void' if is_set_op else rconverter.jni.target_type_name }} {{jni_name}}({{jni_args|join(', ')}}{{', ' + rconverter.jni.target_type_name + ' ' + setter_var_name if is_set_op}}){
          {%- set call_args = [] %}
          {{args_snippet(args, call_args)|indent(4)}}
          {%- if not cxx.is_static %}
          validateID(id);
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').jni_to_cxx if owner_class.vars.shared_ref else owner_class.converter.jni_to_cxx -%}
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          {{call_code(this_converter.converted_name('id') + "->", call_args, is_set_op)|indent(4)}}
          {%- else %}
          {{call_code(owner_class.cxx.type_name + "::", call_args, is_set_op)|indent(4)}}
          {%- endif %}
      }
      {%- endmacro -%}
      {{gen_method()}}
      {%- if vars.is_operator and vars.name == 'get' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
      {{gen_method(is_set_op=true)}}
      {%- endif %}

function:
  kotlin:
    include: *var_method_kotlin_include
    body: |
      {%- if vars.return_value_policy == 'reference_internal' -%}
      {% do Error.critical("Cannot apply reference internal policy on a non member function's return value: {} in {}".format(cxx.name, vars.file_fullname)) -%}
      {%- endif -%}
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname) -%}
      {%- endif -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set comma = joiner(', ') -%}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      fun {{vars.name}}({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.kotlin.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}
      {%- if arg.default -%}
      {%- if arg.is_enum %}
      {%- if arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields -%}
      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. Iegen is skipping default value addition in target language wrappers.".format(arg.default.split('::')|last, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- else %} = {{arg.converter.kotlin.target_type_name}}.{{arg.type_info.vars.enum_field_name_prefix + arg.default.split('::')|last}}
      {%- endif -%}
      {%- else -%}
      {%- if arg.is_literal %} = {{arg.default}}{{'F' if arg.is_float}}{{'L' if arg.is_long}}
      {%- elif arg.is_null_ptr %} = null
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor-%}): {{rconverter.kotlin.target_type_name}}{{'?' if vars.nullable_return}} {
          {%- set call_args = [] -%}
          {%- set result_converter = rconverter.jdk_to_kotlin -%}
          {%- for arg in args %}
          {%- set converter = arg.converter.kotlin_to_jdk -%}
          {%- set conversion = converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) -%}
          {%- if conversion %}
          {{conversion|indent}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {%- endfor %}
          val result = j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({{call_args|join(', ')}})
          {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent}}
          return {{result_converter.converted_name('result')}}
      }
    glob_external: |
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- set comma = joiner(', ') -%}
      private external fun j{{vars.name|capitalize}}{{vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none else overloading_postfix}}{{template_postfix}}({%- for arg in args -%}{{comma()}}{{arg.name}}: {{arg.converter.jdk.target_type_name}}{%- endfor-%}): {{rconverter.jdk.target_type_name}}
    glob_init:
      unique_content: |
        {%- if vars.c_wrapper_lib_name %}
        val INIT = run {
            System.loadLibrary("{{vars.c_wrapper_lib_name}}");
        }
        {%- endif %}
  cxx:
    include: *var_method_cxx_include
    body: |
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- set func_name="j%s%s%s"|format(vars.name|capitalize, vars.overloading_postfix if cxx.is_overloaded and vars.overloading_postfix is not none and cxx.is_overloaded else overloading_postfix, template_postfix) %}
      {%- set jni_args=["JNIEnv* env, jclass cls"] + args|format_list("{arg.converter.jni.target_type_name} {arg.name}", 'arg') -%}
      {%- macro args_snippet(args, call_args) %}
      {%- for arg in args -%}
      {%- set converter = arg.converter.jni_to_cxx %}
      {%- set conversion = converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) %}
      {%- if conversion %}
      {{conversion}}
      {%- endif %}
      {%- do call_args.append(converter.converted_name(arg.name))%}
      {%- endfor %}
      {%- endmacro %}
      {%- macro call_code(call_args) %}
      {%- if 'no_throw' not in vars.throws %}
      void* err_ptr = nullptr;
      {%- endif -%}
      {%- if rconverter.jni.target_type_name != 'void' %}
      try {
          const auto& result = {{cxx.namespace}}::{{cxx.name}}{%- if cxx.is_template -%}
                                              <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                              {%- endif -%}({{call_args|join(', ')}});
          {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
          return {{rconverter.cxx_to_jni.converted_name('result')}};
      }
      {%- else %}
      try {
          {{cxx.namespace}}::{{cxx.name}}({{call_args|join(', ')}});
          return;
      }
      {%- endif %}
      {%- if 'no_throw' not in vars.throws %}
      {%- for exc_type in vars.throws -%}
      catch (const {{exc_type}}& e) {
          err_ptr = new {{exc_type}}(e);
          {%- set exc_info = get_type_info(exc_type) %}
          jclass excCls = env->FindClass("{{[exc_info.vars.package_prefix, exc_info.vars.package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
          jclass iegObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'alias.IEGenObject']|map('replace', '.', pat_sep)|path_join}}");
          jmethodID iegConstructor = env->GetMethodID(iegObjClass, "<init>", "(JZ)V");
          jobject iegObj = env->NewObject(iegObjClass, iegConstructor, reinterpret_cast<jobjectid>(new IEGenCObject {strdup("{{exc_info.cxx.unqualified_canonical_type_name}}"), err_ptr}), true);
          jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'alias.IEGenObject']|map('replace', '.', pat_sep)|path_join}};)V");
          jobject excObj = env->NewObject(excCls, excConstructor, iegObj);
          env->Throw(jthrowable(excObj));
      }
      {%- endfor %}
      {%- endif %}
      {%- if not 'std::exception' in vars.throws %}
      catch (const std::exception& e) {
          jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
          jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
          env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
      }
      {%- endif %}
      catch (...) {
          jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
          jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
          env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
      }

      {% if rconverter.jni.target_type_name != 'void' -%}
      {{rconverter.jni.target_type_name}} result {};
      return result;
      {%- endif %}
      {%- endmacro %}
      {%- set jni_name = helper.get_jni_func_name(vars.package_prefix + '.' + vars.package, vars.file|capitalize + 'Kt', func_name) %}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}({{jni_args|join(', ')}}){
          {%- set call_args = [] %}
          {{args_snippet(args, call_args)|indent(4)}}
          {{call_code(call_args)|indent(4)}}
      }


var_getter_kotlin_include: &var_getter_kotlin_include
  unique_content: |
    {%- macro gen_import(converter, gen_desc_import=false, gen_for_impl=false) -%}
    {%- if converter.parent_type_info -%}
    {#- in case of nested cases we don't need `gen_for_impl` anymore, so we don't pass it deeper -#}
    {{gen_import(make_type_converter(converter.parent_type_info.cxx.type_name).kotlin, gen_desc_import=gen_desc_import)}}
    {%- else %}
    {%- if converter.vars and converter.vars.is_proj_type and converter.vars.package != vars.package -%}
    {{marker}}import {{converter.vars.package_prefix}}.{{converter.vars.package}}.{{converter.get_target_type_name(interface_class=(gen_for_impl and converter.vars.action == 'gen_interface'))}}
    {%- endif -%}
    {%- endif %}
    {%- for arg_converter in converter.args -%}
    {{gen_import(arg_converter, gen_desc_import=gen_desc_import, gen_for_impl=gen_for_impl)}}
    {%- endfor -%}
    {%- if gen_desc_import and converter.vars and converter.vars.descendants is defined and converter.descendants is defined -%}
    {%- for descendant in (converter.vars.descendants if converter.vars.descendants is not none else converter.descendants) -%}
    {%- set desc_converter = make_type_converter(descendant).kotlin -%}
    {{gen_import(desc_converter, gen_desc_import=gen_desc_import, gen_for_impl=gen_for_impl)}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {#- we need imports for descendants only for return type and we need to import implementation classes for downcasting -#}
    {{gen_import(rconverter.kotlin, gen_desc_import=true, gen_for_impl=true)}}

var_getter_cxx_include: &var_getter_cxx_include
  unique_content: |
    {%- macro gen_include(type_info, gen_desc_incl=true) -%}
    {%- if type_info.vars and type_info.vars.is_proj_type -%}
    {{marker}}#include "{{type_info.vars.prj_rel_file_name}}"
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
    {{gen_include(arg_type_info, gen_desc_incl)}}
    {%- endfor -%}
    {#- `is defined` check is done for enum types (enums don't have descendants) -#}
    {%- if gen_desc_incl and type_info.vars and type_info.vars.descendants is defined and type_info.descendants is defined -%}
    {%- for descendant in (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) -%}
    {#- generate includes for descendants list of an argument -#}
    {{gen_include(get_type_info(descendant))}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {{gen_include(return_type_info, gen_desc_incl=false)}}{{gen_include(owner_class)}}

property_getter:
  kotlin:
    include: *var_getter_kotlin_include
    properties: |
      {%- if not cxx.is_public -%}
        {%- do Error.critical("{}.{} is not a public field. Make it public or remove iegen API.".format(owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- set owner_name = owner_class.converter.kotlin.target_type_name -%}
      {% set result_converter = rconverter.jdk_to_kotlin %}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {{'var' if vars.action == 'gen_property_setter' else 'val'}} {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}}
          get() {
              {%- if owner_class.vars.action == 'gen_interface' %}
              val result = {{owner_name}}Helper.j{{vars.name|capitalize}}(id)
              {%- else %}
              val result = j{{vars.name|capitalize}}(id)
              {%- endif %}
              {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(8)}}
              {%- if vars.return_value_policy == 'reference_internal' and rconverter.kotlin_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
              {%- set conversion = rconverter.kotlin_ref_internal.snippet(result_converter.converted_name('result'), reference='this', nullable=vars.nullable_return) -%}
              {%- if conversion %}
              {{conversion|indent(8)}}{% endif %}
              {%- endif %}
              return {{result_converter.converted_name('result')}}
          }
          {%- if vars.action == 'gen_property_setter' %}
          {%- set converter = rconverter.kotlin_to_jdk %}
          set(value) {
              {{converter.snippet('value', nullable=vars.nullable_return)|indent(8)}}
              {%- if owner_class.vars.action == 'gen_interface' %}
              {{owner_name}}Helper.jSet{{vars.name|lower}}(id, {{converter.converted_name('value')}})
              {%- else %}
              jSet{{vars.name|lower}}(id, {{converter.converted_name('value')}})
              {%- endif %}
              {#- This should go to shared macro -#}
              {%- if vars.keep_alive %}
              {%- set args = [namespace(name='value', converter=rconverter)] %}
              {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
              {%- if invalid_args  %}
              {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
              {%- endif %}
              {%- for arg_idx in vars.keep_alive %}
              {%- set converter = args[arg_idx - 1].converter %}
              {%- if converter.kotlin_keep_alive %}
              {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(8)}}
              {%- endif %}
              {%- endfor %}
              {%- endif %}
          }
          {% endif %}
    private_external: |
      {%- if owner_class.vars.action == 'gen_class' -%}
      private external fun j{{vars.name|capitalize}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if vars.action == 'gen_property_setter' %}
      private external fun jSet{{vars.name|lower}}(id: Long, value: {{rconverter.jdk.target_type_name}}): Unit
      {%- endif %}
      {%- endif %}
    interface_external: |
      {%- if owner_class.vars.action == 'gen_interface' %}

      @JvmStatic
      external fun j{{vars.name|capitalize}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if vars.action == 'gen_property_setter' %}

      @JvmStatic
      external fun jSet{{vars.name|lower}}(id: Long, value: {{rconverter.jdk.target_type_name}}): Unit
      {%- endif %}
      {%- endif %}
  cxx:
    include: *var_getter_cxx_include
    body: |
      {%- set parent_type_name = owner_class.converter.kotlin.target_type_name + 'Helper' if owner_class.vars.action == 'gen_interface' else owner_class.converter.kotlin.target_type_name %}
      {%- set func_name="j%s"|format(vars.name|capitalize) %}
      {%- set jni_name = helper.get_jni_func_name(vars.package_prefix + '.' + vars.package, parent_type_name, func_name) %}
      {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').jni_to_cxx if owner_class.vars.shared_ref else owner_class.converter.jni_to_cxx -%}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}(JNIEnv* env, jobject obj, jobjectid id){
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          const auto& result = {{this_converter.converted_name('id')}}->{{cxx.name}};
          {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(4)}}
          return {{rconverter.cxx_to_jni.converted_name('result')}};
      }
      {%- if vars.action == 'gen_property_setter' %}
      {% set func_name="jSet%s"|format(vars.name|lower) %}
      {%- set jni_name = helper.get_jni_func_name(vars.package_prefix + '.' + vars.package, parent_type_name, func_name) %}
      extern "C" JNIEXPORT void {{jni_name}}(JNIEnv* env, jobject obj, jobjectid id, {{rconverter.jni.target_type_name}} value){
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          {% set converter = rconverter.jni_to_cxx %}
          {{converter.snippet('value', nullable=vars.nullable_return)|indent(4)}}
          {{this_converter.converted_name('id')}}->{{cxx.name}} = {{converter.converted_name('value')}};
      }
      {% endif %}

getter:
  kotlin:
    include: *var_getter_kotlin_include
    properties: |
      {%- do helper.validate_getter(cxx, vars, args, owner_class, setter|default(none)) -%}
      {%- do helper.validate_template_getter_setter(cxx, vars, owner_class, setter|default(none)) -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set owner_name = owner_class.converter.kotlin.target_type_name -%}
      {% set result_converter = rconverter.jdk_to_kotlin %}
      {%- if vars.comment %}
      {{vars.comment|make_doxygen_comment}}
      {%- endif %}
      {{'open ' if cxx.is_open}}{{'override ' if cxx.is_override}}{{'var ' if setter is defined else 'val '}}
                                             {%- if cxx.is_template -%}
                                             {%- for name in template_names or [] %}
                                             {%- if name != None %}{{name}}{% else %}{{template_type_converters[loop.index - 1].custom.tname}}{% endif %}
                                             {%- endfor %}
                                             {%- else %}{{vars.name}}
                                             {%- endif -%}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}}
          get() {
              {%- if owner_class.vars.action == 'gen_interface' %}
              val result = {{owner_name}}Helper.j{{vars.name|capitalize}}{{template_postfix}}(id)
              {%- else %}
              val result = j{{vars.name|capitalize}}{{template_postfix}}(id)
              {%- endif %}
              {{result_converter.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(8)}}
              {%- if vars.return_value_policy == 'reference_internal' and rconverter.kotlin_ref_internal and (return_type_info.cxx.is_lval_reference or return_type_info.cxx.is_pointer) %}
              {%- set conversion = rconverter.kotlin_ref_internal.snippet(result_converter.converted_name('result'), reference='this', nullable=vars.nullable_return) -%}
              {%- if conversion %}
              {{conversion|indent(8)}}{%- endif %}
              {%- endif %}
              return {{result_converter.converted_name('result')}}
          }
          {%- if setter is defined %}
          {%- set incorrect_nullable_args = setter.vars.nullable_arg|reject('in', setter.args|map(attribute='name'))|list -%}
          {%- if incorrect_nullable_args -%}
            {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), setter.owner_class.cxx.displayname, setter.cxx.displayname)) -%}
          {%- endif -%}
          {%- set converter = setter.args[0].converter.kotlin_to_jdk %}
          {%- if cxx.is_override %}
          set(value) {
              super.{{vars.name}} = value
          }
          {%- else %}
          set(value) {
              {{converter.snippet('value', nullable=vars.nullable_return)|indent(8)}}
              {%- if owner_class.vars.action == 'gen_interface' %}
              {{owner_name}}Helper.j{{setter.vars.name|capitalize}}{{template_postfix}}(id, {{converter.converted_name('value')}})
              {%- else %}
              j{{setter.vars.name|capitalize}}{{template_postfix}}(id, {{converter.converted_name('value')}})
              {%- endif %}
              {%- if setter.vars.keep_alive %}
              {%- set args = [namespace(name='value', converter=rconverter)] %}
              {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
              {%- if invalid_args  %}
              {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args)) -%}
              {%- endif %}
              {%- for arg_idx in vars.keep_alive %}
              {%- set converter = args[arg_idx - 1].converter %}
              {%- if converter.kotlin_keep_alive %}
              {{converter.kotlin_keep_alive.snippet('this', reference=args[arg_idx - 1].name|to_camel_case)|indent(8)}}
              {%- endif %}
              {%- endfor %}
              {%- endif %}
          }
          {%- endif %}
          {%- endif %}
    private_external: |
      {%- if owner_class.vars.action == 'gen_class' -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      private external fun j{{vars.name|capitalize}}{{template_postfix}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if setter is defined %}
      private external fun j{{setter.vars.name|capitalize}}{{template_postfix}}(id: Long, value: {{setter.args[0].converter.jdk.target_type_name}}): Unit
      {%- endif %}
      {%- endif %}
    interface_external: |
      {%- if owner_class.vars.action == 'gen_interface' -%}
      {% set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      @JvmStatic
      external fun j{{vars.name|capitalize}}{{template_postfix}}(id: Long): {{rconverter.jdk.target_type_name}}
      {%- if setter is defined %}

      @JvmStatic
      external fun j{{setter.vars.name|capitalize}}{{template_postfix}}(id: Long, value: {{setter.args[0].converter.jdk.target_type_name}}): Unit
      {%- endif %}
      {%- endif %}
  cxx:
    include: *var_getter_cxx_include
    body: |
      {%- macro gen_exc_try_block(vars) -%}
      {%- if 'no_throw' not in vars.throws %}
      {%- for exc_type in vars.throws -%}
          catch (const {{exc_type}}& e) {
              err_ptr = new {{exc_type}}(e);
              {%- set exc_info = get_type_info(exc_type) %}
              jclass excCls = env->FindClass("{{[exc_info.vars.package_prefix, exc_info.vars.package, exc_info.vars.name]|map('replace', '.', pat_sep)|path_join}}");
              jclass iegObjClass = env->FindClass("{{[vars.helpers_package_prefix, 'alias.IEGenObject']|map('replace', '.', pat_sep)|path_join}}");
              jmethodID iegConstructor = env->GetMethodID(iegObjClass, "<init>", "(JZ)V");
              jobject iegObj = env->NewObject(iegObjClass, iegConstructor, reinterpret_cast<jobjectid>(new IEGenCObject {strdup("{{exc_info.cxx.unqualified_canonical_type_name}}"), err_ptr}), true);
              jmethodID excConstructor = env->GetMethodID(excCls, "<init>", "(L{{[vars.helpers_package_prefix, 'alias.IEGenObject']|map('replace', '.', pat_sep)|path_join}};)V");
              jobject excObj = env->NewObject(excCls, excConstructor, iegObj);
              env->Throw(jthrowable(excObj));
          }
      {%- endfor %}
      {%- endif %}
      {%- if not 'std::exception' in vars.throws %}
          catch (const std::exception& e) {
              jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF(e.what()));
          }
      {%- endif %}
          catch (...) {
              jclass handlerCls = env->FindClass({{"\"{}/exceptionUtils/ExceptionHandler\"".format(vars.helpers_package_prefix|replace('.', pat_sep))}});
              jmethodID handlerMethod = env->GetStaticMethodID(handlerCls, "handleUncaughtException", "(Ljava/lang/String;)V");
              env->CallStaticVoidMethod(handlerCls, handlerMethod, env->NewStringUTF("Uncaught Exception"));
          }
      {%- endmacro -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.kotlin.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set func_name="j%s%s"|format(vars.name|capitalize, template_postfix) %}
      {%- if cxx.is_template -%}
      {%- set template_args = '<' + template_choice.values()|format_list("{type}", 'type')|join(', ') + '>' %}
      {%- else %}
      {%- set template_args = '' %}
      {%- endif %}
      {%- set parent_type_name = owner_class.converter.kotlin.target_type_name + 'Helper' if owner_class.vars.action == 'gen_interface' else owner_class.converter.kotlin.target_type_name %}
      {%- set jni_name = helper.get_jni_func_name(vars.package_prefix + '.' + vars.package, parent_type_name, func_name) %}
      {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').jni_to_cxx if owner_class.vars.shared_ref else owner_class.converter.jni_to_cxx %}
      extern "C" JNIEXPORT {{rconverter.jni.target_type_name}} {{jni_name}}(JNIEnv* env, jobject obj, jobjectid id){
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          {%- if 'no_throw' not in vars.throws %}
          void* err_ptr = nullptr;
          {%- endif %}
          try {
              const auto& result = {{this_converter.converted_name('id')}}->{{cxx.name}}{{template_args}}();
              {{rconverter.cxx_to_jni.snippet('result', value_policy=vars.return_value_policy, nullable=vars.nullable_return)|indent(8)}}
              return {{rconverter.cxx_to_jni.converted_name('result')}};
          }
          {{gen_exc_try_block(vars)}}

          {{rconverter.jni.target_type_name}} result {};
          return result;
      }
      {%- if setter is defined %}
      {% set func_name="j%s%s"|format(setter.vars.name|capitalize, template_postfix) %}
      {%- set jni_setter_name = helper.get_jni_func_name(vars.package_prefix + '.' + vars.package, parent_type_name, func_name) %}
      extern "C" JNIEXPORT void {{jni_setter_name}}(JNIEnv* env, jobject obj, jobjectid id, {{setter.args[0].converter.jni.target_type_name}} {{setter.args[0].name}}){
          validateID(id);
          {{this_converter.snippet('id', cxx_is_pointer=True)|indent(4)}}
          {%- set converter = setter.args[0].converter.jni_to_cxx %}
          {{converter.snippet(setter.args[0].name, nullable=vars.nullable_return)|indent(4)}}
          {%- if 'no_throw' not in vars.throws %}
          void* err_ptr = nullptr;
          {%- endif %}
          try {
             {{this_converter.converted_name('id')}}->{{setter.cxx.name}}{{template_args}}({{converter.converted_name(setter.args[0].name)}});
          }
          {{gen_exc_try_block(setter.vars)}}
      }
      {% endif %}
