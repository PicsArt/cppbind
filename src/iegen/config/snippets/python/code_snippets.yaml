file:
  python_init:
    file_path: |
      {{vars.out_dir + pat_sep + [vars.package_prefix, vars.package, '__init__']|map('replace', '.', pat_sep)|path_join}}.{{vars.extension}}
    scopes:
      - include
      - code_fragment
    content: |
      {{[banner_logo, vars.banner_comment]|make_py_docstring}}
      {{include}}
      {%- if code_fragment %}
      {{code_fragment}}
      {%- else %}
      {%- endif %}{{new_line}}
  python:
    file_path: |
      {{vars.target_file_fullname}}
    scopes:
      - body
      - include
    content: |
      {{[banner_logo, vars.banner_comment]|make_py_docstring}}
      {%- set future_import = 'from __future__ import annotations' %}
      {%- set typing_import = 'from typing import *' %}
      {%- set pybind_import = 'import ' + [vars.pybind_module, vars.package, vars.file]|join('.') + ' as pybind_' + vars.file + vars.file_postfix %}
      {%- if vars.helpers_package_prefix %}
      {%- set bind_import = 'from ' + vars.helpers_package_prefix + '.bind_utils{} import *'.format(vars.file_postfix) %}
      {%- else %}
      {%- set bind_import = 'from bind_utils{} import *'.format(vars.file_postfix) %}
      {%- endif %}
      {%- set helpers = helper_includes|format_list('from {} import *')|join_unique %}
      {{[future_import, typing_import, pybind_import, include, helpers, bind_import]|join(new_line)|sort_python_code}}
      {{body}}{{new_line}}
  cxx:
    file_path: |
      {{vars.c_file_fullname}}
    scopes:
      - include
      - header
      - body
      - footer
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include <pybind11/pybind11.h>
      #include <pybind11/stl.h>
      #include <pybind11/functional.h>

      {{include}}

      namespace py = pybind11;

      {{header}}
          {{body|string|indent(4)}}
      {{footer}}{{new_line}}
  hpp:
    file_path: |
      {{vars.h_file_fullname}}
    scopes:
      - header
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      {% set filename = [vars.package_prefix, vars.package, vars.file]|map('replace', '.', '_')|join('_') -%}
      #ifndef {{filename}}_hpp
      #define {{filename}}_hpp

      #include <pybind11/pybind11.h>

      namespace py = pybind11;

      {{header}}

      #endif{{new_line}}
  pybind_module_cxx:
    file_path: |
      {{vars.c_pybind_filename}}
    scopes:
      - body
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include <pybind11/pybind11.h>
      #include "{{path.relpath(vars.h_pybind_filename, vars.out_prj_dir)}}"

      namespace py = pybind11;

      void bind{{vars.pybind_module.replace('.', '_')|capitalize|to_camel_case}}(py::module& m) {
          {{body|string|indent}}
      }{{new_line}}
  pybind_module_hpp:
    file_path: |
      {{vars.h_pybind_filename}}
    scopes:
      - include
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      {% set package = vars.pybind_module.split('.')[-1] -%}
      #ifndef {{package + vars.file_postfix}}_hpp
      #define {{package + vars.file_postfix}}_hpp

      {{include}}
      #include <pybind11/pybind11.h>

      namespace py = pybind11;
      void bind{{vars.pybind_module.replace('.', '_')|capitalize|to_camel_case}}(py::module& m);

      #endif{{new_line}}
  pybind_package:
    file_path: |
      {{vars.pybind_module_filename}}
    gen: false
    scopes:
      - body
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}
      {% set packages = vars.pybind_module.split('.') %}
      {%- set package = packages[0] %}
      #include <pybind11/pybind11.h>
      #include "{{path.relpath(vars.h_pybind_filename, vars.out_prj_dir)}}"

      namespace py = pybind11;
      PYBIND11_MODULE({{package}}, m) {
          py::module_ parent = m;
          {%- for p in packages[1:] %}
          {%- set parent_module = packages[loop.index - 1] %}
          py::module_ {{parent_module}} = parent.def_submodule("{{p}}", "{{p}}");
          parent = {{parent_module}};
          {%- endfor %}
          bind{{vars.pybind_module.replace('.', '_').split('_')|map('capitalize')|join}}(parent);
      }{{new_line}}
  bind: !include bind_snippet.yaml

var_pybind_module_cxx: &var_pybind_module
  body:
    unique_content: |
      {%- set package_name = vars.package|replace('.', '_') -%}
      {{marker}}py::module_ {{package_name}} = m.def_submodule("{{vars.package}}", "{{vars.package}}");
      {{marker}}py::module_ {{package_name}}_{{vars.file}} = {{package_name}}.def_submodule("{{vars.file}}", "{{vars.file}}");
      {{marker}}bind{{[vars.package_prefix, vars.package, vars.file]|map('replace', '.', '_')|join('_')|to_camel_case(capitalize=True)}}({{package_name}}_{{vars.file}});

package:
  python_init:
    code_fragment:
      unique_content: |
        {%- if vars.code_fragment -%}
        {{marker}}
        {{vars.code_fragment}}
        {%- endif -%}
    include:
      unique_content: |
        {{vars.include|format_list('from {} import *')|join_unique}}

var_pybind_module_hpp: &var_pybind_module_hpp
  include:
    unique_content: |
      #include "{{path.relpath(vars.h_file_fullname, vars.out_prj_dir)}}"

var_hpp_header: &var_hpp_header
  unique_content: |
    void bind{{[vars.package_prefix, vars.package, vars.file]|map('replace', '.', '_')|join('_')|to_camel_case(capitalize=True)}}(py::module& m);


var_cxx_header: &var_cxx_header
  unique_content: |
    void bind{{[vars.package_prefix, vars.package, vars.file]|map('replace', '.', '_')|join('_')|to_camel_case(capitalize=True)}}(py::module& m) {

var_cxx_footer: &var_cxx_footer
  unique_content: |
    } /* bind{{[vars.package_prefix, vars.package, vars.file]|map('replace', '.', '_')|join('_')|to_camel_case(capitalize=True)}} */


enum:
  python:
    body: |
      {%- if vars.header_code_fragment %}
      {{vars.header_code_fragment}}{{new_line}}
      {%- endif %}
      {% set m = 'pybind_' + vars.file + vars.file_postfix %}
      class {{vars.name}}({{vars.bases_list|join(', ')}}{{', ' if vars.bases_list}}metaclass=EnumMetaclass):
          {{vars.comment|make_py_docstring|indent}}
          {%- for case in enum_cases -%}
          {%- if case.name not in vars.enum_excluded_fields -%}
          {%- if case.comment %}
          {{case.comment|make_py_comment|indent}}
          {%- endif %}
          {{vars.enum_field_name_prefix + case.name}} = {{m}}.{{vars.name}}.{{case.name}}
          {%- endif %}
          {%- endfor %}

          def __int__(self):
              return self.value
          {%- if vars.code_fragment %}

          {{vars.code_fragment|indent(4)}}
          {%- endif %}
          {%- if vars.footer_code_fragment %}
          {{new_line}}{{vars.footer_code_fragment}}
          {%- endif %}
  python_init:
    include:
      unique_content: |
        from .{{vars.file + vars.file_postfix}} import {{vars.name}}
  cxx:
    header: *var_cxx_header
    footer: *var_cxx_footer
    body: |
      {
          {%- if cxx.namespace %}
          using namespace {{cxx.namespace}};
          {%- endif %}
          py::enum_<{{cxx.type_name}}>(m, "{{vars.name}}")
              {%- for case in enum_cases %}
              {%- if case.name not in vars.enum_excluded_fields %}
              .value("{{case.name}}", {{cxx.type_name}}::{{case.name}})
              {%- endif %}
              {%- endfor -%};
      }
    include:
      unique_content: |
        #include "{{vars.prj_rel_file_name}}"
  hpp:
    header: *var_hpp_header
  pybind_module_cxx: *var_pybind_module
  pybind_module_hpp: *var_pybind_module_hpp
  pybind_package:
    body:

var_class: &var_class
  python:
    include:
      unique_content: |
        {%- if cxx.is_abstract -%}
        {{marker}}from abc import abstractmethod
        {%- endif -%}
        {%- if vars.include -%}
        {{marker}}{{vars.include|format_list("from {} import *")|join_unique}}
        {%- endif -%}
        {%- macro gen_import(type_info) -%}
        {%- if type_info.vars and type_info.vars.is_proj_type and type_info.vars.target_file_fullname != vars.target_file_fullname -%}
        {{marker}}import {{type_info.vars.package_prefix + '.' if type_info.vars.package_prefix}}{{type_info.vars.package}}.{{type_info.vars.file + type_info.vars.file_postfix}} as {{type_info.vars.file}}
        {%- endif -%}
        {%- for arg_type_info in type_info.arg_types_infos -%}
        {{gen_import(arg_type_info)}}
        {%- endfor -%}
        {%- endmacro -%}
        {%- for base in base_types_infos -%}
        {{gen_import(base)}}
        {%- endfor -%}
    body:
      scopes:
        - constructor_body
        - properties
        - body
      content: |
        {%- if ancestors|rejectattr('vars.shared_ref', 'equalto', vars.shared_ref)|list|length != 0 %}
        {%- do Error.critical(cxx.type_name + ' ancestors have different values for shared_ref variable.') %}
        {%- endif %}
        {%- if vars.header_code_fragment %}
        {{vars.header_code_fragment}}{{new_line}}
        {%- endif %}
        {%- set bases_specifiers = [] -%}
        {%- for base_type_converter in base_types_converters|map(attribute='python') -%}
        {%- set base_type_package = base_type_converter.vars.file + '.' if base_type_converter.is_obj_type and base_type_converter.vars.target_file_fullname != vars.target_file_fullname else '' -%}
        {%- do bases_specifiers.append(base_type_package + base_type_converter.target_type_name) -%}
        {%- endfor -%}
        {%- do bases_specifiers.extend(vars.bases_list) -%}
        {%- do bases_specifiers.append('metaclass=OriginalMethodsMetaclass') %}

        class {{converter.python.get_target_type_name(definition=True)}}({{bases_specifiers|join(', ')}}):
            {%- if vars.comment %}
            {{vars.comment|make_py_docstring|indent}}
            {%- endif %}
            {%- if not cxx.is_abstract %}
            {%- if constructor_body %}
            {{constructor_body|string|indent}}
            {%- endif %}
            {%- else %}
            @abstractmethod
            def __init__(self, *args, **kwargs):
                pass
            {%- endif %}
            {%- if properties %}
            {{properties|string|indent}}
            {%- endif %}
            {%- if body %}
            {{body|string|indent}}
            {%- endif %}
            {%- if (not cxx.is_abstract, not constructor_body, not properties, not body)|all %}
            pass
            {%- endif %}
            {%- if vars.footer_code_fragment %}
            {{new_line}}{{vars.footer_code_fragment}}
            {%- endif %}
  python_init:
    include:
      unique_content: |
        {%- if not converter.python.parent_type_info -%}{#- do not generate an import for nested type in __init__.py -#}
        from .{{vars.file + vars.file_postfix}} import {{converter.python.target_type_name}}
        {%- endif -%}
  cxx:
    header: *var_cxx_header
    footer: *var_cxx_footer
    include:
      unique_content: |
        {%- if vars.is_proj_type -%}
        #include "{{vars.prj_rel_file_name}}"
        {%- endif -%}
        {%- macro gen_include(type_info) -%}
        {%- if type_info.vars and type_info.vars.is_proj_type -%}
        {{marker}}#include "{{type_info.vars.prj_rel_file_name}}"
        {%- endif -%}
        {%- for arg_type_info in type_info.arg_types_infos -%}
        {{gen_include(arg_type_info)}}
        {%- endfor -%}
        {%- endmacro -%}
        {%- for base in base_types_infos -%}
        {{gen_include(base)}}
        {%- endfor -%}
        {%- if vars.include_cxx -%}
        {{marker}}{{vars.include_cxx|select('match_regexp', '^<.*>$', '^".*"$')|format_list('#include {}')|join_unique}}
        {{marker}}{{vars.include_cxx|reject('match_regexp', '^<.*>$', '^".*"$')|format_list('#include "{}"')|join_unique}}
        {%- endif -%}
    body:
      scopes:
        - body
      content: |
        {
            {%- if cxx.namespace %}
            using namespace {{cxx.namespace}};
            {%- endif %}
            {% set comma = joiner(', ') -%}
            {% set shared_ptr = 'std::shared_ptr<' + cxx.type_name + '>' -%}
            py::class_<{{cxx.type_name}} {%- if vars.shared_ref -%}
                                          , std::shared_ptr<{{cxx.type_name}}>
                                         {%- endif %}
                                         {%- if base_types_converters -%}
                                         , {% for base_info in base_types_infos -%}
                                         {{comma()}}{{base_info.cxx.type_name}}
                                         {%- endfor -%}
                                         {%- endif %}> {{converter.python.get_target_type_name(definition=True)|decapitalize}}(m, "{{converter.python.get_target_type_name(definition=True)}}"{{', py::is_final()' if not cxx.is_open}});
            {{body|string|indent(4)}}
        }
  hpp:
    header: *var_hpp_header
  pybind_module_cxx: *var_pybind_module
  pybind_module_hpp: *var_pybind_module_hpp
  pybind_package:
    body:

class: *var_class

interface: *var_class


var_bind_method: &var_bind_method
  converter:
    unique_content: |
      {%- for arg in args -%}
      {%- set converter = arg.converter.python_to_pybind -%}
      {%- set snippet = converter.snippet('arg') -%}
      {%- if snippet -%}
      {{marker}}if type_hint == '{{arg.converter.python.target_type_name}}':
          {{snippet|indent}}
          return {{converter.converted_name('arg')}}
      {%- endif -%}
      {%- endfor -%}

var_method_python_include: &var_method_python_include
  unique_content: |
    {%- macro gen_import(type_info) -%}
    {%- if type_info.vars and type_info.vars.is_proj_type and type_info.vars.target_file_fullname != vars.target_file_fullname -%}
    {{marker}}import {{type_info.vars.package_prefix + '.' if type_info.vars.package_prefix}}{{type_info.vars.package}}.{{type_info.vars.file + type_info.vars.file_postfix}} as {{type_info.vars.file}}
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
    {{gen_import(arg_type_info)}}
    {%- endfor -%}
    {%- endmacro -%}
    {%- for arg in args -%}
    {{gen_import(arg.type_info)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_import(return_type_info)}}
    {%- endif -%}

var_method_cxx_include: &var_method_cxx_include
  unique_content: |
    {{marker}}#include "{{vars.prj_rel_file_name}}"
    {%- macro gen_include(type_info) -%}
    {%- if type_info.vars and type_info.vars.is_proj_type -%}
    {{marker}}#include "{{type_info.vars.prj_rel_file_name}}"
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
    {{gen_include(arg_type_info)}}
    {%- endfor -%}
    {%- endmacro -%}
    {%- for arg in args -%}
    {{gen_include(arg.type_info)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_include(return_type_info)}}
    {%- endif -%}

constructor:
  python:
    include: *var_method_python_include
    constructor_body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
        {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {% set comma = joiner(', ') %}
      @bind
      def __init__(self{{', ' if args}}{%- for arg in args -%}
                                       {%- set arg_converter = arg.converter.python %}
                                       {%- set arg_package = arg_converter.vars.file + '.' if arg_converter.is_obj_type and arg_converter.vars.target_file_fullname != vars.target_file_fullname else '' -%}
                                       {{comma()}}{{arg.name|to_snake_case}}: {{'Optional['  if arg.name in vars.nullable_arg or arg.is_null_ptr}}{{arg_package}}{{arg_converter.target_type_name}}{{']' if arg.name in vars.nullable_arg or arg.is_null_ptr}}
                                       {%- if arg.default -%}
                                       {%- if arg.is_enum %}
                                       {%- if arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields -%}
                                       {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} constructor argument. Iegen is skipping default value addition in target language wrappers.".format(arg.default.split('::')|last, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
                                       {%- else %} = {{arg_package}}{{arg_converter.target_type_name}}.{{arg.type_info.vars.enum_field_name_prefix + arg.default.split('::')|last}}
                                       {%- endif -%}
                                       {%- else -%}
                                       {%- if arg.is_literal %} = {{arg.default|capitalize if arg.is_bool else arg.default}}
                                       {%- else %} = None
                                       {%- endif %}
                                       {%- endif %}
                                       {%- endif -%}
                                       {%- endfor %}):
          {{vars.comment|make_py_docstring|to_snake_case(args|map(attribute='name'))|indent}}
          pass
  bind: *var_bind_method
  cxx:
    include: *var_method_cxx_include
    body: |
      {%- set comma = joiner(', ') %}
      {{owner_class.converter.python.get_target_type_name(definition=True)|decapitalize}}.def(py::init<{%- for arg in args -%}
                                                                                          {{comma()}}{{arg.type_info.cxx.type_name}}
                                                                                          {%- endfor -%}>(){{', ' if args}}
                                                                                          {%- set comma = joiner(', ') -%}
                                                                                          {%- for arg in args -%}
                                                                                          {{comma()}}py::arg("{{arg.name|to_snake_case}}")
                                                                                          {%- if arg.default %}{{' = ' + arg.default if not (arg.is_enum and arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields)}}
                                                                                          {%- endif -%}
                                                                                          {%- endfor -%}
                                                                                          {#- This should go to shared macro -#}
                                                                                          {%- if vars.keep_alive -%}
                                                                                          {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
                                                                                          {%- if invalid_args -%}
                                                                                          {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
                                                                                          {%- endif -%}
                                                                                            , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
                                                                                          {%- endif %});



method:
  python:
    include: *var_method_python_include
    body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
        {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname) -%}
      {%- endif -%}
      {%- set comma = joiner(', ') -%}
      {%- if cxx.is_static %}
      @classmethod
      {%- endif %}
      {%- set _name = vars.name|to_snake_case %}
      {%- set rconverter = rconverter.python %}
      @bind
      def {{_name}}({{'self' if not cxx.is_static else 'cls'}}{{', ' if args}}
                                                          {%- set rtype_package = rconverter.vars.file + '.' if rconverter.is_obj_type and rconverter.vars.target_file_fullname != vars.target_file_fullname else '' -%}
                                                          {%- for arg in args -%}
                                                          {%- set arg_converter = arg.converter.python %}
                                                          {%- set arg_package = arg_converter.vars.file + '.' if arg_converter.is_obj_type and arg_converter.vars.target_file_fullname != vars.target_file_fullname else '' -%}
                                                          {{comma()}}{{arg.name|to_snake_case}}: {{'Optional['  if arg.name in vars.nullable_arg or arg.is_null_ptr}}{{arg_package}}{{arg_converter.target_type_name}}{{']' if arg.name in vars.nullable_arg or arg.is_null_ptr}}
                                                          {%- if arg.default -%}
                                                          {%- if arg.is_enum %}
                                                          {%- if arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields -%}
                                                          {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. Iegen is skipping default value addition in target language wrappers.".format(arg.default.split('::')|last, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
                                                          {%- else %} = {{arg_package}}{{arg_converter.target_type_name}}.{{arg.type_info.vars.enum_field_name_prefix + arg.default.split('::')|last}}
                                                          {%- endif -%}
                                                          {%- else -%}
                                                          {%- if arg.is_literal %} = {{arg.default|capitalize if arg.is_bool else arg.default}}
                                                          {%- else %} = None
                                                          {%- endif %}
                                                          {%- endif %}
                                                          {%- endif -%}
                                                          {%- endfor %}) -> {{'Optional[' if vars.nullable_return}}{{rtype_package}}{{rconverter.target_type_name}}{{']' if vars.nullable_return}}:
          {{vars.comment|make_py_docstring|to_snake_case(args|map(attribute='name'))|indent}}
          pass

      {%- set setter_var_name = 'value' -%}
      {%- if vars.is_operator and vars.name == '__getitem__' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}

      @bind
      def __setitem__({{'self' if not cxx.is_static else 'cls'}}{{', ' if args}}
                                                          {%- set rtype_package = rconverter.vars.file + '.' if rconverter.is_obj_type and rconverter.vars.target_file_fullname != vars.target_file_fullname else '' -%}
                                                          {%- for arg in args -%}
                                                          {%- set arg_converter = arg.converter.python %}
                                                          {%- set arg_package = arg_converter.vars.file + '.' if arg_converter.is_obj_type and arg_converter.vars.target_file_fullname != vars.target_file_fullname else '' -%}
                                                          {{arg.name|to_snake_case}}: {{arg_package}}{{arg_converter.target_type_name}}{{comma()}}{{setter_var_name}}: {{rtype_package}}{{rconverter.target_type_name}}
                                                          {%- endfor %}):
          {{vars.comment|make_py_docstring|to_snake_case(args|map(attribute='name'))|indent}}
          pass
      {%- endif %}

  bind: *var_bind_method
  cxx:
    include: *var_method_cxx_include
    body: |
      {%- set _name = vars.name|to_snake_case -%}
      {%- set comma = joiner(', ') -%}
      {{owner_class.converter.python.get_target_type_name(definition=True)|decapitalize}}.def{{'_static' if cxx.is_static }}("{{_name}}"{%- if cxx.is_overloaded -%}
      , py::overload_cast<
      {%- for arg in args -%}
      {{comma()}}{{arg.type_info.cxx.type_name}}
      {%- endfor -%}>(&{{owner_class.cxx.type_name}}::{{cxx.name}}{{', py::const_' if cxx.is_const}})
      {%- else -%}
      , &{{owner_class.cxx.type_name}}::{{cxx.name}}
      {%- endif -%}
      {%- if cxx.is_template -%}
      <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
      {%- endif -%}
      {{', ' if args}}
      {%- set comma = joiner(', ') -%}
      {%- for arg in args -%}
      {{comma()}}py::arg("{{arg.name|to_snake_case}}")
      {%- if arg.default %}{{' = ' + arg.default if not (arg.is_enum and arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields)}}
      {%- endif -%}
      {%- endfor -%}
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive and not (vars.is_operator and vars.name == '__getitem__') -%}
      {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%- if cxx.is_static -%}
      {%- do Error.critical('Cannot apply keep alive policy for a static member function: {}.{}'.format(name, owner)) -%}
      {%- endif -%}
      {%- if invalid_args -%}
      {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
      {%- endif -%}
      , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%- endif -%}
      {%- if return_type_info.cxx.type_name != 'void' and vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
      {%- set setter_var_name = 'value' -%}
      {%- if vars.is_operator and vars.name == '__getitem__' and not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
      {{owner_class.converter.python.get_target_type_name(definition=True)|decapitalize}}.def("__setitem__", []({{owner_class.cxx.type_name}}& self,{%- for arg in args %} {{arg.type_info.cxx.type_name}} {{arg.name|to_snake_case}}{%- endfor -%}, {{return_type_info.cxx.unqualified_resolved_type_name}} {{setter_var_name}}){ self[{{args[0].name|to_snake_case}}] = {{setter_var_name}}; }
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive -%}
      {%- set args = args + [rconverter] %}
      {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%- if invalid_args -%}
      {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
      {%- endif -%}
      , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%- endif -%});
      {%- endif %}



function:
  python_init:
    include:
      unique_content: |
        {%- set template_postfix = '_' + template_type_converters|format_list("{arg.python.target_type_name}", 'arg')|join|to_snake_case|lower if cxx.is_template else '' -%}
        from .{{vars.file + vars.file_postfix}} import {{vars.name|to_snake_case}}{{overloading_prefix|replace('_', '')}}{{template_postfix}}
  python:
    include: *var_method_python_include
    body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list %}
      {%- if incorrect_nullable_args %}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.").format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname) %}
      {%- endif %}
      {%- set template_postfix = '_' + template_type_converters|format_list("{arg.python.target_type_name}", 'arg')|join|to_snake_case|lower if cxx.is_template else '' %}
      {%- set comma = joiner(', ') %}
      {% set rconverter = rconverter.python %}
      @bind
      def {{vars.name|to_snake_case}}{{overloading_prefix|replace('_', '')}}{{template_postfix}}({%- set rtype_package = rconverter.vars.file + '.' if rconverter.is_obj_type and rconverter.vars.target_file_fullname != vars.target_file_fullname else '' -%}
                                      {%- for arg in args -%}
                                      {%- set arg_converter = arg.converter.python %}
                                      {%- set arg_package = arg_converter.vars.file + '.' if arg_converter.is_obj_type and arg_converter.vars.target_file_fullname != vars.target_file_fullname else '' -%}
                                      {{comma()}}{{arg.name|to_snake_case}}: {{'Optional['  if arg.name in vars.nullable_arg or arg.is_null_ptr}}{{arg_package}}{{arg_converter.target_type_name}}{{']' if arg.name in vars.nullable_arg or arg.is_null_ptr}}
                                      {%- if arg.default -%}
                                      {%- if arg.is_enum %}
                                      {%- if arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields -%}
                                      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. Iegen is skipping default value addition in target language wrappers.".format(arg.default.split('::')|last, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
                                      {%- else %} = {{arg_package}}{{arg_converter.target_type_name}}.{{arg.type_info.vars.enum_field_name_prefix + arg.default.split('::')|last}}
                                      {%- endif -%}
                                      {%- else -%}
                                      {%- if arg.is_literal %} = {{arg.default|capitalize if arg.is_bool else arg.default}}
                                      {%- else %} = None
                                      {%- endif %}
                                      {%- endif %}
                                      {%- endif -%}
                                      {%- endfor %}) -> {{'Optional[' if vars.nullable_return}}{{rtype_package}}{{rconverter.target_type_name}}{{']' if vars.nullable_return}}:
          {{vars.comment|make_py_docstring|to_snake_case(args|map(attribute='name'))|indent}}
          pass
  bind: *var_bind_method
  hpp:
    header: *var_hpp_header
  cxx:
    include: *var_method_cxx_include
    header: *var_cxx_header
    footer: *var_cxx_footer
    body: |
      {%- set template_postfix = template_type_converters|format_list("{arg.python.target_type_name}", 'arg')|join if cxx.is_template else '' -%}
      {%- set comma = joiner(', ') %}
      m.def("{{vars.name|to_snake_case}}{{overloading_prefix|replace('_', '')}}{{'_' + template_postfix|to_snake_case|lower if template_postfix}}"{%- if cxx.is_overloaded -%}
      , py::overload_cast<
      {%- for arg in args -%}
      {{comma()}}{{arg.type_info.cxx.type_name}}
      {%- endfor -%}>(&{{cxx.namespace}}::{{cxx.name}}{{', py::const_' if cxx.is_const}})
      {%- else -%}
      , &{{cxx.namespace}}::{{cxx.name}}
      {%- endif -%}
      {%- if cxx.is_template -%}
      <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
      {%- endif -%}
      {{', ' if args}}
      {%- set comma = joiner(', ') -%}
      {%- for arg in args -%}
      {{comma()}}py::arg("{{arg.name|to_snake_case}}")
      {%- if arg.default %}{{' = ' + arg.default if not (arg.is_enum and arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields)}}
      {%- endif -%}
      {%- endfor -%}{%- if return_type_info.cxx.type_name != 'void' and vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
  pybind_module_hpp: *var_pybind_module_hpp
  pybind_module_cxx:
    body:
      unique_content: |
        {%- set template_postfix = template_type_converters|format_list("{arg.python.target_type_name}", 'arg')|join if cxx.is_template else '' -%}
        {%- set package_name = vars.package|replace('.', '_') -%}
        {{marker}}py::module_ {{package_name}} = m.def_submodule("{{vars.package}}", "{{vars.package}}");
        {{marker}}py::module_ {{package_name}}_{{vars.file}} = {{package_name}}.def_submodule("{{vars.file}}", "{{vars.file}}");
        {{marker}}bind{{[vars.package_prefix, vars.package, vars.file]|map('replace', '.', '_')|join('_')|to_camel_case(capitalize=True)}}({{package_name}}_{{vars.file}});
  pybind_package:
    body:

var_bind_getter: &var_bind_getter
  converter:
    unique_content: |
      {%- set converter = rconverter.python_to_pybind -%}
      {%- set snippet = converter.snippet('arg') -%}
      {%- if snippet -%}
      {{marker}}if type_hint == '{{rconverter.python.target_type_name}}':
          {{snippet|indent}}
          return {{converter.converted_name('arg')}}
      {%- endif -%}

var_getter_python_include: &var_getter_python_include
  unique_content: |
    {%- macro gen_import(type_info) -%}
    {%- if type_info.vars and type_info.vars.is_proj_type and type_info.vars.target_file_fullname != vars.target_file_fullname -%}
    {{marker}}import {{type_info.vars.package_prefix + '.' if type_info.vars.package_prefix}}{{type_info.vars.package}}.{{type_info.vars.file + type_info.vars.file_postfix}} as {{type_info.vars.file}}
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
    {{gen_import(arg_type_info)}}
    {%- endfor -%}
    {%- endmacro -%}
    {{gen_import(return_type_info)}}

var_getter_cxx_include: &var_getter_cxx_include
  unique_content: |
    {%- macro gen_include(type_info) -%}
    {%- if type_info.vars and type_info.vars.is_proj_type -%}
    {{marker}}#include "{{type_info.vars.prj_rel_file_name}}"
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
    {{gen_include(arg_type_info)}}
    {%- endfor -%}
    {%- endmacro -%}
    {{gen_include(return_type_info)}}

property_getter:
  python:
    include: *var_getter_python_include
    properties: |
      {%- if not cxx.is_public -%}
        {%- do Error.critical("{}.{} is not a public field. Make it public or remove iegen API.".format(owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- set _name = vars.name|to_snake_case -%}
      {%- set rconverter = rconverter.python -%}
      {% set arg_package = rconverter.vars.file + '.' if rconverter.is_obj_type and rconverter.vars.target_file_fullname != owner_class.vars.target_file_fullname else '' %}
      @property
      @bind
      def {{_name}}(self) -> {{'Optional[' if vars.nullable_return}}{{arg_package}}{{rconverter.target_type_name}}{{']' if vars.nullable_return}}:
          {{vars.comment|make_py_docstring|indent}}
          pass
      {% if vars.action == 'gen_property_setter' %}
      @{{_name}}.setter
      @bind
      def {{_name}}(self, value: {{'Optional[' if vars.nullable_return}}{{arg_package}}{{rconverter.target_type_name}}{{']' if vars.nullable_return}}):
          {{vars.comment|make_py_docstring|indent}}
          pass
      {%- endif %}
  bind: *var_bind_getter
  cxx:
    include: *var_getter_cxx_include
    body: |
      {%- set _name = vars.name|to_snake_case -%}
      {%- if vars.action == 'gen_property_setter' -%}
      {{owner_class.converter.python.get_target_type_name(definition=True)|decapitalize}}.def_readwrite("{{_name}}", &{{owner_class.cxx.type_name}}::{{cxx.name}}
      {%- if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif -%}
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive -%}
      {%- set args = [rconverter] %}
      {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%- if invalid_args -%}
      {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
      {%- endif -%}
      , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%- endif -%});
      {%- else -%}
      {{owner_class.converter.python.get_target_type_name(definition=True)|decapitalize}}.def_readonly("{{_name}}", &{{owner_class.cxx.type_name}}::{{cxx.name}}{%- if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
      {%- endif -%}

getter:
  python:
    include: *var_getter_python_include
    properties: |
      {%- do helper.validate_getter(cxx, vars, args, owner_class, setter|default(none)) -%}
      {%- do helper.validate_template_getter_setter(cxx, vars, owner_class, setter|default(none)) -%}
      {%- macro gen_name() -%}
      {%- if cxx.is_template -%}
      {%- for name in template_names or [] %}
      {%- if name != None %}{{name}}{% else %}{{template_type_converters[loop.index - 1].custom.tname}}{% endif %}
      {%- endfor %}
      {%- else %}{{vars.name}}
      {%- endif -%}
      {%- endmacro -%}
      {%- set rconverter = rconverter.python %}
      {%- set arg_package = rconverter.vars.file + '.' if rconverter.is_obj_type and rconverter.vars.target_file_fullname != vars.target_file_fullname else '' %}
      @property
      @bind
      def {{gen_name()|to_snake_case}}(self) -> {{'Optional[' if vars.nullable_return}}{{arg_package}}{{rconverter.target_type_name}}{{']' if vars.nullable_return}}:
          {{vars.comment|make_py_docstring|indent}}
          pass
      {%- if setter is defined %}
      {%- set incorrect_nullable_args = setter.vars.nullable_arg|reject('in', setter.args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
        {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), setter.owner_class.cxx.displayname, setter.cxx.displayname)) -%}
      {%- endif %}

      @{{gen_name()|to_snake_case}}.setter
      @bind
      def {{gen_name()|to_snake_case}}(self, value: {{'Optional[' if vars.nullable_return}}{{arg_package}}{{rconverter.target_type_name}}{{']' if vars.nullable_return}}):
          {{vars.comment|make_py_docstring|indent}}
          pass
      {%- endif -%}
  bind: *var_bind_getter
  cxx:
    include: *var_getter_cxx_include
    body: |
      {%- macro gen_name() -%}
      {%- if cxx.is_template -%}
      {%- for name in template_names or [] %}
      {%- if name != None %}{{name}}{% else %}{{template_type_converters[loop.index - 1].custom.tname}}{% endif %}
      {%- endfor %}
      {%- else %}{{vars.name}}
      {%- endif -%}
      {%- endmacro -%}
      {%- if cxx.is_template -%}
      {%- set template_args = '<' + template_choice.values()|format_list("{type}", 'type')|join(', ') + '>' %}
      {%- else %}
      {%- set template_args = '' %}
      {%- endif %}
      {%- if setter is defined %}
      {{owner_class.converter.python.get_target_type_name(definition=True)|decapitalize}}.def_property("{{gen_name()|to_snake_case}}", py::cpp_function(&{{owner_class.cxx.type_name}}::{{cxx.name}}{{template_args}}
      {%- if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %}), &{{owner_class.cxx.type_name}}::{{setter.cxx.name}}{{template_args}}
      {#- This should go to shared macro -#}
      {%- if vars.keep_alive -%}
      {%- set args = [rconverter] %}
      {%- set invalid_args = vars.keep_alive|select('lt', 1)|list + vars.keep_alive|select('gt', args|length)|list %}
      {%- if invalid_args -%}
      {%- do Error.critical('The following indices of keep_alive for {}.{} are out of range: {}'.format(cxx.name, owner_class.cxx.type_name, invalid_args|join(','))) -%}
      {%- endif -%}
      , {{vars.keep_alive|map('increment')|format_list('py::keep_alive<1, {}>()')|join(', ')}}
      {%- endif -%});
      {%- else %}
      {{owner_class.converter.python.get_target_type_name(definition=True)|decapitalize}}.def_property_readonly("{{gen_name()|to_snake_case}}", &{{owner_class.cxx.type_name}}::{{cxx.name}}{{template_args}}
      {%- if vars.return_value_policy %}, py::return_value_policy::{{vars.return_value_policy}}{%- endif %});
      {%- endif %}
