file:
  python:
    file_path: |
      {{[config.out_dir, config.package_prefix, package, file + config.file_postfix]|map('replace', '.', pat_sep)|path_join}}.{{config.extension}}
    scopes:
      - body
      - include
    content: |
      import {{'pybind_' + file + config.file_postfix}}
      {{helper_includes|format_list('from {} import *')|join('\n')}}
      {{include}}

      {{body}}
  cxx:
    file_path: |
      {{[config.cxx_out_dir, config.package_prefix, package, file + config.file_postfix]|map('replace', '.', pat_sep)|path_join}}.cpp
    scopes:
      - body
      - include
    content: |
      #include <pybind11/pybind11.h>
      #include <pybind11/stl.h>
      #include <pybind11/functional.h>
      #include <iostream>
      #define concat concat_pi_call
      {{include}}
      #undef concat
      namespace py = pybind11;

      PYBIND11_MODULE({{'pybind_' + file + config.file_postfix}}, m) {
          {{body|string|indent}}
      }

enum:
  python:
    body: |
      {%- set m = 'pybind_' + file + config['file_postfix']-%}
      class {{name}}({{m}}.{{name}}):
          {%- for case in enum_cases -%}
          {%- if case.comment %}
          {{case.comment|string|indent(4)}}
          {%- endif %}
          {{case.name}} = {{m}}.{{name}}.{{case.name}}
          {%- endfor %}
      {{'\n'}}
  cxx:
    body: |
      py::enum_<{{cxx_type_name}}>(m, "{{name}}")
          {%- for case in enum_cases %}
          .value("{{case.name}}", {{cxx_type_name}}::{{case.name}})
          {%- endfor %}
          .export_values();

var_class: &var_class
  python:
    include:
      unique_content: |
        {{include|format_list("from {} import *")|join('\n')}}
        {%- if is_abstract %}
        from abc import abstractmethod
        {%- endif %}
    body:
      scopes:
        - constructor_comment
        - properties
        - body
      content: |
        {%- set comma = joiner(', ') -%}
        {%- set m = 'pybind_' + file + config['file_postfix'] -%}
        class {{name}}{{template_suffix}}({%- if base_types_converters is defined -%}
                                  {% for base_type_converter in base_types_converters -%}
                                  {{comma()}}{{base_type_converter.python.target_type_name}}
                                  {%- endfor -%}
                                  {%- endif -%}
                       {{comma()}}metaclass=OriginalMethodsMetaclass):
            {{comment|string|indent}}
            {%- if not is_abstract %}
            def __new__(cls, *args, **kwargs):
                return {{m}}.{{name}}{{template_suffix}}(*args, **kwargs){{'\n'}}
            {% if constructor_comment -%}
            def __init__(self, *args, **kwargs):
                """
                The following constructors are supported:
                    {{constructor_comment|string|indent(12)}}
                """
            {% endif -%}
            {%- else %}
            @abstractmethod
            def __init__(self, *args, **kwargs):
               pass
            {% endif -%}
            {{properties|string|indent}}
            {{body|string|indent}}
        {{'\n'}}
  cxx:
    include:
      unique_content: |
        #include "{{prj_rel_file_name}}"
        {%- if template_includes %}
        {{template_includes|format_list('#include "{}"')|join('\n')}}
        {%- endif %}
        {{helper.python.get_declaration_includes(ctx, config)|format_list('#include "{}"')|join('\n')}}
    body:
      content: |
        using namespace {{ctx.namespace}};
        {%- set comma = joiner(', ') -%}
        {%- set shared_ptr = 'std::shared_ptr<' + cxx_type_name + '>' -%}
        {%- if base_types_converters is defined -%}
        {%- for base_type in base_types_converters -%}
        {%- if base_type.ctx and base_type.ctx.node.args['file']['python'] != file%}
        py::module_::import("{{'pybind_' + base_type.ctx.node.args['file']['python'] + config['file_postfix']}}").attr("{{base_type.ctx.name}}");
        {%- endif %}
        {%- endfor -%}
        {%- endif %}
        py::class_<{{cxx_type_name}} {%- if shared_ref or ancestors|any('shared_ref') -%}
                                      , std::shared_ptr<{{cxx_type_name}}>
                                     {%- endif %}
                                     {%- if base_types_converters is defined -%},
                                     {%- for base_type in base_types_converters -%}
                                     {{comma()}}{{base_type.python.original_type_name}}
                                     {%- endfor -%}
                                     {%- endif %}> {{name|lower}}{{template_suffix|capitalize}}(m, "{{name}}{{template_suffix}}"{{', py::is_final()' if not is_open}});

class: *var_class

interface: *var_class

constructor:
  python:
    constructor_comment: |
      {{owner_class.name}}{{owner_class.template_suffix}}({{args|format_list("{arg.name}: {arg.converter.python.target_type_name}", 'arg')|join(', ')}})
  cxx:
    body: |
      {%- set comma = joiner(', ') -%}
      {{owner_class.name|lower}}{{owner_class.template_suffix|capitalize}}.def(py::init<{%- for arg in args -%}
                                                                                   {{comma()}}{{arg.converter.python.original_type_name}}
                                                                                   {%- endfor -%}>(){{', ' if args}}{{args|format_list('py::arg("{arg.name}")', 'arg')|join(', ')}});


function:
  python:
    body: |
      {%- macro func() -%}
      {%- if is_static -%}
      @staticmethod
      {% endif -%}
      {%- if is_operator -%}
      {%- set _name = helper.python.get_operator_name(name) -%}
      {%- else -%}
      {%- set _name = name -%}
      {%- endif -%}
      def {{_name}}{{overloading_prefix if not ctx.node.is_template}}({{'self' if not is_static}}{{', ' if args and not is_static}}{{args|format_list("{arg.name}", 'arg')|join(', ')}}):
          {{comment|string|indent}}
          return {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{_name}}{{overloading_prefix if not ctx.node.is_template}}']{%- if is_static -%}.__get__('{{_name}}'){%- endif -%}({{'self' if not is_static}}{{', ' if args and not is_static}}{{args|format_list("{arg.name}", 'arg')|join(', ')}})
      {%- endmacro -%}
      {%- if ctx.node.is_function_template -%}
      {%- if template_choice == ctx.template_choice %}
      {{func()}}
      {%- endif -%}
      {%- else %}
      {{func()}}
      {%- endif -%}
  cxx:
    body: |
      {%- if is_operator %}
      {%- set _name = helper.python.get_operator_name(name) -%}
      {%- else -%}
      {%- set _name = name -%}
      {%- endif %}
      {%- set comma = joiner(', ') -%}
      {{owner_class.name|lower}}{{owner_class.template_suffix|capitalize}}.def{{'_static' if is_static }}("{{_name}}{{overloading_prefix if not ctx.node.is_template}}"{%- if helper.python.is_overloaded_cursor(ctx) -%}
      , py::overload_cast<
      {%- for arg in args -%}
      {{comma()}}{%- if arg.converter.ctx -%}
      {{arg.converter.python.original_type_name}}
      {%- else -%}
      {{arg.type.spelling}}
      {%- endif -%}
      {%- endfor -%}>(&{{owner_class.cxx_type_name}}::{{cxx_name}}{{', py::const_' if ctx.cursor.is_const_method()}})
      {%- else -%}
      , &{{owner_class.cxx_type_name}}::{{cxx_name}}
      {%- endif -%}
      {%- if ctx.node.is_function_template -%}
      <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
      {%- endif -%}
      {{', ' if args}}{{args|format_list('py::arg("{arg.name}")', 'arg')|join(', ')}});

property_getter:
  python:
    properties: |
      @property
      def {{name}}(self):
          {{comment|string|indent}}
          return {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{name}}'].fget(self)
      {% if gen_property_setter %}
      @{{name}}.setter
      def {{name}}(self, value):
          {{comment|string|indent}}
          {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{name}}'].fset(self, value)
      {%- endif %}
  cxx:
    body: |
      {%- if gen_property_setter %}
      {{owner_class.name|lower}}{{owner_class.template_suffix|capitalize}}.def_readwrite("{{name}}", &{{owner_class.cxx_type_name}}::{{cxx_name}});
      {%- else %}
      {{owner_class.name|lower}}{{owner_class.template_suffix|capitalize}}.def_readonly("{{name}}", &{{owner_class.cxx_type_name}}::{{cxx_name}});
      {%- endif %}

getter:
  python:
    properties: |
      @property
      def {{name}}{{overloading_prefix if ctx.node.is_function_template}}(self):
          {{comment|string|indent}}
          return {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{name}}{{overloading_prefix if ctx.node.is_function_template}}'].fget(self)

      {% if setter_ctx is defined %}
      @{{name}}{{overloading_prefix if ctx.node.is_function_template}}.setter
      def {{name}}{{overloading_prefix if ctx.node.is_function_template}}(self, value):
          {{comment|string|indent}}
          {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{name}}{{overloading_prefix if ctx.node.is_function_template}}'].fset(self, value)
      {%- endif %}
  cxx:
    body: |
      {% if setter_ctx is defined %}
      {% set arg = setter_ctx.args[0] %}
      {{owner_class.name|lower}}{{owner_class.template_suffix|capitalize}}.def_property("{{name}}{{overloading_prefix if ctx.node.is_function_template}}", &{{owner_class.cxx_type_name}}::{{cxx_name}}
                                                    {%- if ctx.node.is_function_template -%}
                                                    <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                                    {%- endif -%},
                                                    {%- if helper.python.is_overloaded_cursor(setter_ctx['ctx']) %} py::overload_cast<
                                                    {%- if arg.converter.ctx -%}
                                                    {{arg.converter.python.original_type_name}}
                                                    {%- else -%}
                                                    {{arg.type.spelling}}
                                                    {%- endif -%}>(&{{owner_class.cxx_type_name}}::{{setter_ctx.cxx_name}})
                                                    {%- else %} &{{owner_class.cxx_type_name}}::{{setter_ctx.cxx_name}}
                                                    {%- endif -%}
                                                    {%- if ctx.node.is_function_template -%}
                                                    <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                                    {%- endif -%});
      {%- else %}
      {{owner_class.name|lower}}{{owner_class.template_suffix|capitalize}}.def_property_readonly("{{name}}{{overloading_prefix if ctx.node.is_function_template}}", &{{owner_class.cxx_type_name}}::{{cxx_name}}{%- if ctx.node.is_function_template -%}
                                                                                                                                                          <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                                                                                                                                          {%- endif -%});
      {%- endif %}
