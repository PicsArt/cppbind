file:
  python:
    file_path: |
      {{[config.out_dir, config.package_prefix, package, file]|map('replace', '.', pat_sep)|path_join}}.{{config.extension}}
    scopes:
      - body
      - include
    content: |
      import {{'pybind_' + file}}
      {{helper_includes|format_list('from {} import *')|join('\n')}}
      {{include}}


      {{body}}
  cxx:
    file_path: |
      {{[config.cxx_out_dir, config.package_prefix, package, file]|map('replace', '.', pat_sep)|path_join}}.cpp
    scopes:
      - body
      - include
    content: |
      #include <pybind11/pybind11.h>
      #include <pybind11/stl.h>
      #include <iostream>
      {{include}}

      namespace py = pybind11;

      PYBIND11_MODULE({{'pybind_' + file}}, m) {
          {{body|string|indent}}
      }

enum:
  python:
    body: |
      {%- set m = 'pybind_' + file -%}
      class {{name}}({{m}}.{{name}}):
        {%- for case in enum_cases -%}
        {%- if case.comment %}
        {{case.comment|string|indent(2)}}
        {%- endif %}
        {{case.name}} = {{m}}.{{name}}.{{case.name}}
        {%- endfor %}
      {{'\n'}}
  cxx:
    body: |
      py::enum_<{{cxx_type_name}}>(m, "{{name}}")
          {%- for case in enum_cases %}
          .value("{{case.name}}", {{cxx_type_name}}::{{case.name}})
          {%- endfor %}
          .export_values();

var_class: &var_class
  python:
    include:
      unique_content: |
        {{include|format_list("from {} import *")|join('\n')}}
    body:
      scopes:
        - head
        - properties
        - body
      content: |
        {%- set comma = joiner(', ') -%}
        {%- set m = 'pybind_' + file -%}
        class {{name}}{{template_suffix}}({%- if base_types_converters is defined -%}
                                  {% for base_type_converter in base_types_converters -%}
                                  {{comma()}}{{base_type_converter.python.target_type_name}}
                                  {%- endfor -%}
                                  {%- endif -%}
                       {{comma()}}metaclass=OriginalMethodsMetaclass):
            {{comment|string|indent}}
            def __new__(cls, *args, **kwargs):
                return {{m}}.{{name}}{{template_suffix}}(*args, **kwargs){{'\n'}}
            {%- set constructor_comments = helper.python.get_constructors_comment(ctx.cursor) -%}
            {%- if constructor_comments %}
            def __init__(self, *args, **kwargs):
                {{helper.python.make_comment(constructor_comments)|indent(8)}}
                pass
            {%- endif %}
            {{head|string|indent}}
            {{properties|string|indent}}
            {{body|string|indent}}
        {{'\n'}}
  cxx:
    include:
      unique_content: |
        #include "{{prj_rel_file_name}}"
        {%- if template_includes %}
        {{template_includes|format_list('#include "{}"')|join('\n')}}
        {%- endif %}
        {{helper.python.get_declaration_includes(ctx, config)|format_list('#include "{}"')|join('\n')}}
    body:
      content: |
        {%- set comma = joiner(', ') -%}
        {%- set shared_ptr = 'std::shared_ptr<' + cxx_type_name + '>' -%}
        {%- set base_types = ctx.base_types -%}
        {%- if base_types -%}
        {%- for base_type in base_types %}
        {%- set base_type_ctx = ctx.find_by_type(base_type) -%}
        {%- if base_type_ctx  and base_type_ctx.node.args['file']['python'] != file%}
        py::module_::import("{{'pybind_' + base_type_ctx.node.args['file']['python']}}").attr("{{base_type_ctx.name}}");
        {%- endif %}
        {%- endfor -%}
        {%- endif %}
        py::class_<{{cxx_type_name}} {%- if shared_ref or ancestors|any('shared_ref') -%}
                                      , std::shared_ptr<{{cxx_type_name}}>
                                     {%- endif %}
                                     {%- if base_types -%},
                                     {%- for base_type in base_types -%}
                                     {{comma()}}{{base_type.get_canonical().spelling}}
                                     {%- endfor -%}
                                     {%- endif %}> {{name|lower}}(m, "{{name}}{{template_suffix}}"{{', py::is_final()' if not is_open}});

class: *var_class

interface: *var_class

constructor:
  cxx:
    body: |
      {{owner_class.name|lower}}.def(py::init<{{args|format_list("{arg.spelling}", 'arg')|join(', ')}}>(){{', ' if args}}{{args|format_list('py::arg("{arg.name}")', 'arg')|join(', ')}});


function:
  python:
    body: |
      {%- if is_static %}
      @staticmethod
      {%- endif -%}
      {%- if is_operator %}
      {%- set _name = helper.python.get_operator_name(name) -%}
      {%- else -%}
      {%- set _name = name -%}
      {%- endif %}
      def {{_name}}({{'self' if not is_static}}{{', ' if args and not is_static}}{{args|format_list("{arg.name}", 'arg')|join(', ')}}):
          {{comment|string|indent}}
          return {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{_name}}']{%- if is_static -%}.__get__('{{_name}}'){%- endif -%}({{'self' if not is_static}}{{', ' if args and not is_static}}{{args|format_list("{arg.name}", 'arg')|join(', ')}})
  cxx:
    body: |
      {%- if is_operator %}
      {%- set _name = helper.python.get_operator_name(name) -%}
      {%- else -%}
      {%- set _name = name -%}
      {%- endif %}
      {%- set comma = joiner(', ') -%}
      {{owner_class.name|lower}}.def{{'_static' if is_static }}("{{_name}}"{%- if helper.python.get_overload_cursors(ctx) -%}
      , py::overload_cast<
      {%- for arg in args -%}
      {{arg.type.get_canonical().spelling}}{{comma()}}
      {%- endfor -%}>(&{{owner_class.cxx_type_name}}::{{cxx_name}}{{', py::const_' if ctx.cursor.is_const_method()}})
      {%- else -%}
      , &{{owner_class.cxx_type_name}}::{{cxx_name}}
      {%- endif -%}
      {%- if ctx.node.is_function_template -%}
      <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
      {%- endif -%}
      {{', ' if args}}{{args|format_list('py::arg("{arg.name}")', 'arg')|join(', ')}});

property_getter:
  python:
    properties: |
      @property
      def {{name}}(self):
          {{comment|string|indent}}
          return {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{name}}'].fget(self)
      {%- if gen_property_setter %}
      @{{name}}.setter
      def {{name}}(self, value):
          {{comment|string|indent}}
          {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{name}}'].fset(self, value)
      {%- endif %}
  cxx:
    body: |
      {%- if gen_property_setter %}
      {{owner_class.name|lower}}.def_readwrite("{{name}}", &{{owner_class.cxx_type_name}}::{{cxx_name}});
      {%- else %}
      {{owner_class.name|lower}}.def_readonly("{{name}}", &{{owner_class.cxx_type_name}}::{{cxx_name}});
      {%- endif %}

getter:
  python:
    properties: |
      @property
      def {{name}}(self):
          {{comment|string|indent}}
          return {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{name}}'].fget(self)
      {% if setter_ctx is defined %}
      @{{name}}.setter
      def {{name}}(self, value):
          {{comment|string|indent}}
          {{owner_class.name}}{{owner_class.template_suffix}}.originals['{{name}}'].fset(self, value)
      {%- endif %}
  cxx:
    body: |
      {% if setter_ctx is defined %}
      {{owner_class.name|lower}}.def_property("{{name}}", &{{owner_class.cxx_type_name}}::{{cxx_name}}, &{{owner_class.cxx_type_name}}::{{setter_ctx.cxx_name}});
      {%- else %}
      {{owner_class.name|lower}}.def_property_readonly("{{name}}", &{{owner_class.cxx_type_name}}::{{cxx_name}});
      {%- endif %}
