file:
  swift:
    file_path: |
      {{vars.target_file_fullname}}
    scopes:
      - include
      - body
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      {{[include, 'import Foundation', 'import ' + vars.c_wrapper_lib_name]|sort_snippets(cmp=helper.imports_comparator)|join(new_line)}}

      {{body}}
  cc:
    file_path: |
      {{vars.c_file_fullname}}
    scopes:
      - namespace
      - body
      - include
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #include <iostream>
      #include <stdlib.h>
      #include <string.h>
      #include <cxxabi.h>
      #include <memory>
      #include <type_traits>
      #include "{{path.relpath(vars.h_file_fullname, vars.out_prj_dir)}}"
      {{include}}
      {{namespace}}

      {{body}}{{new_line}}
  ch:
    file_path: |
      {{vars.h_file_fullname}}
    scopes:
      - body
      - include
    content: |
      {{[banner_logo, vars.banner_comment]|make_doxygen_comment}}

      #ifndef _C_{{vars.file}}_WRAPPER_
      #define _C_{{vars.file}}_WRAPPER_

      {{cxx_helper_includes|format_list('#include "{}"')|join(new_line)}}
      {{include}}
      #include <stdbool.h>

      #if __cplusplus
      extern "C" {
      #endif
          {{body | string | indent}}
      #if __cplusplus
      }
      #endif
      #endif /* ifndef _C_{{vars.file}}_WRAPPER_ */{{new_line}}

package:

enum:
  swift:
    body: |
      {%- if vars.header_code_fragment -%}
      {{vars.header_code_fragment}}{{new_line}}
      {% endif -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      public enum {{vars.name}}: CUnsignedInt{{', ' if vars.bases_list}}{{vars.bases_list|join(', ')}} {
        {%- for case in enum_cases -%}
        {%- if case.name not in vars.enum_excluded_fields -%}
        {%- if case.comment %}
        {{case.comment|make_doxygen_comment|indent(2)}}
        {%- endif %}
        case {{vars.enum_field_name_prefix + case.name}} = {{case.value}}
        {%- endif %}
        {%- endfor %}
        {%- if vars.code_fragment %}

        {{vars.code_fragment|indent(2)}}
        {%- endif %}
      }
      {%- if vars.footer_code_fragment -%}
      {{new_line}}{{vars.footer_code_fragment}}
      {%- endif %}{{new_line}}

var_class_cxx_include: &var_class_cxx_include
    unique_content: |
      {%- if vars.is_proj_type -%}
      #include "{{vars.prj_rel_file_name}}"
      {%- endif -%}
      {%- macro gen_include(type_info) -%}
      {%- if type_info.vars and type_info.vars.is_proj_type -%}
      {{marker}}#include "{{type_info.vars.prj_rel_file_name}}"
      {%- endif -%}
      {%- for arg_type_info in type_info.arg_types_infos -%}
      {{gen_include(arg_type_info)}}
      {%- endfor -%}
      {%- endmacro -%}
      {%- for base in base_types_infos -%}
      {{gen_include(base)}}
      {%- endfor -%}
      {%- if vars.include_cxx -%}
      {{marker}}{{vars.include_cxx|select('match_regexp', '^<.*>$', '^".*"$')|format_list('#include {}')|join_unique}}
      {{marker}}{{vars.include_cxx|reject('match_regexp', '^<.*>$', '^".*"$')|format_list('#include "{}"')|join_unique}}
      {%- endif -%}

class:
  swift:
    include:
      unique_content: |
        {{marker if vars.include}}{{vars.include|format_list("import {}")|join_unique}}
    body:
      scopes:
        - head
        - properties
        - body
        - private_external
      content: |
        {%- if vars.header_code_fragment -%}
        {{vars.header_code_fragment}}{{new_line}}
        {% endif -%}
        {%- set base_interfaces = base_types_converters|map(attribute='swift')|selectattr('vars.action', 'equalto', 'gen_interface')|map(attribute='target_type_name')|list -%}
        {%- set base_classes = base_types_converters|map(attribute='swift')|rejectattr('vars.action', 'equalto', 'gen_interface')|map(attribute='target_type_name')|list -%}
        {%- set bases_specifiers =  base_classes + base_interfaces + vars.bases_list -%}
        {%- if vars.comment -%}
        {{vars.comment|make_doxygen_comment}}
        {% endif -%}
        public class {{converter.swift.get_target_type_name(definition=True)}}{{': ' + bases_specifiers|join(', ') if bases_specifiers}}
                                {%- if vars.is_exception and not ancestors|selectattr('vars.is_exception', 'equalto', True)|list -%}
                                {{', ' if bases_specifiers else ' : Error'}}
                                {%- endif %} {
          {%- if not base_types_infos|rejectattr('vars.action', 'equalto', 'gen_interface')|list %}

          public let cself: {{converter.sc.target_type_name}}
          public let owner: Bool

          // internal main initializer
          internal required init(_ _cself: {{converter.sc.target_type_name}}, _ _owner: Bool = false) {
            self.cself = _cself
            self.owner = _owner
          }

          deinit {
            release_{{converter.swift.target_type_name|replace('.',  '_')}}(cself, owner)
          }{{new_line}}
          {%- endif %}
          {%- if head %}
          {{head|string|indent(2)}}
          {%- endif %}
          {%- if properties %}
          {{properties|string|indent(2)}}
          {%- endif %}
          {%- if body %}
          {{body|string|indent(2)}}
          {%- endif %}
        }
        {%- if vars.footer_code_fragment %}
        {{new_line}}{{vars.footer_code_fragment}}
        {%- endif %}{{new_line}}
  cc:
    include: *var_class_cxx_include
    namespace:
      unique_content: |
        {%- if cxx.namespace %}
        using namespace {{cxx.namespace}};
        {%- endif %}
    body:
      content: |
        {%- if not base_types_infos|rejectattr('vars.action', 'equalto', 'gen_interface')|list -%}
        void release_{{converter.swift.target_type_name|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner) {
            {%- if (vars.descendants if vars.descendants is not none else descendants) %}
            static_assert(std::has_virtual_destructor<{{cxx.unqualified_resolved_type_name}}>::value, {{'"{} type must have virtual destructor"'.format(cxx.unqualified_resolved_type_name)}});
            {%- endif %}
            free(cself.type);
            if (owner) {
                {%- if root.vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(cself.ptr);
                {%- else %}
                delete static_cast<{{cxx.unqualified_resolved_type_name}}*>(cself.ptr);
                {%- endif %}
            }
        }
        {%- endif -%}
  ch:
    body:
      content: |
        {%- if not base_types_infos|rejectattr('vars.action', 'equalto', 'gen_interface')|list -%}
        void release_{{converter.swift.target_type_name|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner);
        {%- endif -%}


interface:
  swift:
    include:
      unique_content: |
        {{vars.include|format_list("import {}")|join_unique}}
    body:
      scopes:
        - interface_head
        - interface_properties
        - interface_body
        - head
        - properties
        - body
      content: |
        {%- if vars.header_code_fragment -%}
        {{vars.header_code_fragment}}{{new_line}}
        {% endif -%}
        {%- set bases_specifiers = base_types_converters|map(attribute='swift.target_type_name')|list + vars.bases_list -%}
        {%- if vars.comment -%}
        {{vars.comment|make_doxygen_comment}}
        {% endif -%}
        public protocol {{converter.swift.get_target_type_name(definition=True)}}{{': ' + bases_specifiers|join(', ') if bases_specifiers}} {

          {%- if not base_types_converters %}
          var cself: {{converter.sc.target_type_name}} { get }{{new_line}}
          {%- endif %}
          {%- if interface_head %}
          {{interface_head|string|indent(2)}}
          {%- endif %}
          {%- if interface_properties %}
          {{interface_properties|string|indent(2)}}
          {%- endif %}
          {%- if interface_body %}
          {{interface_body|string|indent(2)}}
          {%- endif %}
        }

        extension {{converter.swift.get_target_type_name(definition=True)}} {
          {%- if properties %}
          {{properties|string|indent(2)}}
          {%- endif %}
          {%- if body %}
          {{body|string|indent(2)}}
          {%- endif %}
        }

        public class {{converter.swift.get_target_type_name(interface_class=True, definition=True)}}: {{converter.swift.target_type_name}} {
          public let cself: {{converter.sc.target_type_name}}
          public let owner: Bool

          // internal main initializer
          internal required init(_ _cself: {{converter.sc.target_type_name}}, _ _owner: Bool = false) {
            self.cself = _cself
            self.owner = _owner
          }

          deinit {
            release_{{converter.swift.get_target_type_name(interface_class=True)|replace('.',  '_')}}(cself, owner)
          }{{new_line}}
          {%- if head %}
          {{head|string|indent(2)}}
          {%- endif %}
        }
        {%- if vars.footer_code_fragment %}
        {{new_line}}{{vars.footer_code_fragment}}
        {%- endif %}{{new_line}}
  cc:
    include: *var_class_cxx_include
    namespace:
      unique_content: |
        {%- if cxx.namespace %}
        using namespace {{cxx.namespace}};
        {%- endif %}
    body:
      content: |
        void release_{{converter.swift.get_target_type_name(interface_class=True)|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner){
            {%- if (vars.descendants if vars.descendants is not none else descendants) %}
            static_assert(std::has_virtual_destructor<{{cxx.unqualified_resolved_type_name}}>::value, {{'"{} type must have virtual destructor"'.format(cxx.unqualified_resolved_type_name)}});
            {%- endif %}
            free(cself.type);
            if (owner) {
                {%- if root.vars.shared_ref %}
                delete static_cast<std::shared_ptr<{{cxx.unqualified_resolved_type_name}}>*>(cself.ptr);
                {%- else %}
                delete static_cast<{{cxx.unqualified_resolved_type_name}}*>(cself.ptr);
                {%- endif %}
            }
        }
  ch:
    body:
      content: |
        void release_{{converter.swift.get_target_type_name(interface_class=True)|replace('.',  '_')}}({{converter.c.target_type_name}} cself, bool owner);

var_method_cxx_include: &var_method_cxx_include
  unique_content: |
    {%- if vars.is_proj_type -%}
    #include "{{vars.prj_rel_file_name}}"
    {%- endif -%}
    {%- macro gen_include(type_info, gen_desc_incl=true) -%}
    {%- if type_info.vars and type_info.vars.is_proj_type -%}
    {{marker}}#include "{{type_info.vars.prj_rel_file_name}}"
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
    {{gen_include(arg_type_info, gen_desc_incl)}}
    {%- endfor -%}
    {#- `is defined` check is done for enum types (enums don't have descendants) -#}
    {%- if gen_desc_incl and type_info.vars and type_info.vars.descendants is defined and type_info.descendants is defined -%}
    {%- for descendant in (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) -%}
    {#- generate includes for descendants list of an argument -#}
    {{gen_include(get_type_info(descendant))}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {%- for arg in args -%}
    {{gen_include(arg.type_info)}}
    {%- endfor -%}
    {%- if rconverter is defined -%}
    {{gen_include(return_type_info, gen_desc_incl=false)}}
    {%- endif -%}
    {#- generate includes for descendants list of `this` if the node is method -#}
    {%- if owner_class -%}
    {{gen_include(owner_class)}}
    {%- endif -%}

constructor:
  swift:
    head: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      {%- set comma = joiner(', ') -%}
      public convenience init(
      {%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}
      {%- if arg.default -%}
      {%- if arg.is_enum %}
      {%- if arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields -%}
      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} constructor argument. Iegen is skipping default value addition in target language wrappers.".format(arg.default.split('::')|last, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- else %} = {{arg.converter.swift.target_type_name}}.{{arg.type_info.vars.enum_field_name_prefix + arg.default.split('::')|last}}
      {%- endif -%}
      {%- else -%}
      {%- if arg.is_literal %} = {{arg.default}}
      {%- elif arg.is_null_ptr %} = nil
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}{
        {%- set call_args = [] %}
        {%- for arg in args %}
        {%- set converter = arg.converter.swift_to_sc %}
        {%- set conversion = converter.snippet(arg.name|to_camel_case, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) %}
        {%- if conversion %}
        {{conversion|indent(2)}}
        {%- endif %}
        {%- do call_args.append(converter.converted_name(arg.name|to_camel_case)) %}
        {%- endfor %}
        var err = IEGenCObject()
        self.init(create_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}{{overloading_prefix}}({{call_args|join(', ')}}{{', ' if call_args}}&err), true)
        {%- for arg in args %}
        {%- if arg.converter.sc_cleanup %}
        {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg.name|to_camel_case)) %}
        {%- if cleanup_code_fragment %}
        {{cleanup_code_fragment|indent(2)}}
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        if err.type != nil {
          let errorType = String(cString: err.type!)
          switch errorType {
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws %}
          case ("{{exc_type}}"):
            {%- set exc_info = get_type_info(exc_type) %}
            throw {{exc_info.vars.name}}(err, true)
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          case ("std::exception"):
            {%- set exc_info = get_type_info("std::exception") %}
            let excObj = {{exc_info.vars.name}}(err, true)
            ExceptionHandler.handleUncaughtException(excObj.what())
          {%- endif %}
          default:
            err.type.deallocate()
            ExceptionHandler.handleUncaughtException("Uncaught Exception")
          }
        }
      }{{new_line}}
  cc:
    include: *var_method_cxx_include
    body: |
      {%- set comma = joiner(', ') %}
      {{owner_class.converter.c.target_type_name}} create_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}{{overloading_prefix}}({%- for arg in args -%}{{comma()}}{{arg.converter.c.target_type_name}}
      {%- if arg.converter.c.custom.is_c_pointer_type %} {{'_Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else '_Nonnull'}}{% endif %} {{arg.name}}{%- endfor-%}{{', ' if args}}IEGenCObject* _Nonnull err){
        {%- set call_args = [] -%}
        {%- for arg in args -%}
        {% set converter = arg.converter.c_to_cxx %}
          {{converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr)|indent}}
        {%- do call_args.append(converter.converted_name(arg.name)) -%}
        {% endfor %}
          try {
              auto this_object = new {{owner_class.cxx.type_name}}({{call_args|join(', ')}});
              {%- if owner_class.root.vars.shared_ref %}
              return {strdup("{{owner_class.cxx.unqualified_canonical_type_name}}"), new std::shared_ptr<{{owner_class.cxx.type_name}}>(this_object)};
              {%- else %}
              return {strdup("{{owner_class.cxx.unqualified_canonical_type_name}}"), this_object};
              {%- endif %}
          }
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws -%}
          catch (const {{exc_type}}& e) {
              err->type = strdup("{{exc_type}}");
              err->ptr = new {{exc_type}}(e);
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          catch (const std::exception& e) {
              err->type = strdup("std::exception");
              err->ptr = new std::exception(e);
          }
          {%- endif %}
          catch (...) {
              err->type = strdup("Uncaught Exception");
          }
          {{owner_class.converter.c.target_type_name}} result {};
          return result;
      }
  ch:
    body:
      content: |
        {%- set comma = joiner(', ') %}
        {{owner_class.converter.c.target_type_name}} create_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}{{overloading_prefix}}({%- for arg in args -%}{{comma()}}{{arg.converter.c.target_type_name}}
        {%- if arg.converter.c.custom.is_c_pointer_type %} {{'_Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else '_Nonnull'}}{% endif %} {{arg.name}}{%- endfor-%}{{', ' if args}}IEGenCObject* _Nonnull err);

method:
  swift:
    body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      {%- set comma = joiner(', ') -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- if vars.is_operator and vars.name == '[]' -%}
      {# subscript operator #}
      public subscript({%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{arg.converter.swift.target_type_name}}
                       {%- endfor-%}) -> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
        get {
          {%- set call_args = ['cself'] %}
          {%- for arg in args %}
          {%- set converter = arg.converter.swift_to_sc %}
          {%- set conversion = converter.snippet(arg.name|to_camel_case, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg.name|to_camel_case)) %}
          {%- endfor %}
          let result = {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_getitem_'), overloading_prefix)}}({{call_args|join(', ')}})
          {%- set conversion = rconverter.sc_to_swift.snippet('result', nullable=vars.nullable_return) %}
          {%- if conversion %}
          {{conversion|indent(2)}}
          {%- endif %}
          {%- for arg in args %}
          {%- if arg.converter.sc_cleanup %}
          {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg.name|to_camel_case)) %}
          {%- if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(4)}}
          {%- endif %}
          {%- endif %}
          {%- endfor %}
          return {{rconverter.sc_to_swift.converted_name('result')}}
        }
        {%- if not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
        {%- set res_converter = rconverter.swift_to_sc %}

        set(value) {
          {%- set call_args = ['cself'] %}
          {%- for arg in args %}
          {%- set converter = arg.converter.swift_to_sc %}
          {%- set conversion = converter.snippet(arg.name|to_camel_case, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          {%- do call_args.append(converter.converted_name(arg.name|to_camel_case)) %}
          {%- endfor %}
          {%- set conversion = res_converter.snippet('value', nullable=vars.nullable_return) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          {%- do call_args.append(res_converter.converted_name('value')) %}
          {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_setitem_'), overloading_prefix)}}({{call_args|join(', ')}})
          {%- for arg in args %}
          {%- if arg.converter.sc_cleanup %}
          {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg.name|to_camel_case)) %}
          {%- if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(4)}}
          {%- endif %}
          {%- endif %}
          {%- endfor %}
          {%- if rconverter.sc_cleanup %}
          {%- set cleanup_code_fragment = rconverter.sc_cleanup.snippet(res_converter.converted_name('value')) %}
          {%- if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(4)}}
          {%- endif %}
          {%- endif %}
        }
        {%- endif %}
      }
      {%- else -%}
      {%- if vars.is_operator -%}
      public static func {{vars.name}}(cself: {{owner_class.vars.name}}{{', ' if args}}{%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}{%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
      {%- set call_args = ['cself.cself'] -%}
      {%- else -%}
      {%- set override = cxx.is_override and not is_interface_override -%}
      public {{"static " if cxx.is_static}}{{"override " if override}}func {{vars.name}}(
      {%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}
      {%- if arg.default -%}
      {%- if arg.is_enum %}
      {%- if arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields -%}
      {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {}.{} method argument. Iegen is skipping default value addition in target language wrappers.".format(arg.default.split('::')|last, arg.default.split('::')[-2], owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- else %} = {{arg.converter.swift.target_type_name}}.{{arg.type_info.vars.enum_field_name_prefix + arg.default.split('::')|last}}
      {%- endif -%}
      {%- else -%}
      {%- if arg.is_literal %} = {{arg.default}}
      {%- elif arg.is_null_ptr %} = nil
      {%- endif %}
      {%- endif %}
      {%- endif -%}
      {%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
      {%- set call_args = ['cself'] if not cxx.is_static else [] %}
      {%endif%}
        {%- for arg in args %}
        {%- set converter = arg.converter.swift_to_sc %}
        {%- set conversion = converter.snippet(arg.name|to_camel_case, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) %}
        {%- if conversion %}
        {{conversion|indent(2)}}
        {%- endif %}
        {%- do call_args.append(converter.converted_name(arg.name|to_camel_case))%}
        {%- endfor %}
        var err = IEGenCObject()
        {%- if rconverter.c.target_type_name != 'void' %}
        let result = {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name, overloading_prefix + template_postfix)}}({{call_args|join(', ')}}{{', ' if call_args}}&err)
        {%- else %}
        {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name, overloading_prefix + template_postfix)}}({{call_args|join(', ')}}{{', ' if call_args}}&err)
        {%- endif %}
        {%- for arg in args %}
        {%- if arg.converter.sc_cleanup %}
        {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg.name|to_camel_case)) %}
        {%- if cleanup_code_fragment %}
        {{cleanup_code_fragment|indent(2)}}
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        if err.type != nil {
          let errorType = String(cString: err.type!)
          switch errorType {
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws %}
          case ("{{exc_type}}"):
            {%- set exc_info = get_type_info(exc_type) %}
            throw {{exc_info.vars.name}}(err, true)
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          case ("std::exception"):
            {%- set exc_info = get_type_info("std::exception") %}
            let excObj = {{exc_info.vars.name}}(err, true)
            ExceptionHandler.handleUncaughtException(excObj.what())
          {%- endif %}
          default:
            err.type.deallocate()
            ExceptionHandler.handleUncaughtException("Uncaught Exception")
          }
        }
        {%- if rconverter.c.target_type_name != 'void' %}
        {%- set conversion = rconverter.sc_to_swift.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
        {%- if conversion %}
        {{conversion|indent(2)}}
        {%- endif %}
        return {{rconverter.sc_to_swift.converted_name('result')}}
        {%- endif %}
      }
      {%- endif %}{{new_line}}
    interface_body: |
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif %}
      {%- set comma = joiner(', ') -%}
      {%- if vars.is_operator and vars.name == '[]' -%}
      subscript({%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{arg.converter.swift.target_type_name}}{% endfor %}) -> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} { get {{'set ' if not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference}}}
      {%- else -%}
      func {{vars.name}}({%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}{%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}}
      {%- endif %}
  cc:
    include: *var_method_cxx_include
    body: |
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set comma = joiner(', ') %}
      {%- set is_subscript_operator = vars.is_operator and vars.name == '[]' %}
      {%- if not is_subscript_operator %}
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name, overloading_prefix + template_postfix)}}(
      {%- if not cxx.is_static -%}
      {{owner_class.converter.c.target_type_name}} cself, {% endif -%}
      {%- for arg in args -%}{{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else ' _Nonnull'}}{% endif %} {{arg.name}}{%- endfor-%}{{', ' if args}}IEGenCObject* _Nonnull err){
        {%- set call_args = [] %}
        {%- for arg in args -%}
        {%- set converter = arg.converter.c_to_cxx %}
          {{converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr)|indent}}
        {%- do call_args.append(converter.converted_name(arg.name))%}
        {% endfor %}
        {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.root.vars.shared_ref else owner_class.converter.c_to_cxx -%}
        {%- if not cxx.is_static %}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
        {%- endif %}

        {%- if rconverter.c.target_type_name != 'void' %}
          try {
              const auto& result = {%if not cxx.is_static %}{{this_converter.converted_name('cself')}}->
                                   {%- else%}{{owner_class.cxx.type_name}}::{% endif %}{{cxx.name}}
                                   {%- if cxx.is_template -%}
                                   <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>{%- endif -%}({{call_args|join(', ')}});
              {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
              return {{rconverter.cxx_to_c.converted_name('result')}};
          }
        {%- else %}
          try {
              {%if not cxx.is_static %}{{this_converter.converted_name('cself')}}->{%else%}{{owner_class.cxx.type_name}}::{% endif %}{{cxx.name}}({{call_args|join(', ')}});
          }
        {%- endif %}
        {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws -%}
          catch (const {{exc_type}}& e) {
              err->type = strdup("{{exc_type}}");
              err->ptr = new {{exc_type}}(e);
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          catch (const std::exception& e) {
              err->type = strdup("std::exception");
              err->ptr = new std::exception(e);
          }
          {%- endif %}
          catch (...) {
              err->type = strdup("Uncaught Exception");
          }

          {%- if rconverter.c.target_type_name != 'void' %}
          {{rconverter.c.target_type_name}} result {};
          return result;
          {%- endif %}
      }
      {%- else %}
      {# subscript operator getter #}
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_getitem_'), overloading_prefix + template_postfix)}}({{owner_class.converter.c.target_type_name}} cself,
      {%- for arg in args -%}{{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else ' _Nonnull'}}{% endif %} {{arg.name}}{%- endfor-%}) {
          {%- set call_args = [] %}
          {%- for arg in args -%}
          {%- set converter = arg.converter.c_to_cxx %}
          {{converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr)|indent(4)}}
          {%- do call_args.append(converter.converted_name(arg.name))%}
          {% endfor %}
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.root.vars.shared_ref else owner_class.converter.c_to_cxx -%}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          {%- if rconverter.c.target_type_name != 'void' %}
          const auto& result = {{this_converter.converted_name('cself')}}->{{cxx.name}}
                               {%- if cxx.is_template -%}
                               <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>{%- endif -%}({{call_args|join(', ')}});
          {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
          return {{rconverter.cxx_to_c.converted_name('result')}};
          {%- else %}
          {{this_converter.converted_name('cself')}}->{{cxx.name}}({{call_args|join(', ')}});
          {%- endif %}
      }
      {%- if not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference%}
      {# subscript operator setter #}
      {%- set comma = joiner(', ') -%}
      void {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_setitem_'), overloading_prefix + template_postfix)}}({{owner_class.converter.c.target_type_name}} cself, {% for arg in args -%}
          {{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else ' _Nonnull'}}{% endif %} {{arg.name}}{%- endfor-%}{{', ' if args}}{{rconverter.c.target_type_name}}
          {%- if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} value) {
          {%- set call_args = [] %}
          {%- for arg in args -%}
          {%- set converter = arg.converter.c_to_cxx %}
          {{converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr)|indent}}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {% endfor %}
          {{rconverter.c_to_cxx.snippet('value', nullable=vars.nullable_return)|indent(4)}}
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.root.vars.shared_ref else owner_class.converter.c_to_cxx -%}
          {%- if not cxx.is_static %}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          {%- endif %}
          {{this_converter.converted_name('cself')}}->{{cxx.name}}({{call_args|join(', ')}}) = value;
      }
      {%- endif %}
      {%- endif %}
  ch:
    body:
      content: |
        {%- set comma = joiner(', ') -%}
        {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
        {%- set is_subscript_operator = vars.is_operator and vars.name == '[]' -%}
        {%- if not is_subscript_operator -%}
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_getitem_') if is_subscript_operator else vars.name, overloading_prefix + template_postfix)}}(
        {%- if not cxx.is_static -%}
        {{owner_class.converter.c.target_type_name}} cself, {% endif -%}
        {%- for arg in args -%}{{comma()}}{{arg.converter.c.target_type_name}} {% if arg.converter.c.custom.is_c_pointer_type %}{{'_Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else '_Nonnull'}}{% endif %} {{arg.name}}{%- endfor-%}{{', ' if args}}IEGenCObject* _Nonnull err);
        {%- else %}
        {# subscript operator #}
        {%- set comma = joiner(', ') %}
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}
        {%- endif %} {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_getitem_') if is_subscript_operator else vars.name, overloading_prefix + template_postfix)}}({{owner_class.converter.c.target_type_name}} cself, {% for arg in args -%}
        {{comma()}}{{arg.converter.c.target_type_name}} {% if arg.converter.c.custom.is_c_pointer_type %}{{'_Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else '_Nonnull'}}{% endif %} {{arg.name}}{%- endfor-%});
        {# subscript operator setter #}
        {%- if not return_type_info.cxx.is_const_qualified and return_type_info.cxx.is_lval_reference %}
        {% set comma = joiner(', ') %}
        void {{helper.get_c_func_name(owner_class.converter.swift.target_type_name, vars.name|replace('[]', '_setitem_'), overloading_prefix + template_postfix)}}({{owner_class.converter.c.target_type_name}} cself, {% for arg in args -%}
        {{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type %}{{' _Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else ' _Nonnull'}}{% endif %} {{arg.name}}{%- endfor-%}{{', ' if args}}{{rconverter.c.target_type_name}}
        {%- if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} value);
        {%- endif %}
        {%- endif -%}


function:
  swift:
    body: |
      {%- set incorrect_nullable_args = vars.nullable_arg|reject('in', args|map(attribute='name'))|list -%}
      {%- if incorrect_nullable_args -%}
      {%- do Error.critical("{} arguments are marked as nullable but {} does not have such arguments.".format(', '.join(incorrect_nullable_args), cxx.displayname)) -%}
      {%- endif -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- set comma = joiner(', ') -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      public func {{vars.name}}({%- for arg in args -%}{{comma()}}{{arg.name|to_camel_case}}: {{arg.converter.swift.target_type_name}}{{'?' if arg.name in vars.nullable_arg or arg.is_null_ptr}}
        {%- if arg.default -%}
        {%- if arg.is_enum %}
        {%- if arg.default.split('::')|last in arg.type_info.vars.enum_excluded_fields -%}
        {%- do Error.warning("{} field of {} enum is mentioned as excluded field, so it cannot be used as a default value for {} function argument. Iegen is skipping default value addition in target language wrappers.".format(arg.default.split('::')|last, arg.default.split('::')[-2], cxx.displayname)) -%}
        {%- else %} = {{arg.converter.swift.target_type_name}}.{{arg.type_info.vars.enum_field_name_prefix + arg.default.split('::')|last}}
        {%- endif -%}
        {%- else -%}
        {%- if arg.is_literal %} = {{arg.default}}
        {%- elif arg.is_null_ptr %} = nil
        {%- endif %}
        {%- endif %}
        {%- endif %}
        {%- endfor-%}) {{'throws ' if 'no_throw' not in vars.throws}}-> {{rconverter.swift.target_type_name}}{{'?' if vars.nullable_return}} {
        {%- set call_args = [] %}
        {%- for arg in args %}
        {%- set converter = arg.converter.swift_to_sc %}
        {%- set conversion = converter.snippet(arg.name|to_camel_case, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr) %}
        {%- if conversion %}
        {{conversion|indent(2)}}
        {%- endif %}
        {%- do call_args.append(converter.converted_name(arg.name|to_camel_case))%}
        {%- endfor %}
        var err = IEGenCObject()
        {%- set namespace = cxx.namespace.split('::')|map('capitalize')|join %}
        {%- set c_func_name = helper.get_c_func_name(namespace, vars.name, overloading_prefix + template_postfix) %}
        {%- if rconverter.c.target_type_name != 'void' %}
        let result = {{c_func_name}}({{call_args|join(', ')}}{{', ' if call_args}}&err)
        {%- else %}
        {{c_func_name}}({{call_args|join(', ')}}{{', ' if call_args}}&err)
        {%- endif %}
        {%- for arg in args %}
        {%- if arg.converter.sc_cleanup %}
        {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(arg.converter.swift_to_sc.converted_name(arg.name|to_camel_case)) %}
        {%- if cleanup_code_fragment %}
        {{cleanup_code_fragment|indent(2)}}
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        if err.type != nil {
          let errorType = String(cString: err.type!)
          switch errorType {
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws %}
          case ("{{exc_type}}"):
            {%- set exc_info = get_type_info(exc_type) %}
            throw {{exc_info.vars.name}}(err, true)
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          case ("std::exception"):
            {%- set exc_info = get_type_info("std::exception") %}
            let excObj = {{exc_info.vars.name}}(err, true)
            ExceptionHandler.handleUncaughtException(excObj.what())
          {%- endif %}
          default:
            err.type.deallocate()
            ExceptionHandler.handleUncaughtException("Uncaught Exception")
          }
        }
        {%- if rconverter.c.target_type_name != 'void' %}
        {%- set conversion = rconverter.sc_to_swift.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
        {%- if conversion %}
        {{conversion|indent(2)}}
        {%- endif %}
        return {{rconverter.sc_to_swift.converted_name('result')}}
        {%- endif %}
      }{{new_line}}
  cc:
    include: *var_method_cxx_include
    body: |
      {%- set comma = joiner(', ') %}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' %}
      {%- set namespace = cxx.namespace.split('::')|map('capitalize')|join %}
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{helper.get_c_func_name(namespace, vars.name, overloading_prefix + template_postfix)}}(
      {%- for arg in args -%}{{comma()}}{{arg.converter.c.target_type_name}}{% if arg.converter.c.custom.is_c_pointer_type -%}
      {{' _Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else ' _Nonnull'}}{% endif %} {{arg.name}}{%- endfor-%}{{', ' if args}}IEGenCObject* _Nonnull err) {
          {%- set call_args = [] %}
          {%- for arg in args -%}
          {%- set converter = arg.converter.c_to_cxx %}
          {{converter.snippet(arg.name, nullable=arg.name in vars.nullable_arg or arg.is_null_ptr)|indent(4)}}
          {%- do call_args.append(converter.converted_name(arg.name)) %}
          {%- endfor %}
          {%- if rconverter.c.target_type_name != 'void' %}
          try {
              const auto& result = {{cxx.namespace}}::{{cxx.name}}
                                   {%- if cxx.is_template -%}
                                   <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
                                   {%- endif -%}({{call_args|join(', ')}});
              {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(8)}}
              return {{rconverter.cxx_to_c.converted_name('result')}};
          }
          {%- else %}
          try {
              {{cxx.name}}{%- if cxx.is_template -%}
              <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>
              {%- endif -%}({{call_args|join(', ')}});
          }
          {%- endif %}
          {%- if 'no_throw' not in vars.throws %}
          {%- for exc_type in vars.throws -%}
          catch (const {{exc_type}}& e) {
              err->type = strdup("{{exc_type}}");
              err->ptr = new {{exc_type}}(e);
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in vars.throws %}
          catch (const std::exception& e) {
              err->type = strdup("std::exception");
              err->ptr = new std::exception(e);
          }
          {%- endif %}
          catch (...) {
              err->type = strdup("Uncaught Exception");
          }

          {%- if rconverter.c.target_type_name != 'void' %}
          {{rconverter.c.target_type_name}} result {};
          return result;
          {%- endif %}
      }
  ch:
    body:
      content: |
        {%- set comma = joiner(', ') %}
        {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' %}
        {%- set namespace = cxx.namespace.split('::')|map('capitalize')|join %}
        {%- set c_func_name = helper.get_c_func_name(namespace, vars.name, overloading_prefix + template_postfix) %}
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{c_func_name}}(
        {%- for arg in args -%}
        {{comma()}}{{arg.converter.c.target_type_name}} {% if arg.converter.c.custom.is_c_pointer_type %}{{'_Nullable' if arg.name in vars.nullable_arg or arg.is_null_ptr else '_Nonnull'}}{% endif %} {{arg.name}}
        {%- endfor -%}{{', ' if args}}IEGenCObject* _Nonnull err);


var_getter_cxx_include: &var_getter_cxx_include
  unique_content: |
    {%- macro gen_include(type_info, gen_desc_incl=true) -%}
    {%- if type_info.vars and type_info.vars.is_proj_type -%}
    {{marker}}#include "{{type_info.vars.prj_rel_file_name}}"
    {%- endif -%}
    {%- for arg_type_info in type_info.arg_types_infos -%}
    {{gen_include(arg_type_info, gen_desc_incl)}}
    {%- endfor -%}
    {#- `is defined` check is done for enum types (enums don't have descendants) -#}
    {%- if gen_desc_incl and type_info.vars and type_info.vars.descendants is defined and type_info.descendants is defined -%}
    {%- for descendant in (type_info.vars.descendants if type_info.vars.descendants is not none else type_info.descendants) -%}
    {#- generate includes for descendants list of an argument -#}
    {{gen_include(get_type_info(descendant))}}
    {%- endfor -%}
    {%- endif -%}
    {%- endmacro -%}
    {{gen_include(return_type_info, gen_desc_incl=false)}}{{gen_include(owner_class)}}

property_getter:
  swift:
    properties: |
      {%- if not cxx.is_public -%}
      {%- do Error.critical("{}.{} is not a public field. Make it public or remove iegen API.".format(owner_class.cxx.displayname, cxx.displayname)) -%}
      {%- endif -%}
      {%- set result_converter = rconverter.sc_to_swift -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      public var {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} {
        get {
          let result = _prop_get_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}(cself)
          {%- set conversion = result_converter.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          return {{result_converter.converted_name('result')}}
        }
        {%- if vars.action == 'gen_property_setter' %}
        {%- set converter = rconverter.swift_to_sc %}

        set(value) {
          {%- set conversion = converter.snippet('value', nullable=vars.nullable_return) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          _prop_set_{{owner_class.converter.swift.target_type_name|replace('.', '_')}}_{{vars.name}}(cself, {{converter.converted_name('value')}})
          {%- if rconverter.sc_cleanup %}
          {%- set cleanup_code_fragment = arg.converter.sc_cleanup.snippet(converter.converted_name('value')) %}
          {%- if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(4)}}
          {%- endif %}
          {%- endif %}
        }
        {%- endif %}
      }{{new_line}}
    interface_properties: |
      {%- set result_converter = rconverter.sc_to_swift -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      var {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} { get {% if vars.action == 'gen_property_setter' %}set{% endif %} }
  cc:
    include: *var_getter_cxx_include
    body: |
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}({{owner_class.converter.c.target_type_name}} cself){
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.root.vars.shared_ref else owner_class.converter.c_to_cxx -%}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          const auto& result = {{this_converter.converted_name('cself')}}->{{cxx.name}};
          {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(4)}}
          return {{rconverter.cxx_to_c.converted_name('result')}};
      }
      {%- if vars.action == 'gen_property_setter' %}
      void _prop_set_{{owner_class.converter.swift.target_type_name|replace('.', '_')}}_{{vars.name}}({{owner_class.converter.c.target_type_name}} cself, {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{vars.name}}){
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          {{rconverter.c_to_cxx.snippet(vars.name, nullable=vars.nullable_return)|indent(4)}}
          {{this_converter.converted_name('cself')}}->{{cxx.name}} = {{rconverter.c_to_cxx.converted_name(vars.name)}};
      }
      {% endif %}
  ch:
    body:
      content: |
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}({{owner_class.converter.c.target_type_name}} cself);
        {%- if vars.action == 'gen_property_setter' %}
        void _prop_set_{{owner_class.converter.swift.target_type_name|replace('.', '_')}}_{{vars.name}}({{owner_class.converter.c.target_type_name}} cself, {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{vars.name}});
        {% endif %}

getter:
  swift:
    properties: |
      {%- do helper.validate_getter(cxx, vars, args, owner_class, setter|default(none)) -%}
      {%- do helper.validate_template_getter_setter(cxx, vars, owner_class, setter|default(none)) -%}
      {% set result_converter = rconverter.sc_to_swift -%}
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {% if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      {%- set override = cxx.is_override and not is_interface_override -%}
      public {{'override ' if override}}var {% if cxx.is_template -%}
                                           {%- for name in template_names or [] %}
                                           {%- if name != None %}{{name}}{% else %}{{template_type_converters[loop.index - 1].custom.tname}}{% endif %}
                                           {%- endfor %}
                                           {%- else %}{{vars.name}}
                                           {%- endif -%}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} {
        get {
          let result = _prop_get_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{overloading_prefix}}{{template_postfix}}(cself)
          {%- set conversion = result_converter.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          return {{result_converter.converted_name('result')}}
        }
        {%- if setter is defined %}
        {%- set incorrect_nullable_args = setter.vars.nullable_arg|reject('in', setter.args|map(attribute='name'))|list %}
        {%- if incorrect_nullable_args  %}
        {%- do Error.critical("{} arguments are marked as nullable but {}.{} does not have such arguments.".format(', '.join(incorrect_nullable_args), setter.owner_class.cxx.displayname, setter.cxx.displayname)) %}
        {%- endif %}
        {%- set converter = setter.args[0].converter.swift_to_sc %}

        set(value) {
          {%- set conversion = converter.snippet('value', nullable=vars.nullable_return) %}
          {%- if conversion %}
          {{conversion|indent(4)}}
          {%- endif %}
          _prop_set_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{setter.overloading_prefix}}{{template_postfix}}(cself, {{converter.converted_name('value')}})
          {%- if rconverter.sc_cleanup %}
          {%- set cleanup_code_fragment = rconverter.sc_cleanup.snippet(converter.converted_name('value')) %}
          {%- if cleanup_code_fragment %}
          {{cleanup_code_fragment|indent(4)}}
          {%- endif %}
          {%- endif %}
        }
        {%- endif %}
      }{{new_line}}
    interface_properties: |
      {%- set result_converter = rconverter.sc_to_swift -%}
      {%- if vars.comment -%}
      {{vars.comment|make_doxygen_comment}}
      {% endif -%}
      var {{vars.name}}: {{result_converter.target_type_name}}{{'?' if vars.nullable_return}} { get{% if setter is defined %} set{% endif %} }
  cc:
    include: *var_getter_cxx_include
    body: |
      {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
      {%- if cxx.is_template -%}
      {%- set template_args = '<' + template_choice.values()|format_list("{type}", 'type')|join(', ') + '>' %}
      {%- else %}
      {%- set template_args = '' %}
      {%- endif %}
      {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{overloading_prefix}}{{template_postfix}}({{owner_class.converter.c.target_type_name}} cself){
          {%- set this_converter = make_type_converter('std::shared_ptr<' + owner_class.cxx.type_name + '>').c_to_cxx if owner_class.root.vars.shared_ref else owner_class.converter.c_to_cxx -%}
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          const auto& result = {{this_converter.converted_name('cself')}}->{{cxx.name}}{{template_args}}();
          {{rconverter.cxx_to_c.snippet('result', nullable=vars.nullable_return, value_policy=vars.return_value_policy)|indent(4)}}
          return {{rconverter.cxx_to_c.converted_name('result')}};
      }
      {%- if setter is defined %}
      {% set converter = setter.args[0].converter.c_to_cxx %}
      void _prop_set_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{setter.overloading_prefix}}{{template_postfix}}({{owner_class.converter.c.target_type_name}} cself, {{setter.args[0].converter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{setter.args[0].name}}){
          {{this_converter.snippet('cself', cxx_is_pointer=True)|indent(4)}}
          {{converter.snippet(setter.args[0].name, nullable=vars.nullable_return)|indent(4)}}
          {{this_converter.converted_name('cself')}}->{{setter.cxx.name}}{{template_args}}({{converter.converted_name(setter.args[0].name)}});
      }
      {% endif %}
  ch:
    body:
      content: |
        {%- set template_postfix = template_type_converters|format_list("{arg.swift.custom.tname}", 'arg')|join if cxx.is_template else '' -%}
        {{rconverter.c.target_type_name}}{% if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} _prop_get_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{overloading_prefix}}{{template_postfix}}({{owner_class.converter.c.target_type_name}} cself);
        {%- if setter is defined %}
        {% set converter = setter.args[0].converter.c %}
        void _prop_set_{{owner_class.converter.swift.target_type_name|replace('.',  '_')}}_{{vars.name}}{{setter.overloading_prefix}}{{template_postfix}}({{owner_class.converter.c.target_type_name}} cself, {{converter.target_type_name}}
        {%- if rconverter.c.custom.is_c_pointer_type %}{{' _Nullable' if vars.nullable_return else ' _Nonnull'}}{% endif %} {{setter.args[0].name}});
        {% endif %}
