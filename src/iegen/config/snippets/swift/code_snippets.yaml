file:
  swift:
    file_path: |
      {{config.out_dir + pat_sep + [config.package_prefix, package, file]|map('replace', '.', pat_sep)|path_join}}.swift
    scopes:
      - include
      - body
    content: |
      import Foundation
      {{helper_includes|format_list('import {}')|join('\n')}}
      {{include}}

      {{body}}
  cc:
    file_path: |
      {{config.cxx_out_dir + pat_sep + [config.package_prefix, package, 'c_' + file]|map('replace', '.', pat_sep)|path_join}}.cpp
    scopes:
      - body
      - include
    content: |
      #include <string.h>
      #include <memory>
      #include "{{path.relpath(config.cxx_out_dir + pat_sep + [config.package_prefix, package]|map('replace', '.', pat_sep)|path_join, config.out_prj_dir)}}/c_{{file}}.h"
      {{include}}

      {{body}}
  ch:
    file_path: |
      {{config.cxx_out_dir + pat_sep + [config.package_prefix, package, 'c_' + file]|map('replace', '.', pat_sep)|path_join}}.h
    scopes:
      - body
      - include
    content: |
      #ifndef _C_{{file}}_WRAPPER_
      #define _C_{{file}}_WRAPPER_

      {{cxx_helper_includes|format_list('#include "{}"')|join('\n')}}
      {{include}}
      #include <stdbool.h>

      #if __cplusplus
      extern "C" {
      #endif
          {{body | string | indent}}
      #if __cplusplus
      }
      #endif
      #endif /* ifndef _C_{{file}}_WRAPPER_ */
  exceptions_utils_swift:
    file_path: |
      {{config.out_dir + pat_sep + [config.package_prefix, 'exception_helpers', 'utils']|map('replace', '.', pat_sep)|path_join}}.swift
    scopes:
      - body
    content: |
      public class ExceptionHandler {

          static var uncaughtExceptionHandler = defaultHandler;

          static func defaultHandler(_ err_msg: String) {
              print("Uncaught exception is found: \(err_msg)")
              fatalError("Unexpected Exception")
          }

          static func handleUncaughtException(_ err_msg : String) {
              uncaughtExceptionHandler(err_msg)
          }

          public static func setUncaughtExceptionHandler(_ handler: @escaping (String) -> Void) {
              uncaughtExceptionHandler = handler;
          }

          public static func unsetUncaughtExceptionHandler() {
              uncaughtExceptionHandler = defaultHandler;
          }
      }
  std_exceptions_swift:
    file_path: |
      {{config.out_dir + pat_sep + [config.package_prefix, 'exception_helpers', 'std_exc_classes']|map('replace', '.', pat_sep)|path_join}}.swift
    scopes:
      - body
    content: |
      import {{config.c_wrapper_build_name}}
      public enum Exceptions {
      {% for cls, base_cls in helper.Exceptions.get_std_exc_tree() %}
          {{'public' if base_cls else 'open'}} class {{helper.Exceptions.get_exc_name(cls)}} : {{helper.Exceptions.get_exc_name(base_cls) if base_cls else 'Error'}} {
      {% if not base_cls %}
              public let cself : UnsafeMutableRawPointer
              public let owner : Bool

              public init(_ _cself: UnsafeMutableRawPointer, _ _owner: Bool = false) {
                  self.cself = _cself
                  self.owner = _owner
              }
              deinit {
                  if owner {
                      release_std_exception(cself)
                  }
              }

              open func what() -> String {
                  let result = _func_std_exception_what(cself);
                  let sc_to_swift_result = String(cString: result!)
                  return sc_to_swift_result;
              }
      {% endif %}
          }
      {% endfor %}
      }
  std_exceptions_header:
    file_path: |
      {{config.cxx_out_dir + pat_sep + [config.package_prefix, 'exception_helpers', 'c_std_exceptions']|map('replace', '.', pat_sep)|path_join}}.h
    scopes:
      - body
    content: |
      #ifndef _C_std_exceptions_WRAPPER_
      #define _C_std_exceptions_WRAPPER_

      #if __cplusplus
      extern "C" {
      #endif
      void release_std_exception(void* _Nonnull cself);
      const char * _Nullable _func_std_exception_what(void* _Nonnull cself);
      #if __cplusplus
      }
      #endif
      #endif /* ifndef _C_std_exceptions_WRAPPER_ */
  std_exceptions_cpp:
    file_path: |
      {{config.cxx_out_dir + pat_sep + [config.package_prefix, 'exception_helpers', 'c_std_exceptions']|map('replace', '.', pat_sep)|path_join}}.cpp
    scopes:
      - body
    content: |
      #include <string.h>
      #include <memory>
      #include "{{path.relpath(config.cxx_out_dir + pat_sep + [config.package_prefix, 'exception_helpers', 'c_std_exceptions']|map('replace', '.', pat_sep)|path_join)}}.h"

      void release_std_exception(void* _Nonnull cself) {
          delete dynamic_cast<std::exception*>(static_cast<std::exception*>(cself));
      }

      const char * _Nullable _func_std_exception_what(void* _Nonnull cself){
          auto c_to_cxx_cself = dynamic_cast<std::exception*>(static_cast<std::exception*>(cself));
          const auto& result = c_to_cxx_cself->what();
          return result;
      }


enum:
  swift:
    body: |

     public enum {{name}}: CUnsignedInt{
        {%- for case in enum_cases -%}
        {%- if case.comment %}
        {{case.comment|string|indent(2)}}
        {%- endif %}
        case {{case.name}} = {{case.value}}
        {%- endfor %}
      }


class:
  swift:
    include:
      unique_content: |
        {{include|format_list("import {}")|join('\n')}}
    body:
      scopes:
        - head
        - properties
        - body
        - private_external
      content: |
        {{comment}}
        public class {{name}}{{template_suffix}} {% if base_types_converters is defined -%}
                              {%- set comma = joiner(', ') -%}
                              : {% for base_type_converter in base_types_converters -%}
                                {{comma()}}{{base_type_converter.swift.target_type_name}}
                                {%- endfor -%}
                                {% endif %}{%- if helper.Exceptions.is_std_custom_exc(ctx) or (ctx.is_exception and not helper.Exceptions.has_exc_base(ctx)) -%}
                                {{', ' if base_types_converters is defined and base_types_converters|length > 0 else ' : '}}{{'Exceptions.StdException ' if helper.Exceptions.is_std_custom_exc(ctx) else 'Error '}}
                                {%- endif %} {
            {% if not has_non_abstract_base_class and not helper.Exceptions.is_std_custom_exc(ctx)%}
            public let cself : {{converter.sc.target_type_name}}
            public let owner : Bool

            // internal main initializer
            internal required init(_ _cself: {{converter.sc.target_type_name}} , _ _owner: Bool = false) {
              self.cself = _cself
              self.owner = _owner
            }
            deinit {
              if owner {
                release_{{name}}{{template_suffix}}(cself)
              }
            }
            {%endif%}
            {{head|string|indent}}
            {{properties|string|indent}}
            {{body|string|indent}}
        }
  cc:
    include:
      unique_content: |
        #include "{{prj_rel_file_name}}"
        {{include_cxx|format_list('#include "{}"')|join('\n')}}
    body:
      content: |
        void release_{{name}}{{template_suffix}}({{converter.c.target_type_name}} cself) {
            {%- if root.shared_ref %}
            delete static_cast<std::shared_ptr<{{cxx_root_type_name}}>*>(cself);
            {%- else %}
            delete dynamic_cast<{{cxx_type_name}}*>(static_cast<{{cxx_root_type_name}}*>(cself));
            {%- endif %}
        }
  ch:
    body:
      content: |
        void release_{{name}}{{template_suffix}}({{converter.c.target_type_name}} cself);


interface:
  swift:
    include:
      unique_content: |
        {{include|format_list("import {}")|join('\n')}}
    body:
      scopes:
        - interface_head
        - interface_properties
        - interface_body
        - head
        - properties
        - body
      content: |
        {{comment}}
        public protocol {{interface_name}}{{template_suffix}} {% if base_types_converters is defined -%}
                              {%- set comma = joiner(', ') -%}
                              : {% for base_type_converter in base_types_converters -%}
                                {{comma()}}{{base_type_converter.swift.target_type_name}}
                                {%- endfor -%}
                                {% endif %} {

            {% if not base_types_converters is defined %}
            var cself : {{converter.sc.target_type_name}} { get }
            {% endif %}
            {{interface_head|string|indent}}
            {{interface_properties|string|indent}}
            {{interface_body|string|indent}}
        }
        extension {{interface_name}}{{template_suffix}} {
            {{properties|string|indent}}
            {{body|string|indent}}
        }
        public class {{name}}{{template_suffix}} : {{interface_name}}{{template_suffix}} {
            public let cself : {{converter.sc.target_type_name}}
            public let owner : Bool

            // internal main initializer
            internal required init(_ _cself: {{converter.sc.target_type_name}}, _ _owner: Bool = false) {
              self.cself = _cself
              self.owner = _owner
            }
            deinit {
              if owner {
                release_{{name}}{{template_suffix}}(cself)
              }
            }

            {{head|string|indent}}
        }
  cc:
    include:
      unique_content: |
        #include "{{prj_rel_file_name}}"
        {{include_cxx|format_list('#include "{}"')|join('\n')}}
    body:
      content: |
        void release_{{name}}{{template_suffix}}({{converter.c.target_type_name}} cself){
            {%- if root.shared_ref %}
                delete static_cast<std::shared_ptr<{{cxx_root_type_name}}>*>(cself);
            {%- else %}
                delete dynamic_cast<{{cxx_type_name}}*>(static_cast<{{cxx_root_type_name}}*>(cself));
            {%- endif %}
        }
  ch:
    body:
      content: |
        void release_{{name}}{{template_suffix}}({{converter.c.target_type_name}} cself);

constructor:
  swift:
    head: |
      {{comment}}
      public convenience init({{args|format_list("{arg.name}: {arg.converter.swift.target_type_name}", 'arg')|join(', ')}}) {
      {%- set call_args = [] %}
      {% for arg in args -%}
      {%- set converter = arg.converter.swift_to_sc %}
          {{converter.snippet(arg.name)|indent}}
      {%- do call_args.append(converter.converted_name(arg.name)) %}
      {%- endfor %}
          self.init(create_{{owner_class.name}}{{owner_class.template_suffix}}{{overloading_prefix}}({{call_args|join(', ')}}), true)
      }
  cc:
    body: |
      {{owner_class.converter.c.target_type_name}} create_{{owner_class.name}}{{owner_class.template_suffix}}{{overloading_prefix}}({{args|format_list("{arg.converter.c.target_type_name} {arg.name}", 'arg')|join(', ')}}){
        {%- set call_args = [] -%}
        {%- for arg in args -%}
        {% set converter = arg.converter.c_to_cxx %}
          {{converter.snippet(arg.name)|indent}}
        {%- do call_args.append(converter.converted_name(arg.name)) -%}
        {% endfor %}
          auto this_object = new {{owner_class.cxx_type_name}}({{call_args|join(', ')}});
          {%- if owner_class.root.shared_ref %}
          return new std::shared_ptr<{{owner_class.root.cxx_type_name}}>(this_object);
          {%- else %}
          return static_cast<{{owner_class.root.cxx_type_name}}*>(this_object);
          {%- endif %}
      }
  ch:
    body:
      content: |
        {{owner_class.converter.c.target_type_name}} create_{{owner_class.name}}{{owner_class.template_suffix}}{{overloading_prefix}}({{args|format_list("{arg.converter.c.target_type_name} {arg.name}", 'arg')|join(', ')}});

function:
  swift:
    body: |
      {{comment}}
      {%- if is_operator %}
      public static func {{helper.swift.get_map_cxx_operator_name(name)}}(cself: {{owner_class.name}}{{args|format_list(", {arg.name}: {arg.converter.swift.target_type_name}", 'arg')|join}}) {{'throws ' if helper.Exceptions.can_throw(throws)}}-> {{rconverter.swift.target_type_name}} {
        {%- set call_args = ['cself.cself']%}
      {%- else%}
      public {{"static " if is_static}}{{"override " if is_override}}func {{name}}({{args|format_list("{arg.name}: {arg.converter.swift.target_type_name}", 'arg')|join(', ')}}) {{'throws ' if helper.Exceptions.can_throw(throws)}}-> {{rconverter.swift.target_type_name}} {
        {%- set call_args = ['cself'] if not is_static else [] %}
      {%endif%}
        {%- for arg in args %}
        {%- set converter = arg.converter.swift_to_sc %}
          {{converter.snippet(arg.name)|indent}}
        {%- do call_args.append(converter.converted_name(arg.name))%}
        {%- endfor %}
          var err = ErrorObj()
        {%- if rconverter.c.target_type_name != 'void' %}
          let result = {{helper.swift.get_c_func_name("{}{}_{}{}".format(owner_class.name, owner_class.template_suffix, name, overloading_prefix))}}({{call_args|join(', ')}}{{', ' if call_args|length > 0}}&err);
          {{rconverter.sc_to_swift.snippet('result')|indent}}
        {%- else %}
          {{helper.swift.get_c_func_name("{}{}_{}{}".format(owner_class.name, owner_class.template_suffix, name, overloading_prefix))}}({{call_args|join(', ')}}{{', ' if call_args|length > 0}}&err);
        {%- endif %}
          if (err.is_err) {
              let err_type = Int(err.err_type)
              switch(err_type) {
              {%- if helper.Exceptions.can_throw(throws) %}
              {%- for exc_type in throws %}
                  case({{loop.index}}):
                      throw {{'Exceptions.' if helper.Exceptions.is_std_exc(exc_type)}}{{helper.Exceptions.get_exc_name(exc_type)}}(err.err_ptr, true)
              {%- endfor %}
              {%- endif %}
              {%- if not 'std::exception' in throws %}
                  case({{throws|length + 1 if helper.Exceptions.can_throw(throws) else 1}}):
                      let exc_obj = Exceptions.StdException(err.err_ptr, true)
                      ExceptionHandler.handleUncaughtException(exc_obj.what())
              {%- endif %}
                  default:
                      ExceptionHandler.handleUncaughtException("Uncaught Exception")
              }
          }
        {%- if rconverter.c.target_type_name != 'void' %}
          return {{rconverter.sc_to_swift.converted_name('result')}};
        {%- endif %}
      }
    interface_body: |
      {{comment}}
      func {{name}}({{args|format_list("{arg.name}: {arg.converter.swift.target_type_name}", 'arg')|join(', ')}}) {{'throws ' if helper.Exceptions.can_throw(throws)}}-> {{rconverter.swift.target_type_name}}
  cc:
    body: |
      {{rconverter.c.target_type_name}} {{helper.swift.get_c_func_name("{}{}_{}{}".format(owner_class.name, owner_class.template_suffix, name, overloading_prefix))}}(
      {%- if not is_static -%}
      {{owner_class.converter.c.target_type_name}} cself {{args|format_list(", {arg.converter.c.target_type_name} {arg.name}", 'arg')|join}}, ErrorObj* _Nonnull err
      {%- else -%}
      {{args|format_list("{arg.converter.c.target_type_name} {arg.name}", 'arg')|join(', ')}}{{', ' if args|length > 0}}ErrorObj* _Nonnull err
      {%- endif %}){
        {%- set call_args = [] %}
        {%- for arg in args -%}
        {%- set converter = arg.converter.c_to_cxx %}
          {{converter.snippet(arg.name)|indent}}
        {%- do call_args.append(converter.converted_name(arg.name))%}
        {% endfor %}
        {%- if not is_static %}
          {%- if owner_class.root.shared_ref %}
          auto c_to_cxx_cself = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(
                    *static_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(cself)
                    );
          {%- else %}
          auto c_to_cxx_cself = dynamic_cast<{{owner_class.cxx_type_name}}*>(static_cast<{{owner_class.cxx_root_type_name}}*>(cself));
          {%- endif %}
        {%- endif %}

        {%- if rconverter.c.target_type_name != 'void' %}
          try {
            const auto& result = {%if not is_static %}c_to_cxx_cself->{%else%}{{owner_class.cxx_type_name}}::{% endif %}{{cxx_name}}{%- if ctx.node.is_function_template -%}
                                                                      <{{template_choice.values()|format_list("{type}", 'type')|join(', ')}}>{%- endif -%}({{call_args|join(', ')}});
            {{rconverter.cxx_to_c.snippet('result')|indent}}
            return {{rconverter.cxx_to_c.converted_name('result')}};
          }
        {%- else %}
          try {
            {%if not is_static %}c_to_cxx_cself->{%else%}{{owner_class.cxx_type_name}}::{% endif %}{{cxx_name}}({{call_args|join(', ')}});
          }
        {%- endif %}
        {%- if helper.Exceptions.can_throw(throws) %}
          {%- for exc_type in throws -%}
          catch (const {{exc_type}}& e) {
              err->is_err = true;
              err->err_type = {{loop.index}};
              err->err_ptr = new {{exc_type}}(e);
          }
          {%- endfor %}
          {%- endif %}
          {%- if not 'std::exception' in throws %}
          catch (const std::exception& e) {
              err->is_err = true;
              err->err_type = {{throws|length + 1 if helper.Exceptions.can_throw(throws) else 1}};
              err->err_ptr = new std::exception(e);
          }
          {%- endif %}
          catch (...) {
              err->is_err = true;
          }

          {%- if rconverter.c.target_type_name != 'void' %}
          {{rconverter.c.target_type_name}} result;
          return result;
          {%- endif %}
      }
  ch:
    body:
      content: |
        {{rconverter.c.target_type_name}} {{helper.swift.get_c_func_name("{}{}_{}{}".format(owner_class.name, owner_class.template_suffix, name, overloading_prefix))}}(
        {%- if not is_static -%}
        {{owner_class.converter.c.target_type_name}} cself {{args|format_list(", {arg.converter.c.target_type_name} {arg.name}", 'arg')|join}}, ErrorObj* _Nonnull err
        {%- else -%}
        {{args|format_list("{arg.converter.c.target_type_name} {arg.name}", 'arg')|join(', ')}}{{', ' if args|length > 0}}ErrorObj* _Nonnull err
        {%- endif %});
  exceptions_utils_swift:
    body:
  std_exceptions_swift:
    body:
  std_exceptions_header:
    body:
  std_exceptions_cpp:
    body:


property_getter:
  swift:
    properties: |
      {% set result_converter = rconverter.sc_to_swift %}
      {{comment}}
      public var {{name}}: {{result_converter.target_type_name}} {
            get {
              let result = _prop_get_{{owner_class.name}}{{owner_class.template_suffix}}_{{name}}(cself);
              {{result_converter.snippet('result')|indent(8)}}
              return {{result_converter.converted_name('result')}}
            }
            {% if gen_property_setter is defined %}
            {% set converter = rconverter.swift_to_sc %}
            set(value) {
              {{converter.snippet('value')|indent(8)}}
              _prop_set_{{owner_class.name}}{{owner_class.template_suffix}}_{{name}}(cself, {{converter.converted_name('value')}})
            }
            {% endif %}
      }
    interface_properties: |
      {% set result_converter = rconverter.sc_to_swift %}
      {{comment}}
      var {{name}}: {{result_converter.target_type_name}} { get {% if gen_property_setter is defined %}set{% endif %} }
  cc:
    body: |
      {{rconverter.c.target_type_name}} _prop_get_{{owner_class.name}}{{owner_class.template_suffix}}_{{name}}({{owner_class.converter.c.target_type_name}} cself){
          {%- if owner_class.root.shared_ref %}
          auto c_to_cxx_cself = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(
                    *static_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(cself)
                    );
          {%- else %}
          auto c_to_cxx_cself = dynamic_cast<{{owner_class.cxx_type_name}}*>(static_cast<{{owner_class.cxx_root_type_name}}*>(cself));
          {%- endif %}
          auto result = c_to_cxx_cself->{{cxx_name}};
          {{rconverter.cxx_to_c.snippet('result')|indent}}
          return {{rconverter.cxx_to_c.converted_name('result')}};
      }
      {%- if gen_property_setter is defined %}
      void _prop_set_{{owner_class.name}}{{owner_class.template_suffix}}_{{name}}({{owner_class.converter.c.target_type_name}} cself, {{rconverter.c.target_type_name}} {{name}}){
          {%- if owner_class.root.shared_ref %}
          auto c_to_cxx_cself = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(
                    *static_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(cself)
                    );
          {%- else %}
          auto c_to_cxx_cself = dynamic_cast<{{owner_class.cxx_type_name}}*>(static_cast<{{owner_class.cxx_root_type_name}}*>(cself));
          {%- endif %}
          {{rconverter.c_to_cxx.snippet(name)|indent}}
          c_to_cxx_cself->{{cxx_name}} = {{rconverter.c_to_cxx.converted_name(name)}};
      }
      {% endif %}
  ch:
    body:
      content: |
        {{rconverter.c.target_type_name}} _prop_get_{{owner_class.name}}{{owner_class.template_suffix}}_{{name}}({{owner_class.converter.c.target_type_name}} cself);
        {%- if gen_property_setter is defined %}
        void _prop_set_{{owner_class.name}}{{owner_class.template_suffix}}_{{name}}({{owner_class.converter.c.target_type_name}} cself, {{rconverter.c.target_type_name}} {{name}});
        {% endif %}

getter:
  swift:
    properties: |
      {% set result_converter = rconverter.sc_to_swift %}
      {{comment}}
      public var {{name}}: {{result_converter.target_type_name}} {
            get {
              let result = _prop_get_{{owner_class.name}}{{owner_class.template_suffix}}_{{name}}{{overloading_prefix}}(cself);
              {{result_converter.snippet('result')|indent(8)}}
              return {{result_converter.converted_name('result')}}
            }
            {% if setter_ctx is defined %}
            {% set converter = setter_ctx.args[0].converter.swift_to_sc %}
            set(value) {
              {{converter.snippet('value')|indent(8)}}
              _prop_set_{{owner_class.name}}{{owner_class.template_suffix}}_{{setter_ctx.name}}{{setter_ctx.overloading_prefix}}(cself, {{converter.converted_name('value')}})
            }
            {% endif %}
      }
    interface_properties: |
      {% set result_converter = rconverter.sc_to_swift %}
      {{comment}}
      var {{name}}: {{result_converter.target_type_name}} { get{% if setter_ctx is defined %} set{% endif %}
      }
  cc:
    body: |
      {{rconverter.c.target_type_name}} _prop_get_{{owner_class.name}}{{owner_class.template_suffix}}_{{name}}{{overloading_prefix}}({{owner_class.converter.c.target_type_name}} cself){
          {%- if owner_class.root.shared_ref %}
          auto c_to_cxx_cself = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(
                    *static_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(cself)
                    );
          {%- else %}
          auto c_to_cxx_cself = dynamic_cast<{{owner_class.cxx_type_name}}*>(static_cast<{{owner_class.cxx_root_type_name}}*>(cself));
          {%- endif %}
          auto result = c_to_cxx_cself->{{cxx_name}}();
          {{rconverter.cxx_to_c.snippet('result')|indent}}
          return {{rconverter.cxx_to_c.converted_name('result')}};
      }
      {%- if setter_ctx is defined %}
      {% set converter = setter_ctx.args[0].converter.c_to_cxx %}
      void _prop_set_{{owner_class.name}}{{owner_class.template_suffix}}_{{setter_ctx.name}}{{setter_ctx.overloading_prefix}}({{owner_class.converter.c.target_type_name}} cself, {{setter_ctx.args[0].converter.c.target_type_name}} {{setter_ctx.args[0].name}}){
          {%- if owner_class.root.shared_ref %}
          auto c_to_cxx_cself = std::dynamic_pointer_cast<{{owner_class.cxx_type_name}}>(
                    *static_cast<std::shared_ptr<{{owner_class.cxx_root_type_name}}>*>(cself)
                    );
          {%- else %}
          auto c_to_cxx_cself = dynamic_cast<{{owner_class.cxx_type_name}}*>(static_cast<{{owner_class.cxx_root_type_name}}*>(cself));
          {%- endif %}
          {{converter.snippet(setter_ctx.args[0].name)|indent}}
          c_to_cxx_cself->{{setter_ctx.cxx_name}}({{converter.converted_name(setter_ctx.args[0].name)}});
      }
      {% endif %}
  ch:
    body:
      content: |
        {{rconverter.c.target_type_name}} _prop_get_{{owner_class.name}}{{owner_class.template_suffix}}_{{name}}{{overloading_prefix}}({{owner_class.converter.c.target_type_name}} cself);
        {%- if setter_ctx is defined %}
        {% set converter = setter_ctx.args[0].converter.c %}
        void _prop_set_{{owner_class.name}}{{owner_class.template_suffix}}_{{setter_ctx.name}}{{setter_ctx.overloading_prefix}}({{owner_class.converter.c.target_type_name}} cself, {{converter.target_type_name}} {{setter_ctx.args[0].name}});
        {% endif %}
