std::string:
  std::__cxx11::basic_string

std::__1::pair:
  std::pair

std::__1::shared_ptr:
  std::shared_ptr

std::__1::vector:
  std::vector

std::__1::map:
  std::map

std::__1::unordered_map:
  std::map

std::__1::basic_string:
  std::__cxx11::basic_string

$Object:
  custom:
    is_c_pointer_type: False
    tpostfix: |
      {%- for name in template_names or [] -%}
      {%- if name != None %}{{name}}{% else %}{{args_converters[loop.index - 1].swift.custom.tname}}{% endif -%}
      {%- endfor -%}
    tname: |
      {{vars.interface_name if vars.action == 'gen_interface' else vars.name}}{{custom.tpostfix}}
  types:
    swift: |
      {%- if interface_class|default(False) -%}
      {{vars.interface_class_name}}{{custom.tpostfix}}
      {%- else -%}
      {{custom.tname}}
      {%- endif -%}
    c: "CDataObj"
    sc: "CDataObj"
  converters:
    c_to_cxx: |
      {%- set pointee = cxx.pointee_unqualified_name -%}
      {%- set pointee_base = root_types_infos[0].cxx.pointee_unqualified_name -%}
      {#- This section must be replaced with 'c_to_cxx' section of std::shared_ptr converter -#}
      {%- if root_types_infos[0].vars.shared_ref -%}
      {%- set is_nullable = nullable|default(False) -%}
      std::shared_ptr<{{pointee}}> {{target_name}}_shared_ptr{{' = nullptr' if is_nullable}};
      {%- if is_nullable %}
      if ({{name}}.ptr) {
          {%- if pointee_base == pointee %}
          {{target_name}}_shared_ptr = *static_cast<std::shared_ptr<{{pointee}}>*>({{name}}.ptr);
          {%- else %}
          {{target_name}}_shared_ptr = std::dynamic_pointer_cast<{{pointee}}>(*static_cast<std::shared_ptr<{{pointee_base}}>*>({{name}}.ptr));
          {%- endif %}
      }
      {%- else %}
      {%- if pointee_base == pointee %}
      {{target_name}}_shared_ptr = *static_cast<std::shared_ptr<{{pointee}}>*>({{name}}.ptr);
      {%- else %}
      {{target_name}}_shared_ptr = std::dynamic_pointer_cast<{{pointee}}>(*static_cast<std::shared_ptr<{{pointee_base}}>*>({{name}}.ptr);
      {%- endif %}
      {%- endif %}
      auto{{'&' if not cxx_is_pointer}} {{target_name}} = {{'*' if not cxx_is_pointer}}{{target_name}}_shared_ptr.get();
      {%- else %}
      {%- if pointee_base == pointee %}
      auto{{'&' if not cxx_is_pointer}} {{target_name}} = {{'*' if not cxx_is_pointer}}static_cast<{{pointee}}*>({{name}}.ptr);
      {%- else %}
      // we might need to avoid dynamic_cast if there is no multiple inheritance
      auto{{'&' if not cxx_is_pointer}} {{target_name}} = {{'*' if not cxx_is_pointer}}dynamic_cast<{{pointee}}*>(static_cast<{{pointee_base}}*>({{name}}.ptr));
      {%- endif %}
      {%- endif %}
    cxx_to_c: |
      {%- set pointee = cxx.pointee_unqualified_name -%}
      {%- set pointee_base = root_types_infos[0].cxx.pointee_unqualified_name -%}
      {%- if root_types_infos[0].vars.shared_ref -%}
      {%- if not cxx.is_value_type -%}
      {%- do Error.critical('shared_ref variable is set for ' + pointee + '. In this case iegen supports object return only by value or wrapped into shared_ptr') -%}
      {%- else %}
      std::shared_ptr<{{pointee}}> {{name}}_shared_ptr = std::make_shared<{{pointee}}>({{name}});
      {%- set shared_ptr_conv = make_type_converter('std::shared_ptr<{}>'.format(pointee)) %}
      {{shared_ptr_conv.cxx_to_c.snippet(name + '_shared_ptr', target_name=target_name, is_nullable=is_nullable)}}
      {%- endif %}
      {%- else %}
      int code_{{name}} = 0;
      {%- if vars.descendants %}
      int status = 0;
      const char * name = typeid({{'*' if cxx_is_pointer}}{{name}}).name();
      char* res = abi::__cxa_demangle(name, NULL, NULL, &status);
      std::string demangled_{{name}} = (status==0) ? res : name;
      free(res);
      if (demangled_{{name}} == "{{vars.descendants[0]}}") {
          code_{{name}} = 1;
      } {% for descendant in vars.descendants[1:] -%}
      else if (demangled_{{name}} == "{{descendant}}") {
          code_{{name}} = {{loop.index + 1}};
      } {% endfor %}
      {%- endif %}
      {%- if pointee_base == pointee %}
      {{target_type_name}} {{target_name}} = {code_{{name}}, const_cast<{{pointee}}*>({%if cxx_is_pointer%}{{name}}{%elif cxx_is_reference%} &{{name}} {%else%} new {{pointee}}({{name}}) {%endif%})};
      {%- else %}
      auto value_ptr_{{name}} = const_cast<{{pointee}}*>({%if cxx_is_pointer%}{{name}}{%elif cxx_is_reference%} &{{name}} {%else%} new {{pointee}}({{name}}) {%endif%});
      {{target_type_name}} {{target_name}} = {code_{{name}}, static_cast<{{pointee_base}}*>(value_ptr_{{name}})};
      {%- endif %}
      {%- endif %}
    swift_to_sc: |
      {%- if nullable|default(False) -%}
      let {{target_name}} = CDataObj(index: 0, ptr: {{name}}?.cself.ptr)
      {%- else -%}
      let {{target_name}} = {{name}}.cself
      {%- endif -%}
    sc_to_swift: |
      {%- macro create_instance(type_name) -%}
      {%- if nullable|default(False) -%}
      if ({{name}}.ptr != nil) {
          {{target_name}} = {{type_name}}({{name}}{% if cxx_is_value_type%}, true{%endif%})
      }
      {%- else -%}
      {{target_name}} = {{type_name}}({{name}}{% if cxx_is_value_type%}, true{%endif%})
      {%- endif -%}
      {%- endmacro -%}
      var {{target_name}}: {{target_type_name}}{{'? = nil' if nullable|default(False)}}
      {%- if vars.descendants %}
      let {{name|to_camel_case}}Index = Int({{name}}.index)
      switch({{name|to_camel_case}}Index) {
        {%- for descendant in vars.descendants %}
        case({{loop.index}}):
          {%- set converter = make_type_converter(descendant).swift %}
          {%- set type = converter.get_target_type_name(interface_class=converter.vars.action == 'gen_interface') %}
          {{create_instance(type)|indent(4)}}
        {%- endfor %}
        default:
          {%- set type = vars.interface_class_name if vars.action == 'gen_interface' else vars.name %}
          {{create_instance(type + custom.tpostfix)}}
      }
      {%- else %}
      {%- set type = vars.interface_class_name if vars.action == 'gen_interface' else vars.name %}
      {{create_instance(type + custom.tpostfix)}}
      {%- endif %}

$Enum:
  custom:
    is_c_pointer_type: False
    tname: "{{vars.name}}"
  types:
    swift: "{{custom.tname}}"
    c: unsigned int
    sc: CUnsignedInt
  converters:
    c_to_cxx: |
      auto {{target_name}} = ({{target_type_name}}){{name}};
    cxx_to_c: |
      {{target_type_name}} {{target_name}} = ({{target_type_name}}){{name}};
    swift_to_sc: |
      let {{target_name}} = {{name}}.rawValue
    sc_to_swift: |
      let {{target_name}}_optional = {{target_type_name}}(rawValue: {{name}})
      if ({{target_name}}_optional == nil) {
          {{"ExceptionHandler.handleUncaughtException(\"Internal error: unresolved reference to non existing field of " + target_type_name + " enum.\")"}}
      }
      let {{target_name}} = {{target_name}}_optional!

std::__cxx11::basic_string:
  custom:
    is_c_pointer_type: True
    tname: String
  types:
    swift: String
    c: char*
    sc: UnsafeMutablePointer<CChar>
  converters:
    c_to_cxx: |
      auto {{target_name}} = std::string({{name}});
      free({{name}});
    cxx_to_c: |
      auto {{target_name}} = strdup({{name}}.data());
    swift_to_sc: |
      let {{target_name}} = strdup({{name}})!
    sc_to_swift: |
      let {{target_name}} = String(cString: {{name}})
      defer {
        {{name}}.deallocate()
      }

std::string_view:
  custom:
    is_c_pointer_type: True
    tname: String
  types:
    swift: String
    c: char*
    sc: UnsafeMutablePointer<CChar>
  converters:
    c_to_cxx: |
      {{make_type_converter('std::string').c_to_cxx.snippet(name)}}
    cxx_to_c: |
      {{make_type_converter('std::string').cxx_to_c.snippet(name)}}
    swift_to_sc: |
      {{make_type_converter('std::string').swift_to_sc.snippet(name)}}
    sc_to_swift: |
      {{make_type_converter('std::string').sc_to_swift.snippet(name)}}

char *:
  custom:
    is_c_pointer_type: True
    tname: String
  types:
    swift: String
    c: const char *
    sc: UnsafePointer<CChar>?
  converters:
    c_to_cxx:
    cxx_to_c:
    swift_to_sc: |
      let {{target_name}} = {{name}}.cString(using: String.Encoding.utf8){{'!' if not nullable|default(False)}}
    sc_to_swift: |
      let {{target_name}} = String(cString: {{name}}{{'!' if nullable|default(False)}})

std::vector:
  custom:
    is_c_pointer_type: False
    tname: "Array{{args_converters[0].swift.custom.tname}}"
  types:
    swift: "Array<{{args[0].target_type_name}}>"
    c: "CDataArray"
    sc: "CDataArray"
  converters:
    c_to_cxx: |
      {{cxx.pointee_unqualified_name}} {{target_name}};

      auto data_{{name}} = reinterpret_cast<{{args_converters[0].c.target_type_name}}*>({{name}}.data);

      for (size_t _i_{{name}} = 0; _i_{{name}} < {{name}}.size; ++_i_{{name}}) {
          auto& value_{{name}} = data_{{name}}[_i_{{name}}];
          {{args[0].snippet('value_{}'.format(name))|indent(4)}}
          {{target_name}}.emplace_back({{args[0].converted_name('value_{}'.format(name))}});
      }
    cxx_to_c: |
      auto _data_{{target_name}} = new {{args_converters[0].c.target_type_name}} [{{name}}.size()];
      {{target_type_name}} {{target_name}} = { _data_{{target_name}}, (long long){{name}}.size() };
      for (int _i_{{name}} = 0; _i_{{name}} < {{name}}.size(); ++_i_{{name}}) {
          auto& value_{{name}} = {{name}}[_i_{{name}}];
          {{args[0].snippet('value_{}'.format(name))|indent(4)}}
          _data_{{target_name}}[_i_{{name}}] = {{args[0].converted_name('value_{}'.format(name))}};
      }
    swift_to_sc: |
      let _data_{{target_name}} = UnsafeMutablePointer<{{args_converters[0].sc.target_type_name}}>.allocate(capacity: {{name}}.count)
      var {{target_name}} = {{target_type_name}}()
      {{target_name}}.data = UnsafeMutableRawPointer(_data_{{target_name}})
      {{target_name}}.size = Int64({{name}}.count)
      for _i in 0..<{{name}}.count {
          let value_{{name}} = {{name}}[_i]
          {{args[0].snippet('value_{}'.format(name))|indent(4)}}
          _data_{{target_name}}[_i] = {{args[0].converted_name('value_{}'.format(name))}}
      }
    sc_to_swift: |
      let _tmp_{{name}}_data = UnsafeBufferPointer<{{args_converters[0].sc.target_type_name}}>(start: {{name}}.data.assumingMemoryBound(to: {{args_converters[0].sc.target_type_name}}.self), count: Int({{name}}.size))
      var {{target_name}}: [{{args[0].target_type_name}}] = []
      defer {
        _tmp_{{name}}_data.deallocate()
      }
      for _i in 0..<Int({{name}}.size) {
          let value_{{name}} = _tmp_{{name}}_data[_i]
          {{args[0].snippet('value_{}'.format(name))|indent(4)}}
          {{target_name}}.append({{args[0].converted_name('value_{}'.format(name))}})
      }
    sc_cleanup:
      source: swift
      target: sc
      snippet: |
        {%- if args[0] %}
        {%- set cleanup_code_fragment = args[0].snippet('{}_item'.format(name)) %}
        {%- if cleanup_code_fragment %}
        let {{name}}_data = {{name}}.data.assumingMemoryBound(to: {{args_converters[0].sc.target_type_name}}.self)
        for _i in 0..<Int({{name}}.size) {
            let {{name}}_item = {{name}}_data[_i]
            {{cleanup_code_fragment|indent(4)}}
        }
        {%- endif %}
        {%- endif %}
        {{name}}.data.deallocate()

std::map:
  custom:
    is_c_pointer_type: False
    tname: "Dictionary{{args_converters[0].swift.custom.tname}}{{args_converters[1].swift.custom.tname}}"
  types:
    swift: "Dictionary<{{args[0].target_type_name}}, {{args[1].target_type_name}}>"
    c: "CDataMap"
    sc: "CDataMap"
  converters:
    c_to_cxx: |
      {{cxx.pointee_unqualified_name}} {{target_name}};

      for (size_t _i_{{name}} = 0; _i_{{name}} < {{name}}.size; ++_i_{{name}}) {
          auto ktmp_{{name}} = reinterpret_cast<{{args_converters[0].c.target_type_name}}*>({{name}}.keys)[_i_{{name}}];
          auto vtmp_{{name}} = reinterpret_cast<{{args_converters[1].c.target_type_name}}*>({{name}}.values)[_i_{{name}}];
          {{args[0].snippet('ktmp_{}'.format(name))|indent(4)}}
          {{args[1].snippet('vtmp_{}'.format(name))|indent(4)}}
          {{target_name}}.insert({ {{args[0].converted_name('ktmp_{}'.format(name))}}, {{args[1].converted_name('vtmp_{}'.format(name))}} });
      }
    cxx_to_c: |
      auto _k_data_{{target_name}} = new {{args_converters[0].c.target_type_name}} [{{name}}.size()];
      auto _v_data_{{target_name}} = new {{args_converters[1].c.target_type_name}} [{{name}}.size()];
      {{target_type_name}} {{target_name}} = { _k_data_{{target_name}}, _v_data_{{target_name}}, (long long){{name}}.size() };
      size_t _i_{{name}} = 0;
      for (auto& value_{{name}} : {{name}}) {
          const auto& key_{{name}} = value_{{name}}.first;
          const auto& val_{{name}} = value_{{name}}.second;
          {
              {{args[0].snippet('key_{}'.format(name))|indent(8)}}
              {{args[1].snippet('val_{}'.format(name))|indent(8)}}
              _k_data_{{target_name}}[_i_{{name}}] = {{args[0].converted_name('key_{}'.format(name))}};
              _v_data_{{target_name}}[_i_{{name}}] = {{args[1].converted_name('val_{}'.format(name))}};
              _i_{{name}} += 1;
          }
      }
    swift_to_sc: |
      let _key_{{target_name}} = UnsafeMutablePointer<{{args_converters[0].sc.target_type_name}}>.allocate(capacity: {{name}}.count)
      let _val_{{target_name}} = UnsafeMutablePointer<{{args_converters[1].sc.target_type_name}}>.allocate(capacity: {{name}}.count)
      var {{target_name}} = {{target_type_name}}()
      {{target_name}}.keys = UnsafeMutableRawPointer(_key_{{target_name}})
      {{target_name}}.values = UnsafeMutableRawPointer(_val_{{target_name}})
      {{target_name}}.size = Int64({{name}}.count)
      var _i_{{name}} = 0
      for (key_{{name}}, val_{{name}}) in {{name}} {
          {{args[0].snippet('key_{}'.format(name))|indent(4)}}
          {{args[1].snippet('val_{}'.format(name))|indent(4)}}
          _key_{{target_name}}[_i_{{name}}] = {{args[0].converted_name('key_{}'.format(name))}}
          _val_{{target_name}}[_i_{{name}}] = {{args[1].converted_name('val_{}'.format(name))}}
          _i_{{name}} += 1
      }
    sc_to_swift: |
      let _tmp_k_{{name}}_data = UnsafeBufferPointer<{{args_converters[0].sc.target_type_name}}>(start: {{name}}.keys.assumingMemoryBound(to: {{args_converters[0].sc.target_type_name}}.self), count: Int({{name}}.size))
      let _tmp_v_{{name}}_data = UnsafeBufferPointer<{{args_converters[1].sc.target_type_name}}>(start: {{name}}.values.assumingMemoryBound(to: {{args_converters[1].sc.target_type_name}}.self), count: Int({{name}}.size))
      var {{target_name}}: [{{args_converters[0].swift.target_type_name}}:{{args_converters[1].swift.target_type_name}}] = [:]
      defer {
          _tmp_k_{{name}}_data.deallocate()
          _tmp_v_{{name}}_data.deallocate()
      }
      for _i_{{name}} in 0..<Int({{name}}.size) {
          let key_{{name}} = _tmp_k_{{name}}_data[_i_{{name}}]
          let value_{{name}} = _tmp_v_{{name}}_data[_i_{{name}}]
          do {
              {{args[0].snippet('key_{}'.format(name))|indent(8)}}
              {{args[1].snippet('value_{}'.format(name))|indent(8)}}
              {{target_name}}[{{args[0].converted_name('key_{}'.format(name))}}] = {{args[1].converted_name('value_{}'.format(name))}}
          }
      }
    sc_cleanup:
      source: swift
      target: sc
      snippet: |
        {%- if args[1] %}
        {%- set cleanup_code_fragment = args[1].snippet('{}_item'.format(name)) %}
        {%- if cleanup_code_fragment %}
        let {{name}}_data = {{name}}.values.assumingMemoryBound(to: {{args_converters[1].sc.target_type_name}}.self)
        for _i in 0..<Int({{name}}.size) {
            let {{name}}_item = {{name}}_data[_i]
            {{args[1].snippet('{}_item'.format(name))|indent(4)}}
        }
        {%- endif %}
        {%- endif %}
        {{name}}.keys.deallocate()
        {{name}}.values.deallocate()

std::unordered_map:
  std::map

std::shared_ptr:
  custom:
    is_c_pointer_type: False
    tname: "{{args_converters[0].swift.custom.tname}}"
  types:
    swift: "{{args[0].target_type_name}}"
    c: "{{args[0].target_type_name}}"
    sc: "{{args[0].target_type_name}}"
  converters:
    c_to_cxx: |
      {%- if args[0].vars and not args[0].root_types_infos[0].vars.shared_ref -%}
      {%- do Error.critical(args[0].cxx.pointee_unqualified_name + ' has an invalid value for shared_ref variable.') -%}
      {%- endif -%}
      {%- set pointee_unqualified = args[0].cxx.unqualified_type_name %}
      {%- set pointee = args[0].target_type_name %}
      {%- set pointee_root = args[0].root_types_infos[0].cxx.pointee_unqualified_name %}
      {%- set const_qualifier = 'const ' if args[0].cxx.is_const_qualified else '' %}
      {%- set is_nullable = nullable|default(False)%}
      std::shared_ptr<{{pointee}}> {{target_name}}{{' = nullptr' if is_nullable}};
      {%- if is_nullable %}
      if ({{name}}.ptr) {
          {%- if pointee_root == pointee_unqualified %}
          {{target_name}} = *static_cast<std::shared_ptr<{{pointee}}>*>({{name}}.ptr);
          {%- else %}
          {{target_name}} = std::dynamic_pointer_cast<{{pointee}}>(*static_cast<std::shared_ptr<{{const_qualifier}}{{pointee_root}}>*>({{name}}.ptr));
          {%- endif %}
      }
      {%- else %}
      {%- if pointee_root == pointee_unqualified %}
      {{target_name}} = *static_cast<std::shared_ptr<{{pointee}}>*>({{name}}.ptr);
      {%- else %}
      {{target_name}} = std::dynamic_pointer_cast<{{pointee}}>(*static_cast<std::shared_ptr<{{const_qualifier}}{{pointee_root}}>*>({{name}}.ptr));
      {%- endif %}
      {%- endif %}
    cxx_to_c: |
      {%- if args[0].vars and not args[0].root_types_infos[0].vars.shared_ref -%}
      {%- do Error.critical(args[0].cxx.pointee_unqualified_name + ' has an invalid value for shared_ref variable.') -%}
      {%- endif -%}
      {%- set pointee_root = args[0].root_types_infos[0].cxx.pointee_unqualified_name %}
      {%- set pointee_unqualified = args[0].cxx.unqualified_type_name %}
      {%- set pointee = args[0].cxx.type_name %}
      {%- set const_qualifier = 'const ' if args[0].cxx.is_const_qualified else '' %}
      {%- set is_nullable = nullable|default(False)%}
      int code_{{name}} = 0;
      {%- if args[0].vars.descendants %}
      auto& arg_pointee_{{name}} = *{{name}}.get();
      int status = 0;
      const char * name = typeid({{'*' if cxx_is_pointer}}arg_pointee_{{name}}).name();
      char* res = abi::__cxa_demangle(name, NULL, NULL, &status);
      std::string demangled_{{name}} = (status==0) ? res : name;
      free(res);
      if (demangled_{{name}} == "{{args[0].vars.descendants[0]}}") {
          code_{{name}} = 1;
      } {% for descendant in args[0].vars.descendants[1:] -%}
      else if (demangled_{{name}} == "{{descendant}}") {
          code_{{name}} = {{loop.index + 1}};
      } {% endfor %}
      {%- endif %}
      void* {{target_name}}_ptr{{' = nullptr' if is_nullable}};
      {%- if is_nullable %}
      if ({{name}}) {
          {%- if pointee_root != pointee_unqualified %}
          {{target_name}}_ptr = reinterpret_cast<void*>(new std::shared_ptr<{{const_qualifier}}{{pointee_root}}>(std::static_pointer_cast<{{const_qualifier}}{{pointee_root}}>({{name}})));
          {%- else %}
          {{target_name}}_ptr = reinterpret_cast<void*>(new std::shared_ptr<{{pointee}}>({{name}}));
          {%- endif %}
      }
      {%- else %}
      {%- if pointee_root != pointee_unqualified %}
      {{target_name}}_ptr = reinterpret_cast<void*>(new std::shared_ptr<{{const_qualifier}}{{pointee_root}}>(std::static_pointer_cast<{{const_qualifier}}{{pointee_root}}>({{name}})));
      {%- else %}
      {{target_name}}_ptr = reinterpret_cast<void*>(new std::shared_ptr<{{pointee}}>({{name}}));
      {%- endif %}
      {%- endif %}
      {{target_type_name}} {{target_name}} = {code_{{name}}, {{target_name}}_ptr};
    swift_to_sc: |
      {{args[0].snippet(name, nullable=nullable|default(False))|indent}}
    sc_to_swift: |
      {{args[0].snippet(name, nullable=nullable|default(False))|indent}}

std::pair:
  custom:
    is_c_pointer_type: False
    tname: "Pair{{args_converters[0].swift.custom.tname}}{{args_converters[1].swift.custom.tname}}"
  types:
    swift: "({{args[0].target_type_name}}, {{args[1].target_type_name}})"
    c: "CDataPair"
    sc: "CDataPair"
  converters:
    c_to_cxx: |
      auto first_tmp_{{name}} = *reinterpret_cast<{{args_converters[0].c.target_type_name}}*>({{name}}.first);
      auto second_tmp_{{name}} = *reinterpret_cast<{{args_converters[1].c.target_type_name}}*>({{name}}.second);
      {{args[0].snippet('first_tmp_{}'.format(name))}}
      {{args[1].snippet('second_tmp_{}'.format(name))}}
      {{cxx.pointee_unqualified_name}} {{target_name}} { {{args[0].converted_name('first_tmp_{}'.format(name))}}, {{args[1].converted_name('second_tmp_{}'.format(name))}} };
    cxx_to_c: |
      auto _first_data_{{target_name}} = new {{args_converters[0].c.target_type_name}};
      auto _second_data_{{target_name}} = new {{args_converters[1].c.target_type_name}};
      const auto& first_{{name}} = {{name}}.first;
      const auto& second_{{name}} = {{name}}.second;
      {{args[0].snippet('first_{}'.format(name))}}
      {{args[1].snippet('second_{}'.format(name))}}
      *_first_data_{{target_name}} = {{args[0].converted_name('first_{}'.format(name))}};
      *_second_data_{{target_name}} = {{args[1].converted_name('second_{}'.format(name))}};
      {{target_type_name}} {{target_name}} = { _first_data_{{target_name}}, _second_data_{{target_name}} };
    swift_to_sc: |
      let _first_{{target_name}} = UnsafeMutablePointer<{{args_converters[0].sc.target_type_name}}>.allocate(capacity: 1)
      let _second_{{target_name}} = UnsafeMutablePointer<{{args_converters[1].sc.target_type_name}}>.allocate(capacity: 1)
      defer {
        _first_{{target_name}}.deallocate()
        _second_{{target_name}}.deallocate()
      }
      var {{target_name}} = {{target_type_name}}()
      {{target_name}}.first = UnsafeMutableRawPointer(_first_{{target_name}})
      {{target_name}}.second = UnsafeMutableRawPointer(_second_{{target_name}})
      let first_{{name}} = {{name}}.0
      let second_{{name}} = {{name}}.1
      {{args[0].snippet('first_{}'.format(name))}}
      {{args[1].snippet('second_{}'.format(name))}}
      _first_{{target_name}}[0] = {{args[0].converted_name('first_{}'.format(name))}}
      _second_{{target_name}}[0] = {{args[1].converted_name('second_{}'.format(name))}}
    sc_to_swift: |
      let _tmp_pair_first_{{name}}_data = UnsafeBufferPointer<{{args_converters[0].sc.target_type_name}}>(start: {{name}}.first.assumingMemoryBound(to: {{args_converters[0].sc.target_type_name}}.self), count: 1)
      let _tmp_pair_second_{{name}}_data = UnsafeBufferPointer<{{args_converters[1].sc.target_type_name}}>(start: {{name}}.second.assumingMemoryBound(to: {{args_converters[1].sc.target_type_name}}.self), count: 1)
      defer {
        _tmp_pair_first_{{name}}_data.deallocate()
        _tmp_pair_second_{{name}}_data.deallocate()
      }
      let first_{{name}} = _tmp_pair_first_{{name}}_data[0]
      let second_{{name}} = _tmp_pair_second_{{name}}_data[0]
      {{args[0].snippet('first_{}'.format(name))}}
      {{args[1].snippet('second_{}'.format(name))}}
      let {{target_name}}: ({{args_converters[0].swift.target_type_name}}, {{args_converters[1].swift.target_type_name}}) = ({{args[0].converted_name('first_{}'.format(name))}}, {{args[1].converted_name('second_{}'.format(name))}})
